(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6221],{50494:(e,n,t)=>{"use strict";t.d(n,{Z:()=>D});var o=t(87462),r=t(86010),i=t(67294),a=t(45697),s=t.n(a),c=t(44225),l=t(90401),d=t(23184),p=t(90858),u=t(89713),m=t(63680),g=t(78372),y=t(30396);const f=e=>{let{className:n,...t}=e;return i.createElement(c.t,(0,o.Z)({className:(0,r.Z)("text-[#3ddb85]",n)},t))},h=e=>{let{className:n,...t}=e;return i.createElement(l.A,(0,o.Z)({className:(0,r.Z)("text-text",n)},t))};h.propTypes=f.propTypes={className:s().string};const D=[{id:"javascript",name:"JavaScript",icon:function(e){return i.createElement("svg",(0,o.Z)({viewBox:"0 0 48 48",fill:"none",xmlns:"http://www.w3.org/2000/svg"},e),i.createElement("path",{d:"M0 10C0 4.47715 4.47715 0 10 0H38C43.5229 0 48 4.47715 48 10V38C48 43.5229 43.5228 48 38 48H10C4.47715 48 0 43.5228 0 38V10Z",fill:"#F5DE19"}),i.createElement("path",{d:"M32.3894 37.6804C32.8 38.5145 33.4379 39.2155 34.2296 39.7027C35.0213 40.1899 35.9346 40.4435 36.8642 40.4342C38.7402 40.4342 39.9398 39.4962 39.9398 38.1968C39.9398 36.6478 38.7075 36.0936 36.6422 35.19L35.5097 34.7047C32.2396 33.3123 30.071 31.5688 30.071 27.8822C30.071 24.4865 32.6527 21.8997 36.7024 21.8997C38.0134 21.805 39.3232 22.0984 40.4686 22.7433C41.6139 23.3882 42.544 24.356 43.1428 25.5261L39.6025 27.7893C39.3719 27.2092 38.9704 26.7128 38.4512 26.3661C37.9321 26.0194 37.3198 25.8387 36.6956 25.8479C36.4232 25.8206 36.1482 25.8504 35.888 25.9353C35.6278 26.0202 35.3881 26.1584 35.1842 26.341C34.9804 26.5237 34.8168 26.7468 34.7039 26.9961C34.5911 27.2455 34.5314 27.5156 34.5287 27.7893C34.5287 29.1472 35.3703 29.698 37.3134 30.5431L38.4459 31.0284C42.2943 32.6789 44.4698 34.3604 44.4698 38.1417C44.4698 42.219 41.2668 44.453 36.9658 44.453C35.2899 44.5597 33.619 44.1793 32.1546 43.3574C30.6902 42.5356 29.495 41.3076 28.7131 39.8215L32.3894 37.6804ZM16.3917 38.0728C17.1025 39.3344 17.7496 40.4015 19.3055 40.4015C20.7925 40.4015 21.7323 39.8198 21.7323 37.5565V22.1579H26.2605V37.6168C26.2605 42.305 23.5067 44.4392 19.4983 44.4392C18.0814 44.5166 16.6742 44.1635 15.4617 43.4263C14.2493 42.689 13.2883 41.6022 12.7051 40.3086L16.3917 38.0728Z",fill:"black"}))}},{id:"android",name:"Android",icon:f},{id:"ios",name:"iOS",icon:h},{id:"csharp",name:"C#",icon:e=>{let{className:n,...t}=e;return i.createElement(m.F,(0,o.Z)({className:(0,r.Z)("text-[#08940e]",n)},t))}},{id:"http",name:"HTTP",icon:u.d},{id:"raspberrypi",name:"RaspberryPi",icon:e=>{let{className:n,...t}=e;return i.createElement(y.n,(0,o.Z)({className:(0,r.Z)("text-[#cc2555]",n)},t))}},{id:"rust",name:"Rust",icon:e=>{let{className:n,...t}=e;return i.createElement(g.T,(0,o.Z)({className:(0,r.Z)("text-[black]",n)},t))}},{id:"cpp",name:"C++",icon:e=>{let{className:n,...t}=e;return i.createElement(d.q,(0,o.Z)({className:(0,r.Z)("text-[#283492]",n)},t))}},{id:"python",name:"Python",icon:p.i,disabled:!0}]},36438:(e,n,t)=>{"use strict";t.d(n,{p:()=>u,Z:()=>m});var o=t(67294),r=t(80944);const i=e=>{let n=[{label:"JavaScript",value:"javascript"},{label:"Swift",value:"swift"},{label:"Objective-C",value:"objc"},{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"},{label:"C#",value:"csharp"},{label:"C++",value:"cpp"},{label:"Rust",value:"rust"},{label:"HTTP",value:"http"}];switch(e){case"android":n=[{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"}];break;case"ios":n=[{label:"Swift",value:"swift"},{label:"Objective-C",value:"objc"}];break;case"raspberrypi":n=[{label:"NodeJS",value:"javascript"},{label:"C++",value:"cpp"},{label:"Rust",value:"rust"},{label:"HTTP",value:"http"}];case void 0:break;default:n=n.filter((n=>n.value===e))}return n},a=JSON.parse('{"rust":{"remove-query":"let removed_ids = col_tx\\n    .find_with_args(\\"color == $args.color\\", json!({\\"color\\": \\"yellow\\"}))\\n    .remove()\\n    .unwrap();\\n\\n","evict":"let evicted_ids = collection\\n    .find_with_args(\\"$args.color == color\\", json!({\\"color\\": \\"red\\"}))\\n    .sort(vec![sort_param])\\n    .evict()\\n    .unwrap();\\n\\n","sync-basic":"ditto.start_sync()?;\\n\\n","datamodel":"let store = ditto.store();\\nlet collection = store.collection(\\"people\\").unwrap();\\n\\n","upsert-id":"let doc_id = DocumentId::new(&\\"123abc\\".to_string()).unwrap();\\nlet person = json!({ // Person implements serde::Serialize\\n    \\"_id\\": doc_id,\\n    \\"name\\": \\"Susan\\".to_string(),\\n    \\"age\\": 31,\\n});\\ncollection.upsert(person).unwrap();\\n\\n","array-to-map":"collection\\n    .find_by_id(doc_id)\\n    .update(|opt_doc| {\\n        if let Some(doc) = opt_doc {\\n            let friends: DittoRegister = doc.get(\\"friends\\").unwrap();\\n            let mut map = HashMap::new();\\n            let array = friends.value.as_array().unwrap();\\n\\n            for name in array {\\n                let id = Uuid::new_v4().to_string();\\n                let friend = json!({\\n                    \\"name\\": name,\\n                    \\"id\\": id\\n                });\\n                map.insert(id, friend);\\n            }\\n\\n            doc.set(\\"friendsMap\\", map).unwrap();\\n        }\\n    })\\n    .unwrap();\\n\\n","upsert":"let person = json!({\\n    \\"name\\": \\"Susan\\".to_string(),\\n    \\"age\\": 31,\\n});\\nlet collection = ditto.store().collection(\\"people\\").unwrap();\\nlet id = collection.upsert(person).unwrap();\\n\\n","remove-id":"collection.find_by_id(id).remove().unwrap();\\n\\n","upsert-composite-primary-key":"let collection = ditto.store().collection(\\"people\\").unwrap();\\nlet complex_id = PersonId {\\n    user_id: \\"456abc\\".to_string(),\\n    work_id: 789,\\n};\\nlet doc_id = DocumentId::new(&serde_json::json!(complex_id)).unwrap();\\nlet doc = json!({\\n    \\"_id\\": doc_id,\\n    \\"name\\": \\"Susan\\".to_string(),\\n    \\"age\\": 31,\\n});\\ncollection.upsert(doc).unwrap();\\n\\n","upsert-datatypes":"collection\\n    .upsert(json!({\\n      \\"boolean\\": true,\\n      \\"string\\": \\"Hello World\\",\\n      \\"number\\": 10,\\n      \\"map\\": {\\n        \\"key\\": \\"value\\"\\n      },\\n      \\"array\\": [1,2,3],\\n      \\"null\\": null,\\n    }))\\n    .unwrap();\\n\\n","upsert-default-data":"let default_id = DocumentId::new(&\\"123abc\\".to_string()).unwrap();\\nlet data = json!({ // Person implements serde::Serialize\\n    \\"_id\\": default_id,\\n    \\"name\\": \\"Susan\\".to_string(),\\n    \\"age\\": 31,\\n});\\ncollection\\n    .upsert_with_strategy(data, WriteStrategy::InsertDefaultIfAbsent)\\n    .unwrap();\\n\\n","attachment":"let store = ditto.store();\\nlet collection = store.collection(\\"foo\\")?;\\nlet attachment_file_path = images_dir.join(\\"image.png\\");\\nlet mut metadata = HashMap::new();\\nmetadata.insert(\\"some\\".to_owned(), \\"string\\".to_owned());\\nlet attachment =\\n    collection.new_attachment(attachment_file_path.to_str().unwrap(), metadata)?;\\nlet doc_id = DocumentId::new(&\\"123abc\\".to_string())?;\\nlet content = json!({\\"_id\\": doc_id, \\"some\\": \\"string\\", \\"my_attachment\\": attachment});\\nlet _ = collection.upsert(content)?;\\n// Later or on another peer ...\\nlet doc = collection.find_by_id(doc_id).exec()?;\\nlet attachment_token = doc.get::<DittoAttachmentToken>(\\"my_attachment\\")?;\\nlet (tx, rx) = channel();\\nlet m_tx = std::sync::Mutex::new(tx);\\nlet fetcher = collection.fetch_attachment(attachment_token, move |event| {\\n    // completion handler\\n    if let DittoAttachmentFetchEvent::Completed { attachment } = event {\\n        let tx = m_tx.lock().unwrap();\\n        tx.send(attachment).unwrap();\\n    }\\n})?;\\nlet fetched_attachment = rx.recv().unwrap(); // may also use an async version or other sync strategy\\nlet attachment_file_path = fetched_attachment.path();\\nstd::fs::read(attachment_file_path)?;\\n\\n","counter":"let collection = ditto.store().collection(\\"people\\").unwrap();\\nlet doc_id = collection\\n    .upsert(json!({\\"name\\": \\"Frank\\", \\"owned_cars\\": DittoCounter::new()}))\\n    .unwrap();\\n\\ncollection\\n    .find_by_id(doc_id)\\n    .update(|x| {\\n        if let Some(doc) = x {\\n            doc.increment(\\"owned_cars\\", 1.0).unwrap();\\n        }\\n    })\\n    .unwrap();\\n\\n","update":"let collection = ditto.store().collection(\\"people\\").unwrap();\\nlet doc_id = collection\\n    .upsert(json!({\\"name\\": \\"Frank\\", \\"owned_cars\\": DittoCounter::new()}))\\n    .unwrap();\\n\\ncollection\\n    .find_by_id(doc_id)\\n    .update(|opt_doc| {\\n        if let Some(doc) = opt_doc {\\n            doc.set(\\"age\\", 32).unwrap();\\n            doc.increment(\\"owned_cars\\", 1.0).unwrap();\\n        }\\n    })\\n    .unwrap();\\n\\n","query-basic":"collection\\n    .find(\\"favoriteBook.title == \\\\\'The Great Gatsby\\\\\'\\")\\n    .exec()?;\\n\\n","query-args":"let args = json!({\\"name\\": \\"Susan\\", \\"age\\": 32});\\ncollection\\n    .find_with_args(\\"name == $args.name && age <= $args.age\\", args)\\n    .exec()?;\\n\\n","query-sort":"let sort_param = ffi_sdk::COrderByParam {\\n    query_c_str: c!(\\"miles\\"),\\n    direction: ffi_sdk::QuerySortDirection::Ascending,\\n};\\ncollection\\n    .find(\\"color == \\\\\'red\\\\\'\\")\\n    .sort(vec![sort_param])\\n    .exec()?;\\n\\n","query-limit":"let sort_param = ffi_sdk::COrderByParam {\\n    query_c_str: c!(\\"rank\\"),\\n    direction: ffi_sdk::QuerySortDirection::Ascending,\\n};\\ncollection\\n    .find(\\"color == \\\\\'red\\\\\'\\")\\n    .sort(vec![sort_param])\\n    .limit(100)\\n    .exec()?;\\n\\n","subscribe":"let store = ditto.store(); // Ditto must have a longer lifetime than all live queries\\nlet live_query = store\\n    .collection(\\"cars\\")?\\n    .find(\\"color == \\\\\'red\\\\\'\\")\\n    .subscribe();\\n\\n","sync-observe":"let store = ditto.store(); // Ditto must have a longer lifetime than all live queries\\nlet (tx, rx) = channel();\\n{\\n    let live_query = store\\n        .collection(\\"cars\\")?\\n        .find(\\"color == \\\\\'red\\\\\'\\")\\n        .observe_local(move |mut docs: Vec<BoxedDocument>, event| {\\n            match event {\\n                LiveQueryEvent::Initial { .. } => { /* handle if appropriate */ }\\n                LiveQueryEvent::Update { mut insertions, .. } => {\\n                    insertions.sort_by(|a, b| b.cmp(a));\\n                    for idx in insertions.iter() {\\n                        let doc = docs.remove(*idx);\\n                        tx.send(doc).unwrap();\\n                    }\\n                }\\n            }\\n        })?;\\n    store\\n        .collection(\\"cars\\")?\\n        .upsert(json!({\\"color\\": \\"red\\"}))\\n        .unwrap();\\n    for doc in rx.iter() {\\n        println!(\\"New doc {:?}\\", doc);\\n    }\\n} // IMPORTANT: LiveQuery goes out of scope and is Dropped and terminated here.\\n\\n","sync-observe-local":"// Some action in your app ...\\nlet store = ditto.store();\\nstore.collection(\\"cars\\")?.upsert(json!({\\"color\\": \\"red\\"}))?;\\n// Elsewhere register handlers for data changes\\n{\\n    let live_query = store\\n        .collection(\\"cars\\")?\\n        .find(\\"color == \\\\\'red\\\\\'\\")\\n        .observe_local(move |cars, event| {\\n            println!(\\"cars {:?}, event {:?}\\", cars, event);\\n            // do something when data changes\\n            // BUT this closure must be permitted to take ownership\\n        })?;\\n    // stash your live query in something with a long lifetime\\n    // or it will be dropped\\n}\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every\\n// application.\\nlet p256_der_b64: &str = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nlet app_id = AppId::from_env(\\"app\\")?;\\nlet ditto = Ditto::builder()\\n    .with_root(Arc::new(PersistentRoot::from_current_exe()?))\\n    .with_identity(|ditto_root| identity::SharedKey::new(ditto_root, app_id, p256_der_b64))?\\n    .with_minimum_log_level(CLogLevel::Info)\\n    .build()?;\\nlet res = ditto.set_offline_only_license_token(&license_token);\\nditto.start_sync()?;\\n\\n","online-playground":"let ditto = Ditto::builder()\\n    // creates a `ditto_data` folder in the directory containing the executing process\\n    .with_root(Arc::new(PersistentRoot::from_current_exe()?))\\n    .with_identity(|ditto_root| {\\n        // Provided as an env var, may also be provided as hardcoded string\\n        let app_id = AppId::from_env(\\"00000000-0000-4000-0000-000000000000\\")?;\\n        let shared_token = std::env::var(\\"REPLACE_ME_WITH_A_SHARED_TOKEN\\").unwrap();\\n        let enable_cloud_sync = true;\\n        let custom_auth_url = None;\\n        OnlinePlayground::new(\\n            ditto_root,\\n            app_id,\\n            shared_token,\\n            enable_cloud_sync,\\n            custom_auth_url,\\n        )\\n    })?\\n    .build()?;\\n\\nditto.start_sync()?;\\n\\n","offline-playground":"let ditto = Ditto::builder()\\n    // creates a `ditto_data` folder in the directory containing the executing process\\n    .with_root(Arc::new(PersistentRoot::from_current_exe()?))\\n    .with_identity(|ditto_root| {\\n        // Provided as an env var, may also be provided as hardcoded string\\n        let app_id = AppId::from_env(\\"00000000-0000-4000-0000-000000000000\\")?;\\n        OfflinePlayground::new(ditto_root, app_id)\\n    })?\\n    .build()?;\\n\\nditto.start_sync()?;\\nlet res = ditto.set_offline_only_license_token(&license_token);\\n\\n","network-remote-ditto":"let mut config = TransportConfig::new(); // empty\\n\\nconfig\\n    .connect\\n    .tcp_servers\\n    .insert(\\"135.1.5.5:12345\\".to_string()); // Custom TCP Listener\\nconfig\\n    .connect\\n    .tcp_servers\\n    .insert(\\"185.1.5.5:12345\\".to_string()); // Custom TCP Listener\\nconfig\\n    .connect\\n    .websocket_urls\\n    .insert(\\"wss://example.com\\".to_string()); // Custom WS endpoint\\n\\nditto.set_transport_config(config);\\nditto.start_sync()?;\\n\\n","network-listen":"let mut config = TransportConfig::new(); // empty\\n\\nconfig.listen.tcp.enabled = true;\\nconfig.listen.tcp.interface_ip = \\"0.0.0.0\\".to_string();\\nconfig.listen.tcp.port = 4000;\\nconfig.listen.http.enabled = false;\\n\\nditto.set_transport_config(config);\\nditto.start_sync()?;\\n\\n","transport-sync-groups":"let mut config = TransportConfig::new(); // empty\\n\\nconfig.enable_all_peer_to_peer();\\nconfig.global.sync_group = 1234;\\n\\nditto.set_transport_config(config);\\nditto.start_sync()?;\\n\\n","network-multiple-transports":"let mut config = TransportConfig::new(); // empty\\n\\n// 1. Enable auto-discovery of peer to peer connections\\nconfig.enable_all_peer_to_peer(); // Auto-connect via lan and bluetooth\\n\\n// 2. Configure TCP Listener\\nconfig.listen.tcp.enabled = true;\\nconfig.listen.tcp.interface_ip = \\"0.0.0.0\\".to_string();\\nconfig.listen.tcp.port = 4000;\\nconfig.listen.http.enabled = false;\\n\\n// 3. Configure explicit, hard coded connections\\nconfig\\n    .connect\\n    .tcp_servers\\n    .insert(\\"135.1.5.5:12345\\".to_string()); // Custom TCP Listener\\nconfig\\n    .connect\\n    .websocket_urls\\n    .insert(\\"wss://example.com\\".to_string()); // Custom WS endpoint\\n\\nditto.set_transport_config(config);\\nditto.start_sync()?;\\n\\n"},"objc":{"attachment":"NSBundle *testBundle = [NSBundle bundleForClass:self.class];\\nNSURL *attachmentTestImage = [testBundle URLForResource:@\\"attachment_test\\" withExtension:@\\"png\\"];\\nNSData *attachmentData = [NSData dataWithContentsOfURL:attachmentTestImage];\\n\\nNSDictionary<NSString *, NSString *> *metadata = @{@\\"name\\": @\\"my_image.png\\"};\\nDITAttachment *attachment = [collection newAttachment:attachmentTestImage.path metadata:metadata];\\n\\nDITDocumentID *docID = [collection upsert:@{@\\"some\\": @\\"string\\", @\\"my_attachment\\": attachment} error:nil];\\nDITDocument *doc = [[collection findByID:docID] exec];\\nDITAttachmentToken *attachmentToken = doc[@\\"my_attachment\\"].attachmentToken;\\n\\nDITAttachmentFetcher *fetcher = [collection fetchAttachment:attachmentToken onFetchEvent:^(DITAttachmentFetchEvent *event) {\\n    switch (event.type) {\\n        case DITAttachmentFetchEventTypeCompleted: {\\n            DITAttachmentFetchEventCompleted *completed = [event asCompleted];\\n            DITAttachment *fetchedAttachment = completed.attachment;\\n            NSData *fetchedAttachmentData = [fetchedAttachment getData:nil];\\n            [attachmentRoundtripExpectation fulfill];\\n            break;\\n        }\\n        case DITAttachmentFetchEventTypeProgress:\\n            break;\\n        default:\\n            break;\\n    }\\n}];\\n\\n\\n","counter":"[[collection find:@\\"make == \'Honda\'\\"] updateWithBlock:^(NSArray<DITMutableDocument *> *docs) {\\n    for (DITMutableDocument *doc in docs) {\\n        [doc[@\\"mileage\\"] set:DITCounter.new];\\n        [doc[@\\"mileage\\"].counter incrementBy:1];\\n    }\\n}];\\n\\n","datamodel":"DITCollection *collection = [store collection:@\\"people\\"];\\n\\n","upsert-id":"DITDocumentID *docId = [collection upsert:@{@\\"_id\\": @\\"123abc\\", @\\"name\\": @\\"Susan\\", @\\"age\\": @32 } error:nil];\\nNSLog(@\\"%@\\", docId); // => \\"123abc\\"\\n\\n","upsert":"DITDocumentID *docID = [[ditto.store collection:@\\"people\\"]\\n                         upsert:@{ @\\"name\\": @\\"Susan\\", @\\"age\\": @31 }\\n                         error:nil];\\n\\n","upsert-composite-primary-key":"DITDocumentID *docID = [[ditto.store collection:@\\"people\\"]\\n                upsert:@{\\n                  @\\"_id\\": @{ @\\"userId\\": @\\"456abc\\", @\\"workId\\": @789 },\\n                  @\\"name\\": @\\"John\\",\\n                  @\\"age\\": @31 }\\n                error:nil];\\nNSLog(@\\"%@\\", docID); // => \\"NSDictionary @{ @\\"userId\\": \\"456abc\\": @\\"workId\\": @789 }\\"\\n\\n","upsert-datatypes":"[[ditto.store collection:@\\"foo\\"]\\n    upsert:@{\\n        @\\"boolean\\": @true,\\n        @\\"string\\": @\\"Hello World\\",\\n        @\\"number\\": @10,\\n        @\\"map\\": @{ @\\"key\\": @\\"value\\" },\\n        @\\"array\\": @[ @1, @2, @3 ],\\n        @\\"null\\": [NSNull null]\\n    }\\n error:nil\\n];\\n\\n","upsert-default-data":"DITDocumentID *defaultDocID = [[ditto.store collection:@\\"people\\"]\\n                               upsert:@{ @\\"name\\": @\\"Susan\\", @\\"age\\": @31 }\\n                               writeStrategy: DITWriteStrategyInsertDefaultIfAbsent\\n                               error:nil];\\n\\n","query-basic":"NSArray *docs = [[[ditto.store collection:@\\"people\\"]\\n                    find:@\\"favoriteBook.title == \'The Great Gatsby\'\\"] exec];\\n\\n","query-args":"NSArray *documents = [[[ditto.store collection:@\\"people\\"] find:@\\"name == $args.name && age <= $args.age\\" withArgs:@{@\\"age\\": @32, @\\"name\\": @\\"Max\\"}] exec];\\n\\n","remove-query":"NSArray<DITDocumentID *> *removedIDs = [[[ditto.store collection:@\\"people\\"]\\n                                         find:@\\"name == \'Susan\'\\"] remove];\\n\\n","remove-id":"[[[ditto.store collection:@\\"test\\"] findByID:docID] remove];\\n\\n","update":"DITDocumentID *docID = [[ditto.store collection:@\\"people\\"] upsert:@{\\n    @\\"name\\": @\\"Frank\\",\\n    @\\"age\\": [NSNumber numberWithInt:31],\\n    @\\"ownedCars\\": DITCounter.new\\n} error:nil];\\n\\n\\nDITCollection *collection = [ditto.store collection:@\\"people\\"];\\n[[collection findByID:docID] updateWithBlock:^(DITMutableDocument *doc) {\\n    [doc[@\\"age\\"] set:[NSNumber numberWithInt:32]];\\n    [doc[@\\"ownedCars\\"].counter incrementBy:1];\\n}];\\n\\n","array-to-map":"[[collection findByID:docID] updateWithBlock:^(DITMutableDocument *doc) {\\n    NSMutableDictionary *map = [NSMutableDictionary new];\\n    NSArray *names = doc[@\\"friends\\"].arrayValue;\\n    for (id name in names) {\\n        NSString *uuid = [[NSUUID UUID] UUIDString];\\n        map[uuid] = @{\\n            @\\"id\\": uuid,\\n            @\\"name\\": name\\n        };\\n    }\\n    [doc[@\\"friendsMap\\"] set:map];\\n}];\\n\\n","query-sort":"NSArray *sortedRedCars = [[[[ditto.store collection:@\\"cars\\"]\\n                  find:@\\"color == \'red\'\\"]\\n                  sort:@\\"miles\\" direction:DITSortDirectionAscending] exec];\\n\\n","query-limit":"NSArray *sortedAndLimitedRedCars = [[[[[ditto.store collection:@\\"cars\\"]\\n                  find:@\\"color == \'red\'\\"]\\n                  sort:@\\"miles\\" direction:DITSortDirectionAscending]\\n                  limit:100] exec];\\n\\n","sync-basic":"NSError *error = nil;\\n[ditto startSync:&error];\\n\\n","write-transaction":"NSArray *results = [store write:^(DITWriteTransaction *tx) {\\n    DITScopedWriteTransaction *cars = tx[@\\"cars\\"];\\n    DITScopedWriteTransaction *people = tx[@\\"people\\"];\\n    DITDocumentID *docID = [[DITDocumentID alloc] initWithValue: @\\"abc123\\"];\\n    [people upsert:@{@\\"_id\\": docID, @\\"name\\": @\\"Susan\\"} error:nil];\\n    [cars upsert:@{@\\"make\\": @\\"Ford\\", @\\"color\\": @\\"black\\", @\\"owner\\": docID} error:nil];\\n    [cars upsert:@{@\\"make\\": @\\"Toyota\\", @\\"color\\": @\\"red\\", @\\"owner\\": docID} error:nil];\\n}];\\n\\n","sync-observe":"// Register live query to update UI\\nDITCollection *collection = [ditto.store collection:@\\"cars\\"];\\nDITLiveQuery *liveQuery = [[collection find:@\\"color == \'red\'\\"]\\n    observeLocal:^(NSArray<DITDocument *> *docs, DITLiveQueryEvent *event) {\\n\\n}];\\n\\n","subscribe":"// Register live query to update UI\\nDITCollection *collection = [ditto.store collection:@\\"cars\\"];\\nDITSubscription *subscription = [[collection find:@\\"color == \'red\'\\"] subscribe];\\n\\n","sync-observe-local":"// Register live query to update UI\\nDITCollection *collection = [ditto.store collection:@\\"cars\\"];\\n\\nDITLiveQuery *liveQuery = [[collection find:@\\"color == \'red\'\\"]\\n    observeLocal:^(NSArray<DITDocument *> *docs, DITLiveQueryEvent *event) {\\n\\n}];\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nNSString *p256_der_b64 = @\\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nDITIdentity *identity = [[DITIdentity alloc] initSharedKeyWithAppID:@\\"app\\" sharedKey:p256_der_b64];\\nDITDitto *ditto = [[DITDitto alloc] initWithIdentity:identity];\\n\\nNSError *error = nil;\\nif (![ditto setOfflineOnlyLicenseToken:validLicense error:&error]) {\\n    NSLog(@\\"Error setting license: %@\\", error);\\n}\\n\\n","online-playground-cloudSync":"DITIdentity *identity = [[DITIdentity alloc] initOnlinePlaygroundWithAppID:@\\"00000000-0000-4000-0000-000000000000\\"\\n                                                                     token:@\\"REPLACE_ME_WITH_A_SHARED_TOKEN\\"\\n                                                     // Set to false to disable syncing with the cloud\\n                                                      enableDittoCloudSync:YES];\\nDITDitto *ditto = [[DITDitto alloc] initWithIdentity:identity persistenceDirectory: dittoPersistenceDir];\\nNSError *error = nil;\\n[ditto startSync:&error];\\n\\n","online-playground":"DITIdentity *identity = [[DITIdentity alloc] initOnlinePlaygroundWithAppID:@\\"00000000-0000-4000-0000-000000000000\\"\\n                                                                     token:@\\"REPLACE_ME_WITH_A_SHARED_TOKEN\\"\\n                                                      enableDittoCloudSync:YES];\\nDITDitto *ditto = [[DITDitto alloc] initWithIdentity:identity persistenceDirectory: dittoPersistenceDir];\\nNSError *error = nil;\\n[ditto startSync:&error];\\n\\n","offline-playground":"DITIdentity *identity = [[DITIdentity alloc] initOfflinePlaygroundWithAppID:@\\"00000000-0000-4000-0000-000000000000\\"];\\nDITDitto *ditto = [[DITDitto alloc] initWithIdentity:identity];\\nNSError *error = nil;\\nif (![ditto setOfflineOnlyLicenseToken:validLicense error:&error]) {\\n  NSLog(@\\"Error setting license: %@\\", error);\\n}\\nif (![ditto startSync:&error]) {\\n  NSLog(@\\"Error starting sync: %@\\", error);\\n}\\n[ditto startSync:&error];\\n\\n","network-remote-ditto":"DITMutableTransportConfig *transportConfig = [[DITMutableTransportConfig alloc] init];\\n[transportConfig.connect.tcpServers addObject:@\\"135.1.5.5:12345\\"];\\n[transportConfig.connect.tcpServers addObject:@\\"185.1.5.5:12345\\"];\\n[ditto setTransportConfig:transportConfig];\\nNSError *err = nil;\\n[ditto startSync:&err];\\n\\n","network-listen":"DITMutableTransportConfig *transportConfig = [[DITMutableTransportConfig alloc] init];\\n[transportConfig.listen.tcp setEnabled:true];\\n[transportConfig.listen.tcp setInterfaceIp:@\\"0.0.0.0\\"];\\n[transportConfig.listen.tcp setPort:4000];\\n[ditto setTransportConfig:transportConfig];\\nNSError *err = nil;\\n[ditto startSync:&err];\\n\\n","network-multiple-transports":"DITMutableTransportConfig *transportConfig = [[DITMutableTransportConfig alloc] init];\\n// 1. Enable Local Area Network Connections\\n[transportConfig enableAllPeerToPeer];\\n// 2. Listen for incoming connections on port 4000\\n[transportConfig.listen.tcp setEnabled:true];\\n[transportConfig.listen.tcp setInterfaceIp:@\\"0.0.0.0\\"];\\n[transportConfig.listen.tcp setPort:4000];\\n// 3. Connect explicitly to remote devices\\n[transportConfig.connect.tcpServers addObject:@\\"135.1.5.5:12345\\"];\\n[transportConfig.connect.tcpServers addObject:@\\"185.1.5.5:12345\\"];\\n\\n[ditto setTransportConfig:transportConfig];\\nNSError *err = nil;\\n[ditto startSync:&err];\\n\\n","websocket-connect":"DITMutableTransportConfig *transportConfig = [[DITMutableTransportConfig alloc] init];\\n\\n[transportConfig enableAllPeerToPeer];\\n\\n[transportConfig.connect.websocketURLs addObject:@\\"ws://127.0.0.1\\"];\\n\\n[ditto setTransportConfig:transportConfig];\\nNSError *err = nil;\\n[ditto startSync:&err];\\n\\n","transport-configurations":"DITMutableTransportConfig *transportConfig = [[DITMutableTransportConfig alloc] init];\\n\\n//Enable all peer to peer transports\\n[transportConfig enableAllPeerToPeer];\\n\\n//Or enable/disable each transport separately\\n//BluetoothLe\\n[transportConfig.peerToPeer.bluetoothLe setEnabled:true];\\n//Local Area Network\\n[transportConfig.peerToPeer.lan setEnabled:true];\\n//Awdl\\n[transportConfig.peerToPeer.awdl setEnabled:true];\\n\\n[ditto setTransportConfig:transportConfig];\\nNSError *err = nil;\\n[ditto startSync:&err];\\n\\n","network-monitor-conditions":"// Setting up inside a ViewController\\nDITIdentity *identity = [[DITIdentity alloc] initOnlinePlaygroundWithAppID:@\\"REPLACE_WITH_APP_ID\\" token:@\\"REPLACE_WITH_PLAYGROUND_TOKEN\\"];\\nDITDitto *ditto = [[DITDitto alloc] initWithIdentity:identity];\\nditto.delegate = self;\\n[ditto startSync:nil];\\n\\n// Now you can observe real time changes to the transport conditions:\\n@interface ViewController () <DITDittoDelegate>\\n\\n@end\\n\\n@implementation ViewController\\n\\n- (void)transportConditionChanged:(enum DITTransportCondition)condition forSubsystem:(enum DITConditionSource)source {\\n    if (condition == DITTransportConditionBleDisabled) {\\n        NSLog(@\\"BLE disabled\\");\\n    } else if (condition == DITTransportConditionNoBleCentralPermission) {\\n        NSLog(@\\"Permission missing for BLE\\");\\n    } else if (condition == DITTransportConditionNoBlePeripheralPermission) {\\n        NSLog(@\\"Permission missing for BLE\\");\\n    }\\n}\\n\\n@end\\n\\n","network-query-overlap-group":"NSString *const orders = @\\"orders\\";\\n\\n// The passenger only observes orders that they created\\n[[[passenger.store collection:orders] find:@\\"user_id==abc123\\"] observeLocal:^(NSArray<DITDocument *> *docs, DITLiveQueryEvent *event) {\\n    // render my orders in a list UI\\n}];\\n\\n// Crew member devices observe all orders that everyone created\\n[[[crewA.store collection:orders] find:@\\"status == \'OPEN\'\\"] observeLocal:^(NSArray<DITDocument *> *docs, DITLiveQueryEvent *event) {\\n    // render all orders in a list UI\\n}];\\n\\n[[[crewB.store collection:orders] find:@\\"status == \'OPEN\'\\"] observeLocal:^(NSArray<DITDocument *> *docs, DITLiveQueryEvent *event) {\\n    // render all orders\\n}];\\n\\n// Set up our query overlap group and priorities such that the crew members\\n// will construct multihop connections with each other.\\n[DITExperimental setQueryOverlapGroup:2 ditto:crewA];\\n[DITExperimental setQueryOverlapGroup:2 ditto:crewB];\\n\\n// Query overlap groups should be set before startSync\\n[crewA startSync:nil];\\n[crewB startSync:nil];\\n[passenger startSync:nil];\\n\\n","network-set-priority":"[DITExperimental setPriority:DITConnectionPriorityHigh\\n                 forQueryOverlapGroup:2 ditto:crewA];\\n[DITExperimental setPriority:DITConnectionPriorityHigh\\n        forQueryOverlapGroup:2 ditto:crewB];\\n\\n","transport-sync-groups":"DITMutableTransportConfig *transportConfig = [[DITMutableTransportConfig alloc] init];\\n// 1. Enable All Peer to Peer Connection\\n[transportConfig enableAllPeerToPeer];\\n// 2. Set sync group to an integer between 0 and 2^32\\ntransportConfig.global.syncGroup = 12312;\\n\\n[ditto setTransportConfig:transportConfig];\\nNSError *error = nil;\\n[ditto startSync:&error];\\n\\n","evict":"NSArray<DITDocumentID *> *evictedIDs = [[collection find:@\\"make == \'Honda\'\\"] evict];\\n\\n"},"swift":{"transport-sync-groups":"struct User {\\n    var id: String\\n    var restaurantID: UInt32\\n}\\nlet authenticatedUser = User(id: \\"abc123\\", restaurantID: 323234)\\n\\nvar config = DittoTransportConfig()\\n// 1. Enable All Peer to Peer Connections \\nconfig.enableAllPeerToPeer()\\n// 2. Set sync group to an integer between 0 and 2^32\\nconfig.global.syncGroup = authenticatedUser.restaurantID\\nditto.transportConfig = config\\n\\ndo {\\n  try ditto.startSync()\\n} catch (let error) {\\n  print(error.localizedDescription)\\n}\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nlet p256DerB64 = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\"\\n\\nlet identity = DittoIdentity.sharedKey(appID: \\"app\\", sharedKey: p256DerB64)\\nlet ditto = Ditto(identity: identity, persistenceDirectory: dittoPersistenceDir)\\ndo {\\n    try ditto.setOfflineOnlyLicenseToken(validLicense);\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","write-transaction":"ditto.store.write { transaction in\\n    let cars = transaction.scoped(toCollectionNamed: \\"cars\\")\\n    let people = transaction.scoped(toCollectionNamed: \\"people\\")\\n    let docId = \\"abc123\\"\\n    do {\\n        try people.upsert([\\"_id\\": docId, \\"name\\": \\"Susan\\"] as [String: Any?])\\n        try cars.upsert([\\"make\\": \\"Ford\\", \\"color\\": \\"red\\", \\"owner\\": docId] as [String: Any?])\\n        try cars.upsert([\\"make\\": \\"Toyota\\", \\"color\\": \\"black\\", \\"owner\\": docId] as [String: Any?])\\n    } catch (let err) {\\n      print(err.localizedDescription)\\n    }\\n    people.findByID(docId).evict()\\n}\\n\\n","online-playground-cloudSync":"let ditto = Ditto(identity: .onlinePlayground(\\n    appID: \\"00000000-0000-4000-0000-000000000000\\",\\n    token: \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\",\\n    // Set to false to disable syncing with the cloud\\n    enableDittoCloudSync: true\\n))\\ndo {\\n  try ditto.startSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","offline-playground":"var ditto = Ditto(identity: DittoIdentity.offlinePlayground(\\n    appID: \\"00000000-0000-4000-0000-000000000000\\"\\n))\\ntry! ditto.setOfflineOnlyLicenseToken(validLicense);\\ntry! ditto.startSync()\\n\\n","datamodel":"let carsCollection = ditto.store[\\"cars\\"]\\n// or\\nlet carsCollection = ditto.store.collection(\\"cars\\")\\n\\n","attachment":"let collection = ditto.store[\\"foo\\"]\\n\\nlet myImageURL = bundle.url(forResource: \\"image\\", withExtension: \\"png\\")!\\n\\nlet metadata = [\\"name\\": \\"my_image.png\\"]\\nlet attachment = collection.newAttachment(\\n    path: myImageURL.path,\\n    metadata: metadata\\n)!\\n\\nguard let docID = try? collection.upsert([\\"some\\": \\"string\\", \\"my_attachment\\": attachment]) else{\\n    //hanlde error\\n    return\\n}\\n\\n// Later, find the document and the fetch the attachment\\n\\nlet doc = collection.findByID(docID).exec()\\nlet attachmentToken = doc![\\"my_attachment\\"].attachmentToken!\\n\\nlet fetcher = collection.fetchAttachment(token: attachmentToken) { status in\\n    switch status {\\n    case .completed(let fetchedAttachment):\\n        // Do something with attachment\\n        break\\n    default:\\n        print(\\"Unable to fetch attachment\\")\\n        break\\n    }\\n}\\n\\n","upsert-default-data":"do {\\n    let docID = try ditto.store[\\"people\\"].upsert([\\n        \\"name\\": \\"Susan\\",\\n        \\"age\\": 31\\n    ], writeStrategy: .insertDefaultIfAbsent)\\n} catch {\\n    //handle error\\n    print(error)\\n}\\n\\n","upsert-composite-primary-key":"do {\\n    let docID = try ditto.store[\\"people\\"].upsert([\\n        \\"_id\\": [ \\"userId\\": \\"456abc\\", \\"workId\\": 789 ],\\n        \\"name\\": \\"Susan\\",\\n        \\"age\\": 31\\n    ])\\n    print(docID) // \\"[ \\"userId\\": \\"456abc\\", \\"workId\\": 789 ]\\"\\n} catch {\\n    //handle error\\n    print(error)\\n}\\n\\n","upsert-datatypes":"do {\\n    // Insert JSON-compatible data into Ditto\\n    try ditto.store[\\"foo\\"].upsert([\\n        \\"boolean\\": true,\\n        \\"string\\": \\"Hello World\\",\\n        \\"number\\": 10,\\n        \\"map\\": [\\"key\\": \\"value\\"],\\n        \\"array\\": [1,2,3],\\n        \\"null\\": nil\\n    ])\\n}\\ncatch {\\n    //handle error\\n    print(error)\\n}\\n\\n","counter":"do {\\n    let docId = try ditto.store[\\"people\\"].upsert([\\n        \\"name\\": \\"Frank\\",\\n        \\"ownedCars\\": DittoCounter() // here 0 is a number\\n    ])\\n\\n    ditto.store[\\"people\\"].findByID(docId).update({ mutableDoc in\\n        mutableDoc?[\\"ownedCars\\"].counter?.increment(by: 1)\\n    })\\n} catch {\\n    //handle error\\n    print(error)\\n}\\n\\n","update":"do {\\n    let docID = try ditto.store[\\"people\\"].upsert([\\n        \\"name\\": \\"Frank\\",\\n        \\"age\\": 31,\\n        \\"ownedCars\\": DittoCounter()\\n    ])\\n\\n    ditto.store[\\"people\\"].findByID(docID).update { mutableDoc in\\n        mutableDoc?[\\"age\\"] = 32\\n        mutableDoc?[\\"ownedCars\\"].counter?.increment(by: 1)\\n    }\\n} catch {\\n    //handle error\\n    print(error)\\n}\\n\\n","array-to-map":"collection.findByID(docID).update { doc in\\n    guard let doc = doc else {\\n        print(\\"Document with id=\\\\(docID) not found\\")\\n        return\\n    }\\n\\n    let names = doc[\\"friends\\"].arrayValue\\n    var dict = Dictionary<String, Any>()\\n\\n    _ = names.map { name in\\n        let friend: NSMutableDictionary = [:]\\n        let id = UUID().uuidString\\n        friend[\\"id\\"] = id\\n        friend[\\"name\\"] = name\\n        dict.updateValue(friend, forKey: id)\\n    }\\n    doc[\\"friendsMap\\"].set(dict)\\n}\\n\\n","upsert":"do {\\n    // upsert JSON-compatible data into Ditto\\n    let docID = try ditto.store[\\"people\\"].upsert([\\n        \\"name\\": \\"Susan\\",\\n        \\"age\\": 31\\n    ])\\n} catch {\\n    //handle error\\n    print(error)\\n}\\n\\n","upsert-id":"do {\\n    // upsert JSON-compatible data into Ditto\\n    let docID = try ditto.store[\\"people\\"].upsert([\\n        \\"_id\\": \\"abc123\\",\\n        \\"name\\": \\"Susan\\",\\n        \\"age\\": 31\\n    ])\\n    XCTAssertEqual(docID, \\"abc123\\")\\n} catch {\\n    //handle error\\n    print(error)\\n}\\n\\n","query-basic":"let collection = ditto.store[\\"people\\"]\\n    .find(\\"favoriteBook.title == \'The Great Gatsby\'\\")\\n    .exec()\\n\\n","query-args":"let documents = ditto.store[\\"users\\"].find(\\"name == $args.name && age <= $args.age\\", args: [\\n    \\"age\\": 32,\\n    \\"name\\": \\"Max\\"\\n]).exec()\\n\\n","query-sort":"let sortedRedCars = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .sort(\\"miles\\", direction: .ascending)\\n    .exec()\\n\\n","query-limit":"let sortedAndLimitedRedCars = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .sort(\\"miles\\", direction: .ascending)\\n    .limit(100)\\n    .exec()\\n\\n","sync-observe-local":"// --- Action somewhere in your application\\nfunc userDidInsertCar() {\\n    _ = try? ditto.store.collection(\\"cars\\").upsert([\\n        \\"model\\": \\"Ford\\",\\n        \\"color\\": \\"black\\"\\n    ] as [String: Any?])\\n}\\n\\n// Register live query to update UI\\nlet liveQuery = ditto.store.collection(\\"cars\\").find(\\"color == \'red\'\\")\\n    .observeLocal { cars, event in\\n        // do something\\n    }\\n\\n","sync-observe":"// Register live query to update UI\\nlet example = ditto.store.collection(\\"cars\\").find(\\"color == \'red\'\\")\\n   .observeLocal { cars, event in\\n     // do something\\n}\\n\\n","subscribe":"// Register live query to update UI\\nlet subscription = ditto.store.collection(\\"cars\\").find(\\"color == \'red\'\\").subscribe()\\n\\n","network-remote-ditto":"let config = DittoTransportConfig()\\n// Connect explicitly to a remote devices\\nconfig.connect.tcpServers.add(\\"135.1.5.5:12345\\")\\nconfig.connect.tcpServers.add(\\"185.1.5.5:12345\\")\\n\\nditto.transportConfig = config\\n\\ndo {\\n  try ditto.startSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","device-name":"ditto.deviceName = \\"Susan B.\\"\\nlet observer = ditto.presence.observe { presence in\\n    if !presence.remotePeers.isEmpty {\\n        // render peers\\n    }\\n}\\n\\ndo {\\n  try ditto.startSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","network-listen":"let config = DittoTransportConfig()\\n\\n// Listen for incoming connections on port 4000\\nconfig.listen.tcp.isEnabled = true\\nconfig.listen.tcp.interfaceIp = \\"0.0.0.0\\"\\nconfig.listen.tcp.port = 4000\\n\\nditto.transportConfig = config\\n\\ndo {\\n  try ditto.startSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","transport-configurations":"// Create a new DittoTransportConfig()\\nvar config = DittoTransportConfig()\\n\\n//Enable all peer to peer transports\\nconfig.enableAllPeerToPeer()\\n\\n//Or enable/disable each transport separately\\n//BluetoothLe\\nconfig.peerToPeer.bluetoothLe.isEnabled = true\\n//Local Area Network\\nconfig.peerToPeer.lan.isEnabled = true\\n//Awdl\\nconfig.peerToPeer.awdl.isEnabled = true\\n\\nditto.transportConfig = config\\n\\ndo {\\n  try ditto.startSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","network-multiple-transports":"var config = DittoTransportConfig()\\n// 1. Enable All Peer to Peer Connections\\nconfig.enableAllPeerToPeer()\\n\\n// 2. Listen for incoming connections on port 4000\\nconfig.listen.tcp.isEnabled = true\\nconfig.listen.tcp.interfaceIp = \\"0.0.0.0\\"\\nconfig.listen.tcp.port = 4000\\n\\n// 3. Connect explicitly to remote devices\\nconfig.connect.tcpServers.add(\\"135.1.5.5:12345\\")\\nconfig.connect.tcpServers.add(\\"185.1.5.5:12345\\")\\n\\nditto.transportConfig = config\\n\\ndo {\\n  try ditto.startSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","network-monitor-conditions":"// Setting up inside a ViewController\\nlet ditto = Ditto(identity: DittoIdentity.onlinePlayground(appID: \\"00000000-0000-4000-0000-000000000000\\", token: \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\"))\\nditto.delegate = self\\ntry! ditto.startSync()\\n\\n// Now you can observe real time changes to the transport conditions:\\nextension ViewController: DittoDelegate {\\n   func transportConditionDidChange(transportID: Int64, condition: TransportCondition) {\\n       if condition == .BleDisabled {\\n           print(\\"BLE disabled\\")\\n       } else if condition == .NoBleCentralPermission {\\n           print(\\"Permission missing for BLE\\")\\n       } else if condition == .NoBlePeripheralPermission {\\n           print(\\"Permission missing for BLE\\")\\n       }\\n   }\\n\\n\\n","bus-peers-first-user":"// Get the DittoAddress from the first user in the peer object\\nlet observer = ditto.presence.observe { presence in\\n    if !presence.remotePeers.isEmpty {\\n        let user2PeerAddress = presence.remotePeers[0].address\\n    }\\n}\\nobserver.stop()\\n\\n","bus-single-message-receive":"// User2 sets up a delegate to handle inbound requests\\nlet delegate = SingleMessageReceivedDelegate()\\nditto.bus?.delegate = delegate\\n\\nclass SingleMessageReceivedDelegate: DittoBusDelegate {\\n    var receivedMessage: Data?\\n    \\n    func dittoBus(_ bus: DittoBus, didReceiveSingleMessage message: DittoBusMessage) {\\n        self.receivedMessage = message.data\\n    }\\n    \\n    func dittoBus(_ bus: DittoBus, didReceiveIncomingStream busStream: DittoBusStream, fromPeer peer: DittoAddress) {\\n        // not implemented\\n    }\\n}\\n\\n","bus-reliable-single-message-send":"// User1 sends data to User2. Success provides guarantee of data delivery.\\nlet data = Data([1, 2, 3, 4, 5])\\nditto.bus?.sendSingleReliableMessage(data, to: user2PeerAddress, completion: { error in\\n    if let error {\\n        // success\\n    }\\n})\\n\\n","bus-unreliable-single-message-send":"// User1 sends data to User2. Success provides guarantee of data sent.\\nlet data = Data([1, 2, 3, 4, 5])\\nditto.bus?.sendSingleUnreliableMessage(data, to: user2PeerAddress, completion: { error in\\n    if let error {\\n        // success\\n    }\\n})\\n\\n","bus-bidirectional-stream-common":"// Common Classes\\n\\n// Handles new stream requests\\nclass IncomingStreamReceivedDelegate: DittoBusDelegate {\\n    var connectedStream: DittoBusStream?\\n    var streamDelegate: DittoBusStreamDelegate?\\n\\n    func dittoBus(_ bus: DittoBus, didReceiveSingleMessage message: DittoBusMessage) {\\n        // Not implemented\\n    }\\n\\n    func dittoBus(_ bus: DittoBus, didReceiveIncomingStream busStream: DittoBusStream, fromPeer peer: DittoAddress) {\\n        self.connectedStream = busStream\\n        busStream.delegate = self.streamDelegate\\n    }\\n}\\n\\n/// Handles operations/messages on a connected stream\\nclass StreamDelegate: DittoBusStreamDelegate {\\n    /// A new message has been received from the specified stream.\\n    func dittoBusStream(_ busStream: DittoBusStream, didReceiveMessage message: Data) {\\n        // handle message received\\n    }\\n\\n    /// The stream has closed. This can be triggered by calling close() or by the remote peer doing the same.\\n    func dittoBusStream(_ busStream: DittoBusStream, didClose error: DittoSwiftError) {\\n        // handle connection closed\\n    }\\n\\n    // The operation to enqueue outgoing data on a stream has completed. More data may now be enqueued.\\n    // The message sequence number may be used to track when the remote side has fully acknowledged receipt.\\n    // `error` will be non-nil if the operation failed.\\n    func dittoBusStream(_ busStream: DittoBusStream, didEnqueueDataWithMessageSequence messageSequence: UInt64, error: DittoSwiftError?) {\\n        // handle did enqueue data\\n    }\\n\\n    // The remote peer has acknowledged receipt of all messages up to the given sequence number.\\n    func dittoBusStream(_ busStream: DittoBusStream, didAcknowledgeReceipt messageSequence: UInt64) {\\n        // handle did data was received\\n    }\\n}\\n\\n","bus-bidirectional-stream-handler":"// User2 - Create a delegate to handle inbound stream requests\\nlet incomingDelegate = IncomingStreamReceivedDelegate()\\n// Attach a StreamDelegate to handle messages once a connection is established\\nincomingDelegate.streamDelegate = StreamDelegate()\\nditto.bus?.delegate = incomingDelegate\\n\\n// Send a message\\nlet data = Data([1, 2, 3, 4, 5])\\nincomingDelegate.connectedStream?.enqueueMessage(data: data)\\n\\n// Close the stream\\nincomingDelegate.connectedStream?.close()\\n\\n","bus-reliable-bidirectional-stream-sender":"// User1 - Reliable Bidirectional Stream\\n\\nlet incomingDelegate = IncomingStreamReceivedDelegate()\\nditto.bus?.delegate = incomingDelegate\\n\\nlet streamDelegate = StreamDelegate()\\nvar user1Stream: DittoBusStream?\\nditto1.bus?.openStream(toAddress: user2PeerAddress, reliability: .reliable) { stream, err in\\n    user1Stream = stream\\n    stream?.delegate = streamDelegate\\n}\\n\\n// Send Message\\nlet data = Data([1, 2, 3, 4, 5])\\nuser1Stream?.enqueueMessage(data: data)\\n\\n// An ID unique to the local device that can be used to track this individual stream.\\n_ = user1Stream?.id\\n\\n// close\\nuser1Stream?.close()\\n\\n","bus-unreliable-bidirectional-stream-sender":"// User1 - Unreliable Bidirectional Stream\\nlet incomingDelegate = IncomingStreamReceivedDelegate()\\nditto.bus?.delegate = incomingDelegate\\n\\nlet streamDelegate = StreamDelegate()\\nvar user1Stream: DittoBusStream?\\nditto1.bus?.openStream(toAddress: user2PeerAddress, reliability: .unreliable) { stream, err in\\n    user1Stream = stream\\n    stream?.delegate = streamDelegate\\n}\\n\\n// Send Message\\nlet data = Data([1, 2, 3, 4, 5])\\nuser1Stream?.enqueueMessage(data: data)\\n\\n// An ID unique to the local device that can be used to track this individual stream.\\n_ = user1Stream?.id\\n\\n// close\\nuser1Stream?.close()\\n\\n","network-query-overlap-group":"// The passenger only observes orders that they created\\nlet passengerQuery = passenger.store.collection(\\"orders\\").find(\\"user_id==abc123\\")\\nlet passengerSubscription = passengerQuery.subscribe()\\nlet passengerLiveQuery = passengerQuery.observeLocal { docs, event in\\n  // render passenger orders in a list UI\\n}\\n\\n// Crew member devices observe all orders that everyone created\\nlet crewAQuery = crewA.store.collection(\\"orders\\").findAll()\\nlet crewASubscription = crewAQuery.subscribe()\\nlet crewALiveQuery = crewAQuery.observeLocal { docs, event in\\n  // render all orders in a list UI\\n}\\nlet crewBQuery = crewB.store.collection(\\"orders\\").findAll()\\nlet crewBSubscription = crewBQuery.subscribe()\\nlet crewBLiveQuery = crewBQuery.observeLocal { docs, event in\\n  // render all orders in a list UI\\n}\\n\\n// Set up our query overlap group and priorities such that the crew members\\n// will construct multihop connections with each other.\\nDittoExperimental.setQueryOverlapGroup(queryOverlapGroup: 2, ditto: crewA)\\nDittoExperimental.setQueryOverlapGroup(queryOverlapGroup: 2, ditto: crewB)\\n\\n// Query overlap groups should be set before startSync\\ntry! passenger.startSync()\\ntry! crewA.startSync()\\ntry! crewB.startSync()\\n\\n","network-set-priority":"DittoExperimental.setPriority(DittoConnectionPriority.high, forQueryOverlapGroup: 2, ditto: crewA)\\nDittoExperimental.setPriority(DittoConnectionPriority.high, forQueryOverlapGroup: 2, ditto: crewB)\\n\\n","evict":"collection.find(\\"owner == \'Bob\'\\").evict()\\n\\n","remove-query":"collection.find(\\"owner == \'Bob\'\\").remove()\\n\\n","remove-id":"collection.findByID(docID).remove()\\n\\n","sync-basic":"try! ditto.startSync()\\n\\n"},"cpp":{"sync-observe-local":"// --- Register live query to update UI\\nstd::shared_ptr<LiveQuery> query =\\n    collection.find(\\"color == \'red\'\\")\\n        .observe_local([&](std::vector<Document> docs, LiveQueryEvent event) {\\n\\n        });\\n\\n","datamodel":"Collection cars_collection = ditto.get_store().collection(\\"cars\\");\\n\\n","upsert-id":"json person = json({{\\"_id\\", \\"123abc\\"}, {\\"name\\", \\"Susan\\"}, {\\"age\\", 31}});\\nDocumentId doc_id = ditto.get_store().collection(\\"people\\").upsert(person);\\n\\n","upsert":"json person = json({{\\"name\\", \\"Susan\\"}, {\\"age\\", 31}});\\nDocumentId doc_id = ditto.get_store().collection(\\"people\\").upsert(person);\\n\\n","upsert-composite-primary-key":"json content = json({{\\"_id\\", {{\\"userId\\", \\"456abc\\"}, {\\"workId\\", 789}}},\\n                     {\\"name\\", \\"Susan\\"},\\n                     {\\"age\\", 31}});\\nDocumentId doc_ID = ditto.get_store().collection(\\"people\\").upsert(content);\\n\\n","upsert-datatypes":"// Insert JSON-compatible data into Ditto\\nditto.get_store().collection(\\"foo\\").upsert(json({{\\"boolean\\", true},\\n                                                 {\\"string\\", \\"Hello World\\"},\\n                                                 {\\"number\\", 10},\\n                                                 {\\"map\\", {{\\"key\\", \\"value\\"}}},\\n                                                 {\\"array\\", {1, 2, 3}},\\n                                                 {\\"null\\", NULL}}));\\n\\n","write-transaction":"auto results = ditto.get_store().write([&](WriteTransaction &write_txn) {\\n  ScopedWriteTransaction people = write_txn.scoped(\\"people\\");\\n  ScopedWriteTransaction cars = write_txn.scoped(\\"cars\\");\\n  auto docId = \\"abc123\\";\\n  people.upsert({{\\"name\\", \\"Susan\\"}, {\\"_id\\", DocumentId(docId)}});\\n  cars.upsert({{\\"make\\", \\"Hyundai\\"}, {\\"owner\\", DocumentId(docId)}});\\n  cars.upsert({{\\"make\\", \\"Toyota\\"}, {\\"owner\\", DocumentId(docId)}});\\n});\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared\\n// key for every application.\\nconst std::string p256_der_b64 =\\n    \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4\\"\\n    \\"hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlq\\"\\n    \\"nfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nDitto ditto = ditto::Ditto(Identity::SharedKey(\\"\\", p256_der_b64), path);\\nditto.set_offline_only_license_token(valid_license);\\n\\n","attachment":"auto attachment_file_path = fs::path(images_path.string() + \\"/image.png\\");\\nstd::map<std::string, std::string> metadata = {{\\"some\\", \\"string\\"}};\\n\\nAttachment attachment =\\n    collection.new_attachment(attachment_file_path.string(), metadata);\\n\\nauto doc_id =\\n    collection.upsert({{\\"some\\", \\"string\\"}, {\\"my_attachment\\", attachment}});\\n\\n// Later, find the document and the fetch the attachment\\nauto doc = collection.find_by_id(doc_id).exec();\\nauto att_token = (*doc)[\\"my_attachment\\"].get_attachment_token();\\n\\nauto fetcher = collection.fetch_attachment(\\n    att_token,\\n    AttachmentFetcherEventHandler{\\n        [&](std::unique_ptr<AttachmentFetchEvent> event) {\\n          switch (event->type) {\\n          case AttachmentFetchEventType::Completed: {\\n            AttachmentFetchEventCompleted *completed_event =\\n                static_cast<AttachmentFetchEventCompleted *>(event.get());\\n            Attachment fetched_attachment = completed_event->attachment;\\n            // Do something with attachment\\n            break;\\n          }\\n          default:\\n            std::cout << \\"Unable to fetch attachment\\" << std::endl;\\n          }\\n        }});\\n\\n","array-to-map":"ditto.get_store().collection(\\"people\\").find_by_id(docID).update(\\n    [](MutableDocument &doc) {\\n      auto friendsMap = json::object();\\n      auto array = doc[\\"friends\\"].get_json();\\n      for (size_t i = 0; i < array.size(); i++) {\\n        auto name = array[i];\\n        friendsMap[\\"my_id\\"] = json({{\\"name\\", name}, {\\"id\\", \\"my_id\\"}});\\n      };\\n      doc[\\"friendsMap\\"].set(friendsMap);\\n    });\\n\\n","counter":"DocumentId docID = ditto.get_store().collection(\\"people\\").upsert(\\n    {{\\"name\\", \\"Frank\\"}, {\\"ownedCars\\", Counter()}});\\n\\nditto.get_store().collection(\\"people\\").find_by_id(docID).update(\\n    [](MutableDocument &doc) {\\n      auto counter = doc[\\"ownedCars\\"].get_counter();\\n      counter->increment(1);\\n    });\\n\\n","update":"DocumentId doc_id = ditto.get_store().collection(\\"people\\").upsert(\\n    {{\\"name\\", \\"Frank\\"}, {\\"age\\", 31}, {\\"ownedCars\\", Counter()}});\\n\\nditto.get_store().collection(\\"people\\").find_by_id(doc_id).update(\\n    [](MutableDocument &doc) {\\n      doc[\\"age\\"].set(32);\\n      auto counter = doc[\\"ownedCars\\"].get_counter();\\n      counter->increment(1);\\n    });\\n\\n","remove-id":"ditto.get_store().collection(\\"people\\").find_by_id(doc_id).remove();\\n\\n","remove-query":"ditto.get_store().collection(\\"people\\").find(\\"age <= 32\\").remove();\\n\\n","evict":"ditto.get_store().collection(\\"people\\").find(\\"age <= 32\\").evict();\\n\\n","upsert-default-data":"DocumentId doc_id = ditto.get_store().collection(\\"people\\").upsert(\\n    content, WriteStrategy::insertDefaultIfAbsent);\\n\\n","query-basic":"std::vector<Document> results =\\n    ditto.get_store()\\n        .collection(\\"people\\")\\n        .find(\\"favoriteBook.title == \'The Great Gatsby\'\\")\\n        .exec();\\n\\n","query-args":"json args = json({{\\"age\\", 32}, {\\"name\\", \\"max\\"}});\\nstd::vector<Document> big_c_values =\\n    ditto.get_store()\\n        .collection(\\"people\\")\\n        .find(\\"name == $args.name && age <= $args.age\\", args)\\n        .exec();\\n\\n","query-sort":"std::vector<Document> sorted_red_cars =\\n    ditto.get_store()\\n        .collection(\\"cars\\")\\n        .find(\\"color == \'red\'\\")\\n        .sort(\\"miles\\", SortDirection::ascending)\\n        .exec();\\n\\n","query-limit":"std::vector<Document> sorted_and_limited_red_cars =\\n    ditto.get_store()\\n        .collection(\\"cars\\")\\n        .find(\\"color == \'red\'\\")\\n        .sort(\\"miles\\", SortDirection::ascending)\\n        .limit(100)\\n        .exec();\\n\\n","sync-basic":"try {\\n  ditto.start_sync();\\n} catch (const DittoError &err) {\\n  std::cerr << err.what();\\n}\\n\\n","subscribe":"std::shared_ptr<ditto::Subscription> subscription =\\n    collection.find(\\"color == \'red\'\\").subscribe();\\n\\n","sync-observe":"std::shared_ptr<LiveQuery> liveQuery =\\n    collection.find(\\"color == \'red\'\\")\\n        .observe_local([&](std::vector<Document> docs, LiveQueryEvent event) {\\n          // do something\\n        });\\n\\n","online-playground":"Ditto ditto;\\nauto identity =\\n    Identity::OnlinePlayground(\\"00000000-0000-4000-0000-000000000000\\",\\n                               \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\", true);\\ntry {\\n  ditto = Ditto(identity, dir);\\n  ditto.start_sync();\\n} catch (const DittoError &err) {\\n}\\n\\n","offline-playground":"Ditto ditto;\\nauto identity =\\n    Identity::OfflinePlayground(\\"00000000-0000-4000-0000-000000000000\\", 1234);\\ntry {\\n  ditto = Ditto(identity, dir);\\n\\n  ditto.set_offline_only_license_token(valid_license);\\n  ditto.start_sync();\\n} catch (const DittoError &err) {\\n}\\n\\n","network-remote-ditto":"auto config = ditto::TransportConfig();\\n// Connect explicitly to remote devices\\nconfig.connect.tcp_servers.insert(\\"135.1.5.5:12345\\");\\nconfig.connect.tcp_servers.insert(\\"185.1.5.5:12345\\");\\n\\n// set the transport config\\nditto.set_transport_config(config);\\n// now you can start ditto\'s sync\\nditto.start_sync();\\n\\n","transport-sync-groups":"auto config = ditto::TransportConfig();\\n\\nconfig.enable_all_peer_to_peer();\\nconfig.global.sync_group = 1234;\\n\\n// set the transport config\\nditto.set_transport_config(config);\\n// now you can start ditto\'s sync\\nditto.start_sync();\\n\\n","network-listen":"auto config = ditto::TransportConfig();\\n\\nconfig.listen.tcp.enabled = true;\\nconfig.listen.http.enabled = false;\\nconfig.listen.tcp.interface_ip = \\"0.0.0.0\\";\\nconfig.listen.tcp.port = 4000;\\n\\nditto.set_transport_config(config);\\nditto.start_sync();\\n\\n","network-multiple-transports":"auto config = ditto::TransportConfig();\\n// 1. Enable All Peer to Peer Connections\\nconfig.enable_all_peer_to_peer();\\n\\n// 2. Listen for incoming connections on port 4000\\nconfig.listen.tcp.enabled = true;\\nconfig.listen.http.enabled = false;\\nconfig.listen.tcp.interface_ip = \\"0.0.0.0\\";\\nconfig.listen.tcp.port = 4000;\\n\\n// 3. Connect explicitly to remote devices\\nconfig.connect.tcp_servers.insert(\\"135.1.5.5:12345\\");\\nconfig.connect.tcp_servers.insert(\\"185.1.5.5:12345\\");\\n\\nditto.set_transport_config(config);\\nditto.start_sync();\\n\\n"},"http":{"upsert-composite-primary-key":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v3/store/write\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n      [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"id\\": { \\n          \\"user_id\\": \\"456abc\\",\\n          \\"work_id\\": 789\\n        },\\n        \\"value\\": {\\n          \\"name\\": \\"Susan\\", \\n          \\"age\\": 31\\n        }\\n      }]\\n  }\'\\n\\n","upsert":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v3/store/write\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n      \\"commands\\": [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"id\\": \\"abc123\\",\\n        \\"value\\": {\\n          \\"name\\": \\"Susan\\", \\"age\\": 31\\n        }\\n      }]\\n  }\'\\n\\n","upsert-id":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v3/store/write\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n      \\"commands\\": [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"id\\": \\"456abc\\",\\n        \\"value\\": {\\n          \\"name\\": \\"Susan\\", \\n          \\"age\\": 31\\n        }\\n      }]\\n  }\'\\n\\n","upsert-datatypes":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v3/store/write\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n      \\"commands\\": [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"id\\": \\"456abc\\",\\n        \\"value\\": {\\n          \\"boolean\\": true, \\n          \\"string\\": \\"Hello World\\",\\n          \\"number\\": 10,\\n          \\"map\\": {\\n            \\"key\\": \\"value\\",\\n          },\\n          \\"array\\": [1,2,3],\\n          \\"null\\": null\\n        }\\n      }]\\n  }\'\\n\\n","update":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v3/store/write\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n      \\"commands\\": [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"id\\": \\"123abc\\",\\n        \\"value\\": {\\n          \\"name\\": \\"Frank\\", \\n          \\"age\\": 32,\\n          \\"friends\\": [\\"Susan\\"],\\n          \\"owned_cars\\": 0\\n        }\\n      }]\\n  }\'\\n\\n","query-basic":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v3/store/find\' \\\\\\n--header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n--header \'Content-Type: application/json\' \\\\\\n--data-raw \'{\\n    \\"collection\\": \\"people\\",\\n    \\"query\\": \\"favoriteBook.title == \'The Great Gatsby\'\\"\\n  }\'\\n\\n","query-args":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v3/store/find\' \\\\\\n--header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n--header \'Content-Type: application/json\' \\\\\\n--data-raw \'{\\n    \\"args\\": {\\n      \\"name\\": \\"max\\",\\n      \\"age\\": 32\\n    },\\n    \\"collection\\": \\"people\\",\\n    \\"query\\": \\"name == $args.name && age <= $args.age\\"\\n  }\'\\n\\n","query-limit":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v3/store/find\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n    \\"collection\\": \\"people\\",\\n    \\"query\\": \\"color == \'red\'\\",\\n    \\"limit\\": 100\\n  }\'\\n\\n","remove-id":"curl --location --request POST \'https://<CLOUD_ENDPOINT>/api/v3/store/write\' \\\\\\n--header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n--header \'Content-Type: application/json\' \\\\\\n--data-raw \'{\\n      \\"commands\\": [{\\n        \\"method\\": \\"remove\\",\\n        \\"collection\\": \\"orders\\",\\n        \\"query\\": \\"_id == \'<ID>\'\\"\\n      }]\\n  }\'\\n\\n"},"javascript":{"online-playground":"import { init, Ditto } from \\"@dittolive/ditto\\"\\nconst identity: Identity = { type: \'onlinePlayground\', appID: \'00000000-0000-4000-0000-000000000000\', token: \'REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\' }\\nconst ditto = new Ditto(identity, path)\\nditto.startSync()\\n\\n","online-playground-cloudSync":"const identity: Identity = {\\n  type: \'onlinePlayground\',\\n  appID: \'00000000-0000-4000-0000-000000000000\',\\n  token: \'REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\',\\n  // Set to false to disable syncing with the cloud\\n  enableDittoCloudSync: true,\\n}\\nconst ditto = new Ditto(identity, path)\\nditto.startSync()\\n\\n","offline-playground":"const identity: Identity = { type: \'offlinePlayground\', appID: \'00000000-0000-4000-0000-000000000000\' }\\nconst ditto = new Ditto(identity, path)\\nditto.setOfflineOnlyLicenseToken(validLicense)\\nditto.startSync()\\n\\n","datamodel":"const carsCollection = ditto.store.collection(\'cars\')\\n\\n","upsert-id":"const docID = await ditto.store.collection(\'people\').upsert({\\n  _id: \'123abc\',\\n  name: \'Susan\',\\n  age: 31,\\n})\\n\\nconsole.log(docID) // \\"123abc\\"\\n\\n","upsert":"const docID = await ditto.store.collection(\'people\').upsert({\\n  name: \'Susan\',\\n  age: 31,\\n})\\nconsole.log(docID) // \\"507f191e810c19729de860ea\\"\\n\\n","upsert-datatypes":"// Insert JSON-compatible data into Ditto\\nawait ditto.store.collection(\'people\').upsert({\\n  boolean: true,\\n  string: \'Hello World\',\\n  number: 10,\\n  map: { key: \'value\' },\\n  array: [],\\n  null: null,\\n})\\n\\n","counter":"const frankId = await ditto.store.collection(\'people\').upsert({\\n  name: \'Frank\',\\n  ownedCars: 0, // here 0 is a number\\n})\\n\\nawait ditto.store\\n  .collection(\'people\')\\n  .findByID(frankId)\\n  .update((mutableDoc) => {\\n    mutableDoc.at(\'ownedCars\').set(new Counter())\\n    mutableDoc.at(\'ownedCars\').counter.increment(1)\\n  })\\n\\n","upsert-default-data":"const docID = await ditto.store.collection(\'people\').upsert(\\n  {\\n    name: \'Susan\',\\n    age: 31,\\n  },\\n  { writeStrategy: \'insertDefaultIfAbsent\' },\\n)\\n\\n","upsert-composite-primary-key":"const docID = await ditto.store.collection(\'people\').upsert({\\n  _id: { userID: \'456abc\', workID: 789 },\\n  name: \'Susan\',\\n  age: 31,\\n})\\nconsole.log(docID) // \\"{ \\"userID\\": \\"456abc\\", \\"workID\\": 789 }\\"\\n\\n","update":"const docID = await ditto.store.collection(\'people\').upsert({\\n  name: \'Frank\',\\n  age: 31,\\n  ownedCars: 0,\\n})\\n\\nawait ditto.store\\n  .collection(\'people\')\\n  .findByID(docID)\\n  .update((mutableDoc) => {\\n    mutableDoc.at(\'age\').set(32)\\n\\n    mutableDoc.at(\'ownedCars\').set(new Counter())\\n    mutableDoc.at(\'ownedCars\').counter.increment(1)\\n  })\\n\\n","array-to-map":"await collection.findByID(docID).update((mutableDoc) => {\\n  const map = {}\\n  const array = mutableDoc.at(\'friends\').value\\n  array.forEach((name) => {\\n    const id = getUUID()\\n    map[id] = { id, name }\\n  })\\n  mutableDoc.at(\'friendsMap\').set(map)\\n})\\n\\n","query-basic":"const collection = await ditto.store.collection(\'people\').find(\\"favoriteBook.title == \'The Great Gatsby\'\\")\\n\\n","remove-id":"await ditto.store.collection(\'people\').findByID(docID).remove()\\n\\n","query-args":"const query = \'name == $args.name && age <= $args.age\'\\nconst documents = await ditto.store.collection(\'people\').find(query, {\\n  age: 32,\\n  name: \'Max\',\\n})\\n\\n","remove-query":"await ditto.store.collection(\'people\').find(\'age <= 32\').remove()\\n\\n","query-sort":"const sortedRedCars = await ditto.store.collection(\'cars\').find(\\"color == \'red\'\\").sort(\'miles\', \'ascending\')\\n\\n","query-limit":"const sortedAndLimitedRedCars = await ditto.store.collection(\'cars\').find(\\"color == \'red\'\\").sort(\'miles\', \'ascending\').limit(100)\\n\\n","evict":"await ditto.store.collection(\'people\').find(\'age <= 32\').evict()\\n\\n","sync-basic":"try {\\n  ditto.startSync()\\n} catch (err) {\\n  console.error(err)\\n}\\n\\n","sync-observe":"const liveQuery = ditto.store\\n  .collection(\'cars\')\\n  .find(\\"color == \'red\'\\")\\n  .observeLocal((cars, event) => {\\n    // do something\\n  })\\n\\n","subscribe":"const subscription = ditto.store.collection(\'cars\').find(\\"color == \'red\'\\").subscribe()\\n\\n","sync-observe-local":"const liveQuery = ditto.store\\n  .collection(\'cars\')\\n  .find(\\"color == \'red\'\\")\\n  .observeLocal((cars, event) => {\\n    // do something\\n  })\\n\\n","attachment":"const collection = ditto.store.collection(\'foo\')\\n\\nconst myImageBase64 = \'iVBORw0KGgoAAAANSUhEUgAAAQAAAAEAAQMAAABmvDolAAAAA1BMVEW10NBjBBbqAAAAH0lEQVRoge3BAQ0AAADCoPdPbQ43oAAAAAAAAAAAvg0hAAABmmDh1QAAAABJRU5ErkJggg==\'\\nconst myImageBytes = Uint8Array.from(myImageBase64, (character) => character.charCodeAt(0))\\nconst metadata = { name: \'image.png\' }\\n\\n// On Node, you can also pass a file path (string) instead of image data\\n// and the attachment will be created from that file.\\nconst attachment = await collection.newAttachment(myImageBytes, metadata)\\n\\nconst docID = await collection.upsert({ some: \'string\', my_attachment: attachment })\\n\\n// Later, find the document and then fetch the attachment\\n\\nconst doc = await collection.findByID(docID)\\nconst attachmentToken = doc.at(\'my_attachment\').attachmentToken\\n\\nconst attachmentFetcher = collection.fetchAttachment(attachmentToken, async (attachmentFetchEvent) => {\\n  switch (attachmentFetchEvent.type) {\\n    case \'Completed\':\\n      const fetchedAttachment = attachmentFetchEvent.attachment\\n      // Do something with attachment\\n      break\\n\\n    default:\\n      console.log(\'Unable to fetch attachment\')\\n      break\\n  }\\n})\\n\\n// There is also a more convenient way of fetching the attachment\\n// (AttachmentFetcher implements the `PromiseLike` protocol):\\nconst fetchedAttachment = await collection.fetchAttachment(attachmentToken)\\n// Do something with attachment\\n\\n","network-remote-ditto":"import { TransportConfig } from \'@dittolive/ditto\'\\n\\nconst config = new TransportConfig()\\nconfig.connect.websocketURLs.push(\'wss://135.1.5.5:12345\')\\nconfig.connect.websocketURLs.push(\'wss://185.1.5.5:12345\')\\nditto.setTransportConfig(config)\\nditto.startSync()\\n\\n\\n","network-monitor-conditions":"const transportConditionsObserver = ditto.observeTransportConditions((condition, source) => {\\n  if (condition === \'BLEDisabled\') {\\n    console.log(\'BLE disabled\')\\n  } else if (condition === \'NoBLECentralPermission\') {\\n    console.log(\'Permission missing for BLE\')\\n  } else if (condition === \'NoBLEPeripheralPermission\') {\\n    console.log(\'Permissions missing for BLE\')\\n  }\\n})\\n\\n","transport-sync-groups":"import { TransportConfig } from \'@dittolive/ditto\'\\n\\nconst config = new TransportConfig()\\n// 1. Enable All Peer to Peer Connections (not in a browser environment)\\nconfig.setAllPeerToPeerEnabled(true)\\n\\n//2. Set sync group to an integer between 0 and 2^32\\nconfig.global.syncGroup = 1234\\n\\n// 3. Connect explicitly to remote devices\\nditto.setTransportConfig(config)\\nditto.startSync()\\n\\n","network-multiple-transports":"import { TransportConfig } from \'@dittolive/ditto\'\\n\\nconst config = new TransportConfig()\\n// 1. Enable All Peer to Peer Connections (not in a browser environment)\\nconfig.setAllPeerToPeerEnabled(true)\\n\\n// 2. Listen for incoming connections on port 4000\\nconfig.listen.tcp.isEnabled = true\\nconfig.listen.tcp.interfaceIP = \'0.0.0.0\'\\nconfig.listen.tcp.port = 4000\\n\\n// 3. Connect explicitly to remote devices\\nditto.setTransportConfig(config)\\nditto.startSync()\\n\\n","transport-configurations":"const config = new TransportConfig()\\n\\n/* eslint-disable */\\n// Enable all peer to peer transports\\nconfig.setAllPeerToPeerEnabled(true)\\n\\n// or enable/disable each transport separately\\n// BluetoothLE\\nconfig.peerToPeer.bluetoothLE.isEnabled = true\\n// Local Area Network\\nconfig.peerToPeer.lan.isEnabled = true\\n\\n// AWDL\\nconfig.peerToPeer.awdl.isEnabled = true\\n/* eslint-enable */\\n\\nditto.setTransportConfig(config)\\nditto.startSync()\\n\\n","websocket-connect":"import { TransportConfig } from \'@dittolive/ditto\'\\n\\nconst config = new TransportConfig()\\nconfig.connect.websocketURLs.push(\'ws://127.0.0.1\')\\nditto.setTransportConfig(config)\\nditto.startSync()\\n\\n","network-listen":"import { TransportConfig } from \'@dittolive/ditto\'\\n\\nconst config = new TransportConfig()\\nconfig.listen.tcp.isEnabled = true\\nconfig.listen.tcp.interfaceIP = \'0.0.0.0\'\\nconfig.listen.tcp.port = 4000\\nditto.setTransportConfig(config)\\nditto.startSync()\\n\\n"},"csharp":{"sync-basic":"try\\n{\\n    onlineDitto.StartSync();\\n}\\ncatch (DittoException ex)\\n{\\n    // handle exception\\n}\\n\\n","remove-query":"ditto.Store.Collection(\\"people\\").Find(\\"age <= 32\\").Remove();\\n\\n","remove-id":"var wasRemoved = coll.FindById(docId).Remove();\\n\\n","counter":"var counter = new DittoCounter();\\n\\nvar docId = coll.Upsert(new Dictionary<string, object> {\\n    { \\"make\\", \\"Honda\\" }, { \\"mileage\\", counter }\\n});\\n\\n_ = coll.FindById(docId).Update(mutableDoc =>\\n{\\n    mutableDoc[\\"mileage\\"].Counter.Increment(100);\\n});\\n\\n","update":"var content = new Dictionary<string, object>\\n{\\n    { \\"name\\", \\"Bob\\" },\\n    { \\"age\\", 40 },\\n    { \\"ownedCars\\",  new DittoCounter() }\\n};\\n\\nvar docId = Ditto.Store.Collection(\\"people\\").Upsert(content);\\nDitto.Store.Collection(\\"people\\").FindById(docId).Update(mutableDoc =>\\n{\\n    mutableDoc[\\"age\\"].Set(32);\\n    mutableDoc[\\"ownedCars\\"].Counter.Increment(1);\\n});\\n\\n","evict":"Ditto.Store.Collection(\\"people\\").Find(\\"age <= 32\\").Evict();\\n\\n","array-to-map":"Ditto.Store.Collection(\\"people\\").FindById(docId).Update(mutableDoc =>\\n{\\n    var friendsMap = new Dictionary<string, object>();\\n\\n    foreach (string name in mutableDoc[\\"friends\\"].ListValue)\\n    {\\n        var friend = new Dictionary<string, object>();\\n        var id = \\"myId\\";\\n        friend[\\"id\\"] = id;\\n        friend[\\"name\\"] = name;\\n        mutableDoc[id].Set(friend);\\n    }\\n    mutableDoc[\\"friendsMap\\"].Set(friendsMap);\\n});\\n\\n","attachment":"string attachmentImagePath = Path.Combine(Directory.GetCurrentDirectory(), \\"attachment_test.png\\");\\n\\nvar originalBytes = File.ReadAllBytes(attachmentImagePath);\\n\\nvar metadata = new Dictionary<string, string> { { \\"name\\", \\"my_image.png\\" } };\\nvar attachment = coll.NewAttachment(attachmentImagePath, metadata);\\n\\nvar docId = coll.Upsert(new Dictionary<string, object> { { \\"some\\", \\"string\\" }, { \\"my_attachment\\", attachment } });\\n\\nvar doc = coll.FindById(docId).Exec();\\nvar attachmentToken = doc[\\"my_attachment\\"].AttachmentToken;\\nusing var fetcher = coll.FetchAttachment(attachmentToken, ev =>\\n{\\n    switch (ev)\\n    {\\n        case DittoAttachmentFetchEvent.Completed e:\\n            // Do something with attachment\\n            break;\\n        default:\\n            Console.WriteLine(\\"Unable to fetch attachment\\");\\n            break;\\n    }\\n});\\n\\n","upsert-composite-primary-key":"// Insert JSON-compatible data into Ditto\\nvar content = new Dictionary<string, object> {\\n    { \\"_id\\", new Dictionary<string, object> {{ \\"userId\\", \\"456abc\\" }, { \\"workId\\", 789 }} },\\n    { \\"name\\", \\"Susan\\" },\\n    { \\"age\\", 31 }\\n};\\nvar docId = ditto.Store.Collection(\\"people\\").Upsert(content);\\n\\n","upsert-default-data":"// Immediately try and insert some new default data\\nvar docId = coll.Upsert(\\n    new Dictionary<string, object> { { \\"name\\", \\"Susan\\" } },\\n    DittoWriteStrategy.InsertDefaultIfAbsent);\\n\\n","datamodel":"var coll = ditto.Store.Collection(\\"people\\");\\n\\n","upsert":"var docId = ditto.Store.Collection(\\"people\\").Upsert(\\n    new Dictionary<string, object> {\\n    { \\"name\\", \\"Susan\\" },\\n    { \\"age\\", 31 },\\n    }\\n);\\n\\n","upsert-id":"var returnedId = ditto.Store.Collection(\\"people\\").Upsert(\\n    new Dictionary<string, object> {\\n        { \\"_id\\", \\"123abc\\" },\\n        { \\"name\\", \\"Joe\\" },\\n        { \\"age\\", 32 },\\n        { \\"isOnline\\", true }\\n    }\\n);\\n\\n","upsert-datatypes":"// Insert JSON-compatible data into Ditto\\nvar content = new Dictionary<string, object>\\n{\\n    { \\"boolean\\", true },\\n    { \\"string\\", \\"Hello World\\" },\\n    { \\"number\\", 10 },\\n    { \\"map\\", new Dictionary<string, string>{{ \\"key\\", \\"value\\"}} },\\n    { \\"array\\", new[] {1, 2, 3} },\\n    { \\"null\\", null }\\n};\\nDitto.Store.Collection(\\"foo\\").Upsert(content);\\n\\n","online-playground-cloudSync":"try\\n{\\n    var ditto = new Ditto(DittoIdentity.OnlinePlayground(\\n        appId: \\"00000000-0000-4000-0000-000000000000\\",\\n        token: \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\",\\n        // Set to false to disable syncing with the cloud\\n        enableDittoCloudSync: true), path);\\n\\n    ditto.StartSync();\\n}\\ncatch (DittoException ex)\\n{\\n    Console.WriteLine($\\"Ditto Error {ex.Message}\\");\\n}\\n\\n","online-playground":"try\\n{\\n    var ditto = new Ditto(DittoIdentity.OnlinePlayground(\\"00000000-0000-4000-0000-000000000000\\", \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\", true), path);\\n    ditto.StartSync();\\n}\\ncatch (DittoException ex)\\n{\\n    Console.WriteLine($\\"Ditto Error {ex.Message}\\");\\n}\\n\\n","offline-playground":"try\\n{\\n    var ditto = new Ditto(DittoIdentity.OfflinePlayground(\\"00000000-0000-4000-0000-000000000000\\", 0), path);\\n    ditto.StartSync();\\n    ditto.SetOfflineOnlyLicenseToken(validLicense);\\n}\\ncatch (DittoException ex)\\n{\\n    Console.WriteLine($\\"Ditto Error {ex.Message}\\");\\n}\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nstring p256DerB64 = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nvar identity = DittoIdentity.SharedKey(\\"app\\", p256DerB64);\\nvar ditto = new Ditto(identity);\\ntry\\n{\\n    ditto.SetOfflineOnlyLicenseToken(validLicense);\\n}\\ncatch (DittoException ex)\\n{\\n    Console.WriteLine($\\"Ditto Error {ex.Message}\\");\\n}\\n\\n","query-basic":"var results = ditto.Store.Collection(\\"people\\")\\n    .Find(\\"favoriteBook.title == \'The Great Gatsby\'\\")\\n    .Exec();\\n\\n","query-args":"var docs = ditto.Store\\n    .Collection(\\"users\\")\\n    .Find(\\n        \\"name == $args.name && age <= $args.age\\",\\n        new Dictionary<string, object> { { \\"name\\", \\"max\\" }, { \\"age\\", 32 } })\\n    .Exec();\\n\\n","query-sort":"var sortedCars = ditto.Store.Collection(\\"cars\\")\\n    .Find(\\"color == \'red\'\\")\\n    .Sort(\\"miles\\", direction: DittoSortDirection.Ascending)\\n    .Exec();\\n\\n","query-limit":"var sortedAndLimitedRedCars = ditto.Store.Collection(\\"cars\\")\\n    .Find(\\"color == \'red\'\\")\\n    .Sort(\\"miles\\", direction: DittoSortDirection.Ascending)\\n    .Limit(100).Exec();\\n\\n","subscribe":"// --- Register live query to update UI\\nvar subscription = ditto.Store.Collection(\\"cars\\").Find(\\"color == \'red\'\\")\\n    .Subscribe();\\n\\n","sync-observe":"// --- Register live query to update UI\\nvar liveQuery = ditto.Store.Collection(\\"cars\\").Find(\\"color == \'red\'\\").ObserveLocal((docs, dittoLiveQueryEvent) =>\\n{\\n    // Do something...\\n});\\n\\n// --- Register live query to update UI\\nvar localLiveQuery = ditto.Store.Collection(\\"cars\\").Find(\\"color == \'red\'\\").ObserveLocal((docs, dittoLiveQueryEvent) =>\\n{\\n    // Do something...\\n});\\n\\n","sync-observe-local":"// --- Register live query to update UI\\nvar localLiveQuery = ditto.Store.Collection(\\"cars\\").Find(\\"color == \'red\'\\")\\n    .ObserveLocal((docs, dittoLiveQueryEvent) =>\\n{\\n    // Do something...\\n});\\n\\n","transport-configurations":"DittoTransportConfig config = new DittoTransportConfig();\\n\\n//Enable all peer to peer transports\\nconfig.EnableAllPeerToPeer();\\n\\n//Or enable/disable each transport separately\\n//BluetoothLe\\nconfig.PeerToPeer.BluetoothLE.Enabled = true;\\nconfig.PeerToPeer.BluetoothLE.Enabled = true;\\n//Local Area Network\\nconfig.PeerToPeer.Lan.Enabled = true;\\n//Awdl\\nconfig.PeerToPeer.Awdl.Enabled = true;\\n\\nDitto.TransportConfig = config;\\n\\nDitto.StartSync();\\n\\n","websocket-connect":"DittoTransportConfig config = new DittoTransportConfig();\\n\\nconfig.Connect.WebsocketUrls.Add(\\"ws://127.0.0.1\\");\\n\\nDitto.TransportConfig = config;\\n\\nDitto.StartSync();\\n\\n","network-remote-ditto":"DittoTransportConfig transportConfig = new DittoTransportConfig();\\n// Connect explicitly to a remote device on\\ntransportConfig.Connect.TcpServers.Add(\\"135.1.5.5:12345\\");\\n// you can add as many TcpServers as you would like.\\ntransportConfig.Connect.TcpServers.Add(\\"185.1.5.5:4567\\");\\n// set the transport config\\nDitto.TransportConfig = transportConfig;\\n// now you can start ditto\'s sync\\nDitto.StartSync();\\n\\n","network-listen":"DittoTransportConfig transportConfig = new DittoTransportConfig();\\ntransportConfig.Listen.Tcp = new DittoTcpListenConfig();\\n// By default Listen.Tcp.Enabled is false, be sure to set it to true.\\ntransportConfig.Listen.Tcp.Enabled = true;\\n// if you want to listen on localhost, most likely you will use 0.0.0.0\\n// do not use \\"localhost\\" as a string\\ntransportConfig.Listen.Tcp.InterfaceIp = \\"0.0.0.0\\";\\n// specify your port.\\ntransportConfig.Listen.Tcp.Port = 4000;\\nDitto.TransportConfig = transportConfig;\\n\\n// now you can call `ditto.StartSync()`\\nDitto.StartSync();\\n\\n","network-multiple-transports":"DittoTransportConfig transportConfig = new DittoTransportConfig();\\n\\n// 1. Enable Local Area Network Connections\\ntransportConfig.EnableAllPeerToPeer();\\n\\n// 2. Listen for incoming connections on port 4000\\ntransportConfig.Listen.Tcp.Enabled = true;\\ntransportConfig.Listen.Tcp.InterfaceIp = \\"0.0.0.0\\";\\ntransportConfig.Listen.Tcp.Port = 4000;\\n\\n// 3. Connect explicitly to remote devices\\ntransportConfig.Connect.TcpServers.Add(\\"135.1.5.5:12345\\");\\ntransportConfig.Connect.TcpServers.Add(\\"185.1.5.5:12345\\");\\n\\nditto.TransportConfig = transportConfig;\\n\\nditto.StartSync();\\n\\n","network-set-priority":"DittoExperimental.SetPriorityForQueryOverlapGroup(DittoConnectionPriority.High, 2, crewB);\\nDittoExperimental.SetPriorityForQueryOverlapGroup(DittoConnectionPriority.High, 2, crewA);\\n\\n","transport-sync-groups":"DittoTransportConfig transportConfig = new DittoTransportConfig();\\n// 1. Enable All Peer to Peer Connections \\ntransportConfig.EnableAllPeerToPeer();\\n// 2. Set sync group to an integer between 0 and 2^32\\ntransportConfig.Global.SyncGroup = 12345;\\nditto.TransportConfig = transportConfig;\\n\\nditto.StartSync();\\n\\n"},"kotlin":{"attachment":"val testContext = InstrumentationRegistry.getInstrumentation().context\\nval attachmentStream = testContext.assets.open(\\"attachment_test.png\\")\\n\\nval bitmapStream = testContext.assets.open(\\"attachment_test.png\\")\\nval attachmentBitmap = BitmapFactory.decodeStream(bitmapStream)\\nbitmapStream.close()\\n\\nval metadata = mapOf(\\"name\\" to \\"my_image.png\\")\\nval attachment = coll.newAttachment(attachmentStream, metadata)\\n\\nval docId = coll.upsert(mapOf(\\"some\\" to \\"string\\", \\"my_attachment\\" to attachment))\\nval doc = coll.findById(docId).exec()\\nval attachmentToken = doc!![\\"my_attachment\\"].attachmentToken\\n\\nval fetcher = coll.fetchAttachment(attachmentToken!!) {\\n    when (it) {\\n        is Completed -> {\\n            val attBitmap: Bitmap = BitmapFactory.decodeStream(it.attachment.getInputStream())\\n        }\\n        is Progress -> {}\\n    }\\n}\\n\\n","datamodel":"val carsCollection = ditto.store[\\"cars\\"]\\n// or\\nval carsCollection = ditto.store.collection(\\"cars\\")\\n\\n","upsert-id":"val docId = ditto.store[\\"people\\"].upsert(\\n    mapOf(\\n        \\"_id\\" to \\"123abc\\",\\n        \\"name\\" to \\"Susan\\",\\n        \\"age\\" to 31\\n    )\\n)\\n\\n","upsert":"val docId2 = ditto.store[\\"people\\"].upsert(\\n    mapOf(\\n        \\"name\\" to \\"Susan\\",\\n        \\"age\\" to 31\\n    )\\n)\\n\\n","upsert-composite-primary-key":"val docId = ditto.store[\\"people\\"].upsert(\\n    mapOf(\\n        \\"_id\\" to mapOf( \\"userId\\" to \\"456abc\\", \\"workId\\" to 789),\\n        \\"name\\" to \\"Susan\\",\\n        \\"age\\" to 31\\n    )\\n)\\n\\n","upsert-datatypes":"ditto.store[\\"foo\\"].upsert(mapOf(\\n    \\"boolean\\" to true,\\n    \\"string\\" to \\"Hello World\\",\\n    \\"number\\" to 10,\\n    \\"map\\" to mapOf(\\"key\\" to \\"value\\"),\\n    \\"array\\" to listOf(1,2,3),\\n    \\"null\\" to null\\n))\\n\\n","write-transaction":"val results = ditto.store.write { transaction ->\\n    val cars = transaction.scoped(\\"cars\\")\\n    val people = transaction.scoped(\\"people\\")\\n    val docId = \\"abc123\\"\\n    people.upsert(mapOf(\\"_id\\" to docId, \\"name\\" to \\"Susan\\"))\\n    cars.upsert(mapOf(\\"make\\" to \\"Hyundai\\", \\"color\\" to \\"red\\", \\"owner\\" to docId))\\n    cars.upsert(mapOf(\\"make\\" to \\"Jeep\\", \\"color\\" to \\"pink\\", \\"owner\\" to docId))\\n    people.findById(DittoDocumentId(docId)).evict()\\n}\\n\\n","counter":"val docId = ditto.store[\\"people\\"].upsert(mapOf(\\n    \\"name\\" to \\"Frank\\",\\n    \\"ownedCars\\" to DittoCounter()\\n))\\n\\nditto.store.collection(\\"people\\").findById(docId).update { mutableDoc ->\\n    mutableDoc!![\\"ownedCars\\"].counter!!.increment(amount = 1.0)\\n}\\n\\n","counter-upsert":"val frankId = ditto.store[\\"people\\"].upsert(mapOf(\\n    \\"name\\" to \\"Frank\\",\\n    \\"age\\" to 31,\\n    \\"ownedCars\\" to DittoCounter()\\n))\\n\\n","update":"ditto.store.collection(\\"people\\").findById(frankId).update { mutableDoc ->\\n    mutableDoc?.let {\\n        it[\\"age\\"].set(32)\\n        it[\\"ownedCars\\"].counter!!.increment(amount = 1.0)\\n    }\\n}\\n\\n","evict":"ditto.store[\\"people\\"].find(\\"age <= 32\\").evict()\\n\\n","upsert-default-data":"val docId = ditto.store.collection(\\"people\\").upsert(mapOf(\\n    \\"name\\" to \\"Susan\\",\\n    \\"age\\" to 31\\n), DittoWriteStrategy.InsertDefaultIfAbsent)\\n\\n","array-to-map":"collection.findById(docId).update { mutableDoc ->\\n    val map = mutableMapOf<String, Any>()\\n    val names = mutableDoc!![\\"friends\\"].listValue\\n    names.forEach { name ->\\n        val id = UUID.randomUUID().toString()\\n        map[id] = mapOf(\\n            \\"id\\" to id,\\n            \\"name\\" to name\\n        )\\n    }\\n\\n    mutableDoc[\\"friendsMap\\"].set(map)\\n}\\n\\n","device-name":"ditto.deviceName = \\"Susan B.\\"\\nditto.startSync()\\nditto.observePeersV2 { peers ->\\n    // render peer list\\n}\\n\\n","online-playground-cloudSync":"val identity = DittoIdentity.OnlinePlayground(androidDependencies,\\n    appId = \\"00000000-0000-4000-0000-000000000000\\",\\n    token = \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\",\\n    // Set to false to disable syncing with the cloud\\n    enableDittoCloudSync = true\\n    )\\nditto = Ditto(androidDependencies, identity)\\nditto.startSync()\\n\\n","query-basic":"val results = ditto.store.collection(\\"people\\")\\n    .find(\\"favoriteBook.title == \'The Great Gatsby\'\\")\\n    .exec()\\n\\n","query-args":"val foundDocs = ditto.store.collection(\\"people\\")\\n    .find(\\"name == \\\\$args.name && age <= \\\\$args.age\\", mapOf(\\"name\\" to \\"max\\", \\"age\\" to 32))\\n\\n","query-sort":"val sortedRedCars = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .sort(\\"miles\\", DittoSortDirection.Ascending)\\n    .exec()\\n\\n","query-limit":"val sortedAndLimitedRedCars = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .sort(\\"miles\\", DittoSortDirection.Ascending)\\n    .limit(100)\\n    .exec()\\n\\n","sync-basic":"try {\\n    ditto.startSync()\\n}\\ncatch (e: DittoError) {\\n    // handle error\\n}\\n\\n","sync-observe":"// --- DittoRegister live query to update UI\\nval liveQuery = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .observeLocal { docs, event ->\\n        // Do something...\\n    }\\n\\n","sync-observe-local":"// --- Action somewhere in your application\\nfun userDidInsertCar() {\\n    ditto.store.collection(\\"cars\\").upsert(mapOf(\\n        \\"model\\" to \\"Ford\\",\\n        \\"color\\" to \\"black\\"\\n    ))\\n}\\n\\n// --- DittoRegister live query to update UI\\nval observeLocalQuery = ditto.store.collection(\\"cars\\")\\n    .find(\\"isSold == false\\")\\n    .observeLocal { docs, event ->\\n    // Do something...\\n}\\n\\n","subscribe":"// --- DittoRegister live query to update UI\\nval subscription = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .subscribe()\\n\\n","online-playground":"try {\\n    val androidDependencies = DefaultAndroidDittoDependencies(context)\\n    val identity = DittoIdentity.OnlinePlayground(androidDependencies, appID = \\"00000000-0000-4000-0000-000000000000\\", token = \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\")\\n    val ditto = Ditto(androidDependencies, identity)\\n    ditto.startSync()\\n} catch(e: DittoError) {\\n    Log.e(\\"Ditto error\\", e.message!!)\\n}\\n\\n","offline-playground":"try {\\n    val androidDependencies = AndroidDittoDependencies(context)\\n    val identity = DittoIdentity.OfflinePlayground(androidDependencies, appId =\\n    \\"00000000-0000-4000-0000-000000000000\\")\\n    val ditto = Ditto(androidDependencies, identity)\\n    ditto.setOfflineOnlyLicenseToken(validLicense)\\n    ditto.startSync()\\n} catch(e: DittoError) {\\n    Log.e(\\"Ditto error\\", e.message!!)\\n}\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nval p256DerB64 = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\"\\nval androidDependencies = DefaultAndroidDittoDependencies(context)\\nval identity = DittoIdentity.SharedKey(\\"app\\", p256DerB64, null)\\nval ditto = Ditto(androidDependencies, identity)\\nditto.setOfflineOnlyLicenseToken(validLicense)\\n\\n","transport-configurations":"val config = DittoTransportConfig()\\n\\n//Enable all peer to peer transports\\nconfig.enableAllPeerToPeer()\\n\\n//Or enable/disable each transport separately\\n//BluetoothLe\\nconfig.peerToPeer.bluetoothLe.enabled = true\\n//Local Area Network\\nconfig.peerToPeer.lan.enabled = true\\n//Wifi Aware\\nconfig.peerToPeer.wifiAware.enabled = true\\n\\nditto.transportConfig = config\\n\\nditto.startSync()\\n\\n","transport-sync-groups":"val config = DittoTransportConfig()\\n\\n//Enable all peer to peer transports\\nconfig.enableAllPeerToPeer()\\nconfig.global.syncGroup = 1234U\\n\\nditto.transportConfig = config\\n\\nditto.startSync()\\n\\n","websocket-connect":"val config = DittoTransportConfig()\\n\\nconfig.connect.websocketUrls.add(\\"ws://127.0.0.1\\")\\n\\nditto.transportConfig = config\\n\\nditto.startSync()\\n\\n","network-remote-ditto":"val transportConfig = DittoTransportConfig()\\n\\ntransportConfig.connect.tcpServers.add(\\"135.1.5.5:12345\\")\\ntransportConfig.connect.tcpServers.add(\\"185.1.5.5:12345\\")\\n\\nditto.transportConfig = transportConfig\\nditto.startSync()\\n\\n","network-listen":"val transportConfig = DittoTransportConfig()\\ntransportConfig.connect.tcpServers.add(\\"135.1.5.5:12345\\")\\ntransportConfig.connect.tcpServers.add(\\"185.1.5.5:12345\\")\\nditto.transportConfig = transportConfig\\nditto.startSync()\\n\\n","network-multiple-transports":"val transportConfig = DittoTransportConfig()\\n// 1. Enable All Peer to Peer Connections\\ntransportConfig.enableAllPeerToPeer()\\n// 2. Listen for incoming connections on port 4000\\ntransportConfig.listen.tcp.enabled = true\\ntransportConfig.listen.http.enabled = false\\ntransportConfig.listen.tcp.interfaceIp = \\"0.0.0.0\\"\\ntransportConfig.listen.tcp.port = 4000\\n// 3. Connect explicitly to remote devices\\ntransportConfig.connect.tcpServers.add(\\"135.1.5.5:12345\\")\\ntransportConfig.connect.tcpServers.add(\\"185.1.5.5:12345\\")\\n\\nditto.transportConfig = transportConfig\\nditto.startSync()\\n\\n","network-monitor-conditions":"// ... Setting up inside an Activity\\nval androidDependencies = DefaultAndroidDittoDependencies(applicationContext)\\nval ditto = Ditto(androidDependencies, DittoIdentity.OnlinePlayground\\n(androidDependencies, appId = \\"REPLACE_WITH_APP_ID\\", token = \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\"))\\nditto.callback = this\\nditto.startSync()\\n\\n// Now you can observe real time changes to the transport conditions:\\n\\nclass MainActivity : AppCompatActivity(), DittoCallback {\\n\\n    override fun transportConditionDidChange(transportId: Long, condition: TransportCondition) {\\n        var toastText: String? = null\\n        if (condition == TransportCondition.TRANSPORT_CONDITION_BLE_DISABLED) {\\n            toastText = \\"BLE disabled\\"\\n        } else if (condition == TransportCondition.TRANSPORT_CONDITION_NO_BLE_CENTRAL_PERMISSION) {\\n            toastText = \\"Permission missing for BLE\\"\\n        } else if (condition == TransportCondition.TRANSPORT_CONDITION_NO_BLE_PERIPHERAL_PERMISSION) {\\n            toastText = \\"Permission missing for BLE\\"\\n        }\\n        toastText?.let {\\n            Handler(mainLooper).post {\\n                Toast.makeText(this, it, Toast.LENGTH_LONG).show()\\n            }\\n        }\\n    }\\n}\\n\\n","network-query-overlap-group":"// The passenger only observes orders that they created\\npassenger.store.collection(\\"orders\\")\\n    .find(\\"user_id==abc123\\")\\n    .observeLocal { docs, event ->\\n        // render passenger orders in a list UI\\n}\\n\\n// Crew member devices observe all orders that everyone created\\ncrewA.store.collection(\\"orders\\")\\n    .find(\\"status == \'OPEN\'\\")\\n    .observeLocal { docs, event ->\\n        // render all orders in a list UI\\n}\\ncrewB.store.collection(\\"orders\\")\\n    .find(\\"status == \'OPEN\'\\")\\n    .observeLocal { docs, event ->\\n        // render all orders in a list UI\\n}\\n\\nDittoExperimental.setQueryOverlapGroup(2u, crewA)\\nDittoExperimental.setQueryOverlapGroup(2u, crewB)\\n\\ncrewA.startSync()\\ncrewB.startSync()\\npassenger.startSync()\\n\\n","network-set-priority":"DittoExperimental.setPriorityForQueryOverlapGroup(DittoConnectionPriority.High, 2u, crewA)\\nDittoExperimental.setPriorityForQueryOverlapGroup(DittoConnectionPriority.High, 2u, crewB)\\n\\n","remove-id":"coll.findById(docId).remove()\\n\\n","remove-query":"val removedDocIds = coll.find(\\"make == \'Honda\'\\").remove()\\n\\n"},"java":{"attachment":"String attachmentPath = tempFile.getPath();\\nMap<String, String> metadata = new HashMap<>();\\nmetadata.put(\\"name\\", \\"my_image.png\\");\\nDittoAttachment attachment = coll.newAttachment(attachmentPath, metadata);\\ntempFile.delete();\\n\\nMap<String, Object> content = new HashMap<>();\\ncontent.put(\\"some\\", \\"string\\");\\ncontent.put(\\"my_attachment\\", attachment);\\nDittoDocumentId docID = coll.upsert(content);\\n\\nDittoDocument doc = coll.findById(docID).exec();\\nDittoAttachmentToken attachmentToken = doc.get(\\"my_attachment\\").getAttachmentToken();\\n\\nDittoAttachmentFetcher fetcher = coll.fetchAttachment(attachmentToken, event -> {\\n    if (event.getType() == DittoAttachmentFetchEventType.Completed) {\\n        DittoAttachment att = event.asCompleted().getAttachment();\\n        BufferedImage attachmentImage;\\n        try {\\n            attachmentImage = ImageIO.read(att.getInputStream());\\n        } catch (IOException e) {\\n            e.printStackTrace();\\n        }\\n    } else if (event.getType() == DittoAttachmentFetchEventType.Progress) {\\n        // do nothing - wait for `Completed` or `Deleted`\\n    } else {\\n    }\\n});\\n\\n\\n","datamodel":"DittoCollection carsCollection = ditto.store.collection(\\"cars\\");\\n\\n","upsert-id":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"_id\\", \\"123abc\\");\\ncontent.put(\\"name\\", \\"Susan\\");\\ncontent.put(\\"age\\", 31);\\nDittoDocumentId docId = ditto.store.collection(\\"people\\").upsert(content);\\n// docId => 123abc\\n\\n","upsert":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"name\\", \\"Susan\\");\\ncontent.put(\\"age\\", 31);\\nDittoDocumentId docId = ditto.store.collection(\\"people\\").upsert(content);\\n// docId => 507f191e810c19729de860ea\\n\\n","upsert-composite-primary-key":"Map<String, Object> _id = new HashMap<>();\\n_id.put(\\"userId\\", \\"456abc\\");\\n_id.put(\\"workId\\", 789);\\n\\nMap<String, Object> value = new HashMap<>();\\nvalue.put(\\"_id\\", _id);\\nvalue.put(\\"name\\", \\"Susan\\");\\nvalue.put(\\"age\\", 31);\\nDittoDocumentId docID = ditto.store.collection(\\"people\\").upsert(value);\\n// docId=> \\"_id.put(\\"userId\\", \\"456abc\\"); _id.put(\\"workId\\", 789);\\"\\n\\n","remove-id":"ditto.store.collection(\\"people\\").findById(docId).remove();\\n\\n","remove-query":"ditto.store.collection(\\"people\\").find(\\"age <= 32\\").remove();\\n\\n","evict":"ditto.store.collection(\\"people\\").find(\\"age <= 32\\").evict();\\n\\n","upsert-datatypes":"// Insert JSON-compatible data into Ditto\\nMap<String, Object> content = new HashMap<>();\\ncontent.put(\\"boolean\\", true);\\ncontent.put(\\"string\\", \\"Hello World\\");\\ncontent.put(\\"number\\", 10);\\nMap<String, String> innerMap = new HashMap<>();\\ninnerMap.put(\\"key\\", \\"value\\");\\ncontent.put(\\"map\\", innerMap);\\ncontent.put(\\"array\\", Arrays.asList(1, 2, 3));\\ncontent.put(\\"null\\", null);\\nditto.store.collection(\\"foo\\").upsert(content);\\n\\n","counter":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"name\\", \\"Frank\\");\\ncontent.put(\\"ownedCars\\", new DittoCounter());\\nDittoDocumentId docId = ditto.store.collection(\\"people\\").upsert(content);\\n\\nditto.store.collection(\\"people\\").findById(docId).update(mutDoc -> {\\n    assertThat(mutDoc).isNotNull();\\n    DittoMutableCounter counter = mutDoc.get(\\"ownedCars\\").getCounter();\\n    assertThat(counter).isNotNull();\\n    counter.increment(1);\\n});\\n\\n","array-to-map":"collection.findById(docId).update(dittoMutableDocument -> {\\n    Map<String, Object> friendsMap = new HashMap<>();\\n    List<Object> names = dittoMutableDocument.get(\\"friends\\").getListValue();\\n    names.forEach(name -> {\\n        Map<String, Object> friend = new HashMap<>();\\n        String id = UUID.randomUUID().toString();\\n        friend.put(\\"id\\", id);\\n        friend.put(\\"name\\", name);\\n        friendsMap.put(id, friend);\\n    });\\n});\\n\\n","counter-upsert":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"name\\", \\"Frank\\");\\ncontent.put(\\"age\\", 31);\\ncontent.put(\\"ownedCars\\", new DittoCounter());\\nDittoDocumentId docId = ditto.store.collection(\\"people\\").upsert(content);\\n\\nditto.store.collection(\\"people\\").findById(docId).update(doc -> {\\n    try {\\n        doc.get(\\"age\\").set(32);\\n        doc.get(\\"ownedCars\\").getCounter().increment(1);\\n    } catch (DittoError err) {\\n        // Do something with error\\n    }\\n});\\n\\n","device-name":"ditto.deviceName = \\"Susan B.\\";\\ntry {\\n    ditto.startSync();\\n} catch(DittoError e) {\\n    // handle error\\n}\\nditto.observePeersV2(peers -> {\\n    // render peers\\n});\\n\\n","upsert-default-data":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"name\\", \\"Susan\\");\\ncontent.put(\\"age\\", 31);\\nDittoDocumentId docId = ditto.store\\n        .collection(\\"people\\")\\n        .upsert(content, DittoWriteStrategy.InsertDefaultIfAbsent);\\n\\n","query-basic":"List<DittoDocument> results = ditto.store.collection(\\"people\\")\\n        .find(\\"favoriteBook.title == \'The Great Gatsby\'\\")\\n        .exec();\\n\\n","query-args":"Map<String, Object> queryArgs = new HashMap<>();\\nqueryArgs.put(\\"name\\", \\"max\\");\\nqueryArgs.put(\\"age\\", 32);\\n\\nList<DittoDocument> foundDocs = ditto.store.collection(\\"users\\")\\n        .find(\\"name == $args.name && age <= $args.age\\", queryArgs)\\n        .exec();\\n\\n","query-sort":"List<DittoDocument> sortedRedCars = ditto.store.collection(\\"cars\\")\\n        .find(\\"color == \'red\'\\")\\n        .sort(\\"miles\\", DittoSortDirection.Ascending)\\n        .exec();\\n\\n","query-limit":"List<DittoDocument> sortedAndLimitedRedCars = ditto.store.collection(\\"cars\\")\\n        .find(\\"color == \'red\'\\")\\n        .sort(\\"miles\\", DittoSortDirection.Ascending)\\n        .limit(100)\\n        .exec();\\n\\n","sync-basic":"try {\\n    ditto.startSync();\\n} catch(DittoError e) {\\n    // handle error\\n}\\n\\n","sync-observe":"// --- Register live query to update UI\\nDittoLiveQuery liveQuery = ditto.store.collection(\\"cars\\")\\n        .find(\\"color == \'red\'\\")\\n        .observeLocal((docs, event) -> {\\n            // Do something...\\n        });\\n\\n","subscribe":"// --- Register live query to update UI\\nDittoSubscription subscription = ditto.store.collection(\\"cars\\")\\n        .find(\\"!isSold\\")\\n        .subscribe();\\n\\n","sync-observe-local":"// --- Action somewhere in your application\\nMap<String, Object> content = new HashMap<>();\\ncontent.put(\\"model\\", \\"Ford\\");\\ncontent.put(\\"color\\", \\"black\\");\\nditto.store.collection(\\"cars\\").upsert(content);\\n\\n// --- Register live query to update UI\\nDittoLiveQuery liveQueryLocal = ditto.store.collection(\\"cars\\")\\n        .find(\\"owner == \'Susan\'\\")\\n        .observeLocal((docs, event) -> {\\n            // Do something...\\n        });\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nString p256DerB64 = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nDefaultAndroidDittoDependencies androidDependencies = new DefaultAndroidDittoDependencies(this.context);\\nDittoIdentity identity = new DittoIdentity.SharedKey(androidDependencies, \\"app\\", p256DerB64);\\nDitto ditto = new Ditto(androidDependencies, identity);\\ntry {\\n    ditto.setOfflineOnlyLicenseToken(validLicense);\\n} catch(DittoError e) {\\n    //handle error\\n}\\n\\n","online-playground":"DittoDependencies androidDependencies = new DefaultAndroidDittoDependencies(this.context);\\nDittoIdentity identity = new DittoIdentity.OnlinePlayground(androidDependencies, \\"00000000-0000-4000-0000-000000000000\\", \\"YOUR_PLAYGROUND_TOKEN_HERE\\");\\nDitto ditto = new Ditto(androidDependencies, identity);\\n\\ntry {\\n    ditto.startSync();\\n} catch(DittoError e) {\\n    //handle error\\n}\\n\\n","offline-playground":"DittoIdentity identity = new DittoIdentity.OfflinePlayground(androidDependencies, \\"00000000-0000-4000-0000-000000000000\\");\\nDitto ditto = new Ditto(androidDependencies, identity);\\ntry {\\n    ditto.setOfflineOnlyLicenseToken(validLicense);\\n} catch(DittoError e) {\\n    //handle error\\n}\\ntry {\\n    ditto.startSync();\\n} catch(DittoError e) {\\n    //handle error\\n}\\n\\n","online-playground-cloudSync":"DittoIdentity identity = new DittoIdentity.OnlinePlayground(androidDependencies,\\n        \\"00000000-0000-4000-0000-000000000000\\",\\n        \\"YOUR_PLAYGROUND_TOKEN_HERE\\",\\n        // Set to false to disable syncing with the cloud\\n        true);\\n\\nDitto ditto = new Ditto(androidDependencies, identity);\\n\\ntry {\\n    ditto.startSync();\\n} catch(DittoError e) {\\n    //handle error\\n}\\n\\n","transport-configurations":"DittoTransportConfig config = new DittoTransportConfig();\\n\\n//Enable all peer to peer transports\\nconfig.enableAllPeerToPeer();\\n\\n//Or enable/disable each transport separately\\n//BluetoothLe\\nconfig.getPeerToPeer().getBluetoothLe().setEnabled(true);\\n//Local Area Network\\nconfig.getPeerToPeer().getLan().setEnabled(true);\\n//Awdl\\nconfig.getPeerToPeer().getWifiAware().setEnabled(true);\\n\\nditto.setTransportConfig(config);\\n\\ntry {\\n    ditto.startSync();\\n} catch(DittoError error) {\\n    // handle error\\n}\\n\\n","websocket-connect":"DittoTransportConfig config = new DittoTransportConfig();\\n\\nDittoConnect connect = new DittoConnect();\\nconnect.setWebsocketUrls(Collections.singleton(\\"ws://127.0.0.1\\"));\\nconfig.setConnect(connect);\\n\\ntry {\\n    ditto.startSync();\\n} catch(DittoError error) {\\n    // handle error\\n}\\n\\n","network-remote-ditto":"DittoTransportConfig config = new DittoTransportConfig();\\nDittoConnect connect = new DittoConnect();\\nconnect.setTcpServers(Sets.newHashSet(\\"135.1.5.5:12345\\", \\"185.1.5.5:12345\\"));\\nconfig.setConnect(connect);\\n\\ntry {\\n    ditto.startSync();\\n} catch(DittoError error) {\\n    // handle error\\n}\\n\\n","network-listen":"DittoTransportConfig config = new DittoTransportConfig();\\nconfig.enableAllPeerToPeer();\\n\\nDittoListen listen = new DittoListen();\\nDittoTcpListenConfig tcpListenConfig = new DittoTcpListenConfig();\\ntcpListenConfig.setEnabled(true);\\ntcpListenConfig.setInterfaceIp(\\"0.0.0.0\\");\\ntcpListenConfig.setPort(4000);\\nlisten.setTcp(tcpListenConfig);\\nconfig.setListen(listen);\\n\\ntry {\\n    ditto.startSync();\\n} catch(DittoError error) {\\n    // handle error\\n}\\n\\n","network-multiple-transports":"DittoTransportConfig config = new DittoTransportConfig();\\n\\n// 1. Enable Peer to Peer Connections\\nconfig.enableAllPeerToPeer();\\n\\n// 2. Listen for incoming connections on port 4000\\nDittoListen listen = new DittoListen();\\nDittoTcpListenConfig tcpListenConfig = new DittoTcpListenConfig();\\ntcpListenConfig.setEnabled(true);\\ntcpListenConfig.setInterfaceIp(\\"0.0.0.0\\");\\ntcpListenConfig.setPort(4000);\\nlisten.setTcp(tcpListenConfig);\\nconfig.setListen(listen);\\n// 3. Connect explicitly to remote devices\\nDittoConnect connect = new DittoConnect();\\nconnect.setTcpServers(Sets.newHashSet(\\"135.1.5.5:12345\\", \\"185.1.5.5:12345\\"));\\nconfig.setConnect(connect);\\n\\ntry {\\n    ditto.startSync();\\n} catch(DittoError error) {\\n    // handle error\\n}\\n\\n","network-monitor-conditions":"// Setting up inside an Activity\\nDefaultAndroidDittoDependencies androidDependencies = new DefaultAndroidDittoDependencies(getApplicationContext());\\nDitto ditto = new Ditto(androidDependencies, new DittoIdentity.OnlinePlayground(androidDependenciesOne, \\"REPLACE_WITH_APP_ID\\"));\\nditto.callback = this;\\nditto.startSync();\\n\\n// Now you can observe real time changes to the transport conditions:\\npublic class MainActivity extends AppCompatActivity implements DittoCallback {\\n    @Override\\n    public void transportConditionDidChange(@NotNull DittoTransportCondition condition, @NotNull DittoConditionSource transportId) {\\n        String toastText = null;\\n        if (condition == DittoTransportCondition.BleDisabled) {\\n            toastText = \\"BLE disabled\\";\\n        } else if (condition == DittoTransportCondition.NoBleCentralPermission) {\\n            toastText = \\"Permission missing for BLE\\";\\n        } else if (condition == DittoTransportCondition.NoBlePeripheralPermission) {\\n            toastText = \\"Permission missing for BLE\\";\\n        }\\n\\n        if (toastText != null) {\\n            String finalToastText = toastText;\\n            runOnUiThread(new Runnable() {\\n                @Override\\n                public void run() {\\n                    Toast.makeText(MainActivity.this, finalToastText, Toast.LENGTH_LONG).show();\\n                }\\n            });\\n        }\\n    }\\n}\\n\\n"}}');var s=t(99013),c=t(49366),l=t(30547),d=t(50494);const p=e=>d.Z.find((n=>n.id===e));function u(e){let n,{name:t,language:r,label:i}=e,c=a[r];if(c){let e=c[t];e&&(n=e)}return n?o.createElement(s.Z,{className:r},n.trim().replace("00000000-0000-4000-0000-000000000000","REPLACE_ME_WITH_YOUR_APP_ID")):(console.error(`no snippet for ${t} in language=${r}`),o.createElement("div",null,"Not supported by ",i,"."))}function m(e){let{children:n,name:t}=e;const{tabGroupChoices:a,setTabGroupChoices:s}=(0,r.Z)(),d=p(a.platform);let m=d?d.id:"ios";const g=i(m),y=g[0];return o.createElement(c.Z,{platform:m,groupId:"programming-language",defaultValue:y?y.value:"swift",values:g},g.map((e=>o.createElement(l.Z,{key:`${e.value}-${t}`,value:e.value},o.createElement(u,{name:t,language:e.value,label:e.label})))))}},99013:(e,n,t)=>{"use strict";t.d(n,{Z:()=>A});var o=t(87462),r=t(67294),i=t(86010),a=t(23746),s=t(10195),c=t(87594),l=t.n(c),d=t(95999),p=t(68793),u=t(62435),m=t(71418);const g={codeBlockContainer:"codeBlockContainer_EiTO",codeBlockContent:"codeBlockContent_X2I6",codeBlockTitle:"codeBlockTitle_PQMO",codeBlock:"codeBlock_UxnK",copyButton:"copyButton_V-PD",codeBlockLines:"codeBlockLines_W6UD"};var y=t(32822);const f=/{([\d,-]+)}/,h=["js","jsBlock","jsx","python","html"],D={js:{start:"\\/\\/",end:""},jsBlock:{start:"\\/\\*",end:"\\*\\/"},jsx:{start:"\\{\\s*\\/\\*",end:"\\*\\/\\s*\\}"},python:{start:"#",end:""},html:{start:"\x3c!--",end:"--\x3e"}},b=["highlight-next-line","highlight-start","highlight-end"],v=function(e){void 0===e&&(e=h);const n=e.map((e=>{const{start:n,end:t}=D[e];return`(?:${n}\\s*(${b.join("|")})\\s*${t})`})).join("|");return new RegExp(`^\\s*(?:${n})\\s*$`)},I=e=>{switch(e){case"js":case"javascript":case"ts":case"typescript":return v(["js","jsBlock"]);case"jsx":case"tsx":return v(["js","jsBlock","jsx"]);case"html":return v(["js","jsBlock","html"]);case"python":case"py":return v(["python"]);default:return v()}};function A(e){let{children:n,className:t,metastring:c,title:h}=e;const{prism:D}=(0,y.LU)(),[b,v]=(0,r.useState)(!1),[A,C]=(0,r.useState)(!1);(0,r.useEffect)((()=>{C(!0)}),[]);const w=(0,y.bc)(c)||h,T=(0,r.useRef)(null);let S=[];const _=Array.isArray(n)?n.join(""):n;if(c&&f.test(c)){const e=c.match(f)[1];S=l()(e).filter((e=>e>0))}let k=t?.replace(/language-/,"");!k&&D.defaultLanguage&&(k=D.defaultLanguage);let E=_.replace(/\n$/,"");if(0===S.length&&void 0!==k){let e="";const n=I(k),t=_.replace(/\n$/,"").split("\n");let o;for(let r=0;r<t.length;){const i=r+1,a=t[r].match(n);if(null!==a){switch(a.slice(1).reduce(((e,n)=>e||n),void 0)){case"highlight-next-line":e+=`${i},`;break;case"highlight-start":o=i;break;case"highlight-end":e+=`${o}-${i-1},`}t.splice(r,1)}else r+=1}S=l()(e),E=t.join("\n")}const L=()=>{(0,s.Z)(E),v(!0),setTimeout((()=>v(!1)),2e3)};return r.createElement(a.ZP,(0,o.Z)({},a.lG,{key:String(A),theme:m.Z,code:E,language:k}),(e=>{let{className:n,style:t,tokens:a,getLineProps:s,getTokenProps:c}=e;return r.createElement("div",{className:g.codeBlockContainer},w&&r.createElement("div",{style:t,className:g.codeBlockTitle},w),r.createElement("div",{className:(0,i.Z)(g.codeBlockContent,k)},r.createElement("pre",{tabIndex:0,className:(0,i.Z)(n,g.codeBlock,"thin-scrollbar")},r.createElement("code",{className:g.codeBlockLines},a.map(((e,n)=>{1===e.length&&""===e[0].content&&(e[0].content="\n");const t=s({line:e,key:n}),a=S.includes(n+1);S.includes(n+1)&&(t.className+="bg-gray-800 docusaurus-highlight-code-line");let l=(0,i.Z)(t.className,a&&"bg-gray-700");return r.createElement("span",(0,o.Z)({key:n},t,{className:l}),e.map(((e,n)=>{let t={...c({token:e,key:n})},a=t.className;return a.includes("inserted-sign")&&(a=(0,i.Z)(a,"bg-green-900")),a.includes("deleted-sign")&&(a=(0,i.Z)(a,"bg-red-900")),r.createElement("span",(0,o.Z)({key:n},t,{className:a}))})))})))),r.createElement("button",{ref:T,type:"button","aria-label":(0,d.I)({id:"theme.CodeBlock.copyButtonAriaLabel",message:"Copy code to clipboard",description:"The ARIA label for copy code blocks button"}),className:(0,i.Z)(g.copyButton,"clean-btn",b?"bg-green-500":""),onClick:L},b?r.createElement("div",null,r.createElement(p.Z,{className:"w-4 h-4 inline mr-1"}),r.createElement("span",{className:"text-xs"},"Copied")):r.createElement("div",null,r.createElement(u.Z,{className:"w-4 h-4 inline mr-1"}),r.createElement("span",{className:"text-xs"},"Copy")))))}))}},30547:(e,n,t)=>{"use strict";t.d(n,{Z:()=>r});var o=t(67294);const r=function(e){let{children:n,hidden:t,className:r}=e;return o.createElement("div",{role:"tabpanel",hidden:t,className:r},n)}},49366:(e,n,t)=>{"use strict";t.d(n,{Z:()=>a});var o=t(67294),r=t(80944),i=t(86010);const a=function(e){const{lazy:n,platform:t,block:a,defaultValue:s,values:c,groupId:l,className:d}=e,p=o.Children.toArray(e.children),u=c??p.map((e=>({value:e.props.value,label:e.props.label}))),m=s??p.find((e=>e.props.default))?.props.value,{tabGroupChoices:g,setTabGroupChoices:y}=(0,r.Z)(),[f,h]=(0,o.useState)(m);(0,o.useEffect)((()=>{if(null!=l){const e=g[l];null!=e&&e!==f&&(u.some((n=>n.value===e))?h(e):h(m))}}),[t,g[l]]);const D=e=>{h(e),null!=l&&y(l,e)},b=u.length>1;return o.createElement("div",{className:"tabs-container"},b&&o.createElement(o.Fragment,null,o.createElement("div",{className:"sm:hidden"},o.createElement("label",{htmlFor:"tabs",className:"sr-only"},"Select a tab"),o.createElement("select",{id:"tabs",name:"tabs",value:f,onChange:e=>D(e.currentTarget.value),className:"block w-full focus:ring-blue-500 focus:border-blue-500 border-gray-300 rounded-md"},u.map((e=>{let{value:n,label:t}=e;return o.createElement("option",{value:n,key:n},t??n)})))),o.createElement("div",{className:"hidden sm:block"},o.createElement("nav",{className:"flex space-x-4","aria-label":"Tabs"},u.map((e=>{let{value:n,label:t}=e;return o.createElement("button",{key:n,onClick:()=>D(n),className:(0,i.Z)(f===n?"bg-blue-100 text-blue-700":"text-gray-500 hover:text-gray-700","px-3 py-2 font-medium text-sm rounded-md"),"aria-current":f===n?"page":void 0},t??n)}))))),n?(0,o.cloneElement)(p.filter((e=>e.props.value===f))[0],{className:"margin-vert--md"}):o.createElement("div",{className:"margin-vert--md"},p.map(((e,n)=>(0,o.cloneElement)(e,{key:n,hidden:e.props.value!==f})))))}},19167:(e,n,t)=>{"use strict";t.r(n),t.d(n,{contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>c,toc:()=>l});var o=t(87462),r=(t(67294),t(3905)),i=(t(8209),t(49366),t(30547),t(36438));const a={title:"Attachment",sidebar_position:4},s=void 0,c={unversionedId:"datamodel/attachment",id:"datamodel/attachment",isDocsHomePage:!1,title:"Attachment",description:"If you have a large amount of binary data, or perhaps just a large file, that",source:"@site/docs/common/datamodel/attachment.mdx",sourceDirName:"datamodel",slug:"/datamodel/attachment",permalink:"/common/datamodel/attachment",editUrl:"https://github.com/getditto/docs/edit/main/docs/common/datamodel/attachment.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Attachment",sidebar_position:4},sidebar:"defaultSidebar",previous:{title:"Map",permalink:"/common/datamodel/map"},next:{title:"Array",permalink:"/common/datamodel/array"}},l=[],d={toc:l},p="wrapper";function u(e){let{components:n,...t}=e;return(0,r.kt)(p,(0,o.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If you have a large amount of binary data, or perhaps just a large file, that\nyou want to sync between devices then instead of inserting this into a document\nas bytes you should make use of the attachments feature."),(0,r.kt)("p",null,"Attachments do not get synced between devices by default, even if they are part\nof a document that is being synced between devices. This is because they could\nbe very large files that a given device doesn't need. Instead an attachment must\nbe explicitly fetched using an attachment token that will be present in the\ndocument that the attachment is linked to."),(0,r.kt)(i.Z,{name:"attachment",mdxType:"SnippetGroup"}))}u.isMDXComponent=!0},46700:(e,n,t)=>{var o={"./af":42786,"./af.js":42786,"./ar":30867,"./ar-dz":14130,"./ar-dz.js":14130,"./ar-kw":96135,"./ar-kw.js":96135,"./ar-ly":56440,"./ar-ly.js":56440,"./ar-ma":47702,"./ar-ma.js":47702,"./ar-sa":16040,"./ar-sa.js":16040,"./ar-tn":37100,"./ar-tn.js":37100,"./ar.js":30867,"./az":31083,"./az.js":31083,"./be":9808,"./be.js":9808,"./bg":68338,"./bg.js":68338,"./bm":67438,"./bm.js":67438,"./bn":8905,"./bn-bd":76225,"./bn-bd.js":76225,"./bn.js":8905,"./bo":11560,"./bo.js":11560,"./br":1278,"./br.js":1278,"./bs":80622,"./bs.js":80622,"./ca":2468,"./ca.js":2468,"./cs":5822,"./cs.js":5822,"./cv":50877,"./cv.js":50877,"./cy":47373,"./cy.js":47373,"./da":24780,"./da.js":24780,"./de":59740,"./de-at":60217,"./de-at.js":60217,"./de-ch":60894,"./de-ch.js":60894,"./de.js":59740,"./dv":5300,"./dv.js":5300,"./el":50837,"./el.js":50837,"./en-au":78348,"./en-au.js":78348,"./en-ca":77925,"./en-ca.js":77925,"./en-gb":22243,"./en-gb.js":22243,"./en-ie":46436,"./en-ie.js":46436,"./en-il":47207,"./en-il.js":47207,"./en-in":44175,"./en-in.js":44175,"./en-nz":76319,"./en-nz.js":76319,"./en-sg":31662,"./en-sg.js":31662,"./eo":92915,"./eo.js":92915,"./es":55655,"./es-do":55251,"./es-do.js":55251,"./es-mx":96112,"./es-mx.js":96112,"./es-us":71146,"./es-us.js":71146,"./es.js":55655,"./et":5603,"./et.js":5603,"./eu":77763,"./eu.js":77763,"./fa":76959,"./fa.js":76959,"./fi":11897,"./fi.js":11897,"./fil":42549,"./fil.js":42549,"./fo":94694,"./fo.js":94694,"./fr":94470,"./fr-ca":63049,"./fr-ca.js":63049,"./fr-ch":52330,"./fr-ch.js":52330,"./fr.js":94470,"./fy":5044,"./fy.js":5044,"./ga":29295,"./ga.js":29295,"./gd":2101,"./gd.js":2101,"./gl":38794,"./gl.js":38794,"./gom-deva":27884,"./gom-deva.js":27884,"./gom-latn":23168,"./gom-latn.js":23168,"./gu":95349,"./gu.js":95349,"./he":24206,"./he.js":24206,"./hi":30094,"./hi.js":30094,"./hr":30316,"./hr.js":30316,"./hu":22138,"./hu.js":22138,"./hy-am":11423,"./hy-am.js":11423,"./id":29218,"./id.js":29218,"./is":90135,"./is.js":90135,"./it":90626,"./it-ch":10150,"./it-ch.js":10150,"./it.js":90626,"./ja":39183,"./ja.js":39183,"./jv":24286,"./jv.js":24286,"./ka":12105,"./ka.js":12105,"./kk":47772,"./kk.js":47772,"./km":18758,"./km.js":18758,"./kn":79282,"./kn.js":79282,"./ko":33730,"./ko.js":33730,"./ku":1408,"./ku.js":1408,"./ky":33291,"./ky.js":33291,"./lb":36841,"./lb.js":36841,"./lo":55466,"./lo.js":55466,"./lt":57010,"./lt.js":57010,"./lv":37595,"./lv.js":37595,"./me":39861,"./me.js":39861,"./mi":35493,"./mi.js":35493,"./mk":95966,"./mk.js":95966,"./ml":87341,"./ml.js":87341,"./mn":5115,"./mn.js":5115,"./mr":10370,"./mr.js":10370,"./ms":9847,"./ms-my":41237,"./ms-my.js":41237,"./ms.js":9847,"./mt":72126,"./mt.js":72126,"./my":56165,"./my.js":56165,"./nb":64924,"./nb.js":64924,"./ne":16744,"./ne.js":16744,"./nl":93901,"./nl-be":59814,"./nl-be.js":59814,"./nl.js":93901,"./nn":83877,"./nn.js":83877,"./oc-lnc":92135,"./oc-lnc.js":92135,"./pa-in":15858,"./pa-in.js":15858,"./pl":64495,"./pl.js":64495,"./pt":89520,"./pt-br":57971,"./pt-br.js":57971,"./pt.js":89520,"./ro":96459,"./ro.js":96459,"./ru":21793,"./ru.js":21793,"./sd":40950,"./sd.js":40950,"./se":10490,"./se.js":10490,"./si":90124,"./si.js":90124,"./sk":64249,"./sk.js":64249,"./sl":14985,"./sl.js":14985,"./sq":51104,"./sq.js":51104,"./sr":49131,"./sr-cyrl":79915,"./sr-cyrl.js":79915,"./sr.js":49131,"./ss":85893,"./ss.js":85893,"./sv":98760,"./sv.js":98760,"./sw":91172,"./sw.js":91172,"./ta":27333,"./ta.js":27333,"./te":23110,"./te.js":23110,"./tet":52095,"./tet.js":52095,"./tg":27321,"./tg.js":27321,"./th":9041,"./th.js":9041,"./tk":19005,"./tk.js":19005,"./tl-ph":75768,"./tl-ph.js":75768,"./tlh":89444,"./tlh.js":89444,"./tr":72397,"./tr.js":72397,"./tzl":28254,"./tzl.js":28254,"./tzm":51106,"./tzm-latn":30699,"./tzm-latn.js":30699,"./tzm.js":51106,"./ug-cn":9288,"./ug-cn.js":9288,"./uk":67691,"./uk.js":67691,"./ur":13795,"./ur.js":13795,"./uz":6791,"./uz-latn":60588,"./uz-latn.js":60588,"./uz.js":6791,"./vi":65666,"./vi.js":65666,"./x-pseudo":14378,"./x-pseudo.js":14378,"./yo":75805,"./yo.js":75805,"./zh-cn":83839,"./zh-cn.js":83839,"./zh-hk":55726,"./zh-hk.js":55726,"./zh-mo":99807,"./zh-mo.js":99807,"./zh-tw":74152,"./zh-tw.js":74152};function r(e){var n=i(e);return t(n)}function i(e){if(!t.o(o,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return o[e]}r.keys=function(){return Object.keys(o)},r.resolve=i,e.exports=r,r.id=46700},87594:(e,n)=>{function t(e){let n,t=[];for(let o of e.split(",").map((e=>e.trim())))if(/^-?\d+$/.test(o))t.push(parseInt(o,10));else if(n=o.match(/^(-?\d+)(-|\.\.\.?|\u2025|\u2026|\u22EF)(-?\d+)$/)){let[e,o,r,i]=n;if(o&&i){o=parseInt(o),i=parseInt(i);const e=o<i?1:-1;"-"!==r&&".."!==r&&"\u2025"!==r||(i+=e);for(let n=o;n!==i;n+=e)t.push(n)}}return t}n.default=t,e.exports=t},23746:(e,n,t)=>{"use strict";t.d(n,{ZP:()=>g,lG:()=>a});var o=t(87410);const r={plain:{backgroundColor:"#2a2734",color:"#9a86fd"},styles:[{types:["comment","prolog","doctype","cdata","punctuation"],style:{color:"#6c6783"}},{types:["namespace"],style:{opacity:.7}},{types:["tag","operator","number"],style:{color:"#e09142"}},{types:["property","function"],style:{color:"#9a86fd"}},{types:["tag-id","selector","atrule-id"],style:{color:"#eeebff"}},{types:["attr-name"],style:{color:"#c4b9fe"}},{types:["boolean","string","entity","url","attr-value","keyword","control","directive","unit","statement","regex","atrule","placeholder","variable"],style:{color:"#ffcc99"}},{types:["deleted"],style:{textDecorationLine:"line-through"}},{types:["inserted"],style:{textDecorationLine:"underline"}},{types:["italic"],style:{fontStyle:"italic"}},{types:["important","bold"],style:{fontWeight:"bold"}},{types:["important"],style:{color:"#c4b9fe"}}]};var i=t(67294),a={Prism:o.default,theme:r};function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function c(){return c=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},c.apply(this,arguments)}var l=/\r\n|\r|\n/,d=function(e){0===e.length?e.push({types:["plain"],content:"\n",empty:!0}):1===e.length&&""===e[0].content&&(e[0].content="\n",e[0].empty=!0)},p=function(e,n){var t=e.length;return t>0&&e[t-1]===n?e:e.concat(n)},u=function(e,n){var t=e.plain,o=Object.create(null),r=e.styles.reduce((function(e,t){var o=t.languages,r=t.style;return o&&!o.includes(n)||t.types.forEach((function(n){var t=c({},e[n],r);e[n]=t})),e}),o);return r.root=t,r.plain=c({},t,{backgroundColor:null}),r};function m(e,n){var t={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&-1===n.indexOf(o)&&(t[o]=e[o]);return t}const g=function(e){function n(){for(var n=this,t=[],o=arguments.length;o--;)t[o]=arguments[o];e.apply(this,t),s(this,"getThemeDict",(function(e){if(void 0!==n.themeDict&&e.theme===n.prevTheme&&e.language===n.prevLanguage)return n.themeDict;n.prevTheme=e.theme,n.prevLanguage=e.language;var t=e.theme?u(e.theme,e.language):void 0;return n.themeDict=t})),s(this,"getLineProps",(function(e){var t=e.key,o=e.className,r=e.style,i=c({},m(e,["key","className","style","line"]),{className:"token-line",style:void 0,key:void 0}),a=n.getThemeDict(n.props);return void 0!==a&&(i.style=a.plain),void 0!==r&&(i.style=void 0!==i.style?c({},i.style,r):r),void 0!==t&&(i.key=t),o&&(i.className+=" "+o),i})),s(this,"getStyleForToken",(function(e){var t=e.types,o=e.empty,r=t.length,i=n.getThemeDict(n.props);if(void 0!==i){if(1===r&&"plain"===t[0])return o?{display:"inline-block"}:void 0;if(1===r&&!o)return i[t[0]];var a=o?{display:"inline-block"}:{},s=t.map((function(e){return i[e]}));return Object.assign.apply(Object,[a].concat(s))}})),s(this,"getTokenProps",(function(e){var t=e.key,o=e.className,r=e.style,i=e.token,a=c({},m(e,["key","className","style","token"]),{className:"token "+i.types.join(" "),children:i.content,style:n.getStyleForToken(i),key:void 0});return void 0!==r&&(a.style=void 0!==a.style?c({},a.style,r):r),void 0!==t&&(a.key=t),o&&(a.className+=" "+o),a})),s(this,"tokenize",(function(e,n,t,o){var r={code:n,grammar:t,language:o,tokens:[]};e.hooks.run("before-tokenize",r);var i=r.tokens=e.tokenize(r.code,r.grammar,r.language);return e.hooks.run("after-tokenize",r),i}))}return e&&(n.__proto__=e),n.prototype=Object.create(e&&e.prototype),n.prototype.constructor=n,n.prototype.render=function(){var e=this.props,n=e.Prism,t=e.language,o=e.code,r=e.children,i=this.getThemeDict(this.props),a=n.languages[t];return r({tokens:function(e){for(var n=[[]],t=[e],o=[0],r=[e.length],i=0,a=0,s=[],c=[s];a>-1;){for(;(i=o[a]++)<r[a];){var u=void 0,m=n[a],g=t[a][i];if("string"==typeof g?(m=a>0?m:["plain"],u=g):(m=p(m,g.type),g.alias&&(m=p(m,g.alias)),u=g.content),"string"==typeof u){var y=u.split(l),f=y.length;s.push({types:m,content:y[0]});for(var h=1;h<f;h++)d(s),c.push(s=[]),s.push({types:m,content:y[h]})}else a++,n.push(m),t.push(u),o.push(0),r.push(u.length)}a--,n.pop(),t.pop(),o.pop(),r.pop()}return d(s),c}(void 0!==a?this.tokenize(n,o,a,t):[o]),className:"prism-code language-"+t,style:void 0!==i?i.root:{},getLineProps:this.getLineProps,getTokenProps:this.getTokenProps})},n}(i.Component)},71418:(e,n,t)=>{"use strict";t.d(n,{Z:()=>o});const o={plain:{color:"#9CDCFE",backgroundColor:"#1E1E1E"},styles:[{types:["prolog"],style:{color:"rgb(0, 0, 128)"}},{types:["comment"],style:{color:"rgb(106, 153, 85)"}},{types:["builtin","changed","keyword","interpolation-punctuation"],style:{color:"rgb(86, 156, 214)"}},{types:["number","inserted"],style:{color:"rgb(181, 206, 168)"}},{types:["constant"],style:{color:"rgb(100, 102, 149)"}},{types:["attr-name","variable"],style:{color:"rgb(156, 220, 254)"}},{types:["deleted","string","attr-value","template-punctuation"],style:{color:"rgb(206, 145, 120)"}},{types:["selector"],style:{color:"rgb(215, 186, 125)"}},{types:["tag"],style:{color:"rgb(78, 201, 176)"}},{types:["tag"],languages:["markup"],style:{color:"rgb(86, 156, 214)"}},{types:["punctuation","operator"],style:{color:"rgb(212, 212, 212)"}},{types:["punctuation"],languages:["markup"],style:{color:"#808080"}},{types:["function"],style:{color:"rgb(220, 220, 170)"}},{types:["class-name"],style:{color:"rgb(78, 201, 176)"}},{types:["char"],style:{color:"rgb(209, 105, 105)"}}]}},68793:(e,n,t)=>{"use strict";t.d(n,{Z:()=>r});var o=t(67294);const r=o.forwardRef((function(e,n){return o.createElement("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:2,stroke:"currentColor","aria-hidden":"true",ref:n},e),o.createElement("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"}))}))},62435:(e,n,t)=>{"use strict";t.d(n,{Z:()=>r});var o=t(67294);const r=o.forwardRef((function(e,n){return o.createElement("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:2,stroke:"currentColor","aria-hidden":"true",ref:n},e),o.createElement("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"}))}))},10195:(e,n,t)=>{"use strict";function o(e,n){let{target:t=document.body}=void 0===n?{}:n;const o=document.createElement("textarea"),r=document.activeElement;o.value=e,o.setAttribute("readonly",""),o.style.contain="strict",o.style.position="absolute",o.style.left="-9999px",o.style.fontSize="12pt";const i=document.getSelection();let a=!1;i.rangeCount>0&&(a=i.getRangeAt(0)),t.append(o),o.select(),o.selectionStart=0,o.selectionEnd=e.length;let s=!1;try{s=document.execCommand("copy")}catch{}return o.remove(),a&&(i.removeAllRanges(),i.addRange(a)),r&&r.focus(),s}t.d(n,{Z:()=>o})}}]);