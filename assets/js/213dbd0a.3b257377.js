"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1696],{4911:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var i=n(87462),a=(n(67294),n(3905)),r=n(8209);const s={title:"Access Control Permissions",sidebar_position:3},o=void 0,l={unversionedId:"security/designing-permissions",id:"security/designing-permissions",isDocsHomePage:!1,title:"Access Control Permissions",description:"You can describe permissions attributed using a JSON",source:"@site/docs/common/security/designing-permissions.mdx",sourceDirName:"security",slug:"/security/designing-permissions",permalink:"/common/security/designing-permissions",editUrl:"https://github.com/getditto/docs/edit/main/docs/common/security/designing-permissions.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Access Control Permissions",sidebar_position:3},sidebar:"defaultSidebar",previous:{title:"Authentication",permalink:"/common/security/authentication"},next:{title:"Shared Key",permalink:"/common/security/shared-key"}},c=[{value:"Rejecting a user",id:"rejecting-a-user",children:[],level:2},{value:"Accepting a user",id:"accepting-a-user",children:[],level:2},{value:"Using the _id field",id:"using-the-_id-field",children:[],level:2},{value:"Example",id:"example",children:[],level:2},{value:"Threat modeling in P2P networks",id:"threat-modeling-in-p2p-networks",children:[{value:"Read-only security model",id:"read-only-security-model",children:[{value:"Read-only example",id:"read-only-example",children:[],level:4}],level:3},{value:"App-level Security",id:"app-level-security",children:[],level:3}],level:2}],d={toc:c},h="wrapper";function p(e){let{components:t,...n}=e;return(0,a.kt)(h,(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"You can describe permissions attributed using a JSON\ndocument. This JSON document is encoded within the certificate used by each\ndevice. Each peer verifies the cerificates of other peers, and accepts or rejects reads\nand writes based on these permissions."),(0,a.kt)("p",null,"You can issue each certificiate ",(0,a.kt)("a",{parentName:"p",href:"../how-it-works/certificate-security"},"manually")," or with the ",(0,a.kt)("a",{parentName:"p",href:"../security/authentication"},"Online with\nAuthentication identity"),". "),(0,a.kt)("h2",{id:"rejecting-a-user"},"Rejecting a user"),(0,a.kt)("p",null,"To reject a user from reading or writing at all, specify the JSON payload below."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsonc"},'{\n  "authenticate": false\n}\n')),(0,a.kt)("h2",{id:"accepting-a-user"},"Accepting a user"),(0,a.kt)("p",null,"To grant full ",(0,a.kt)("inlineCode",{parentName:"p"},"read")," & ",(0,a.kt)("inlineCode",{parentName:"p"},"write")," permissions to ",(0,a.kt)("em",{parentName:"p"},"all collections")," and ",(0,a.kt)("em",{parentName:"p"},"all documents"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsonc"},'{\n  "authenticate": true,\n  "expirationSeconds": 28800,\n  "userID": "123abc",\n  "permissions": {\n    "read": {\n      "everything": true,\n      "queriesByCollection": {}\n    },\n    "write": {\n      "everything": true,\n      "queriesByCollection": {}\n    }\n  }\n}\n')),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"authenticate")," to ",(0,a.kt)("inlineCode",{parentName:"li"},"true")," to tell the webhook that the user has successfully validated"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"expirationSeconds")," is ",(0,a.kt)("inlineCode",{parentName:"li"},"number")," property on how long the authentication session is valid for before a refresh is required."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"userID")," is a ",(0,a.kt)("inlineCode",{parentName:"li"},"string")," which identifies the the ",(0,a.kt)("inlineCode",{parentName:"li"},"userID"),". This should be ",(0,a.kt)("em",{parentName:"li"},"unique")," across users within your app. "),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"permissions")," which describes all the types of access control for collections and documents that this user can ",(0,a.kt)("inlineCode",{parentName:"li"},"read")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"write"))),(0,a.kt)("h2",{id:"using-the-_id-field"},"Using the _id field"),(0,a.kt)("p",null,"Currently, you can ",(0,a.kt)("strong",{parentName:"p"},"only specify a permission query on the ",(0,a.kt)("inlineCode",{parentName:"strong"},"_id")," field of a\ndocument"),". Permissions on mutable properties are currently not supported. "),(0,a.kt)("p",null,"To grant selective permissions on specific documents, add to the\n",(0,a.kt)("inlineCode",{parentName:"p"},"queriesByCollection")," property inside either the ",(0,a.kt)("inlineCode",{parentName:"p"},"read")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"write")," property.\nEach key inside ",(0,a.kt)("inlineCode",{parentName:"p"},"queriesByCollection")," is a reference to the collection. Each\nvalue is an array of ",(0,a.kt)("a",{parentName:"p",href:"../concepts/querying"},"ditto queries")," describing which\ndocuments the user can read or write."),(0,a.kt)("h2",{id:"example"},"Example"),(0,a.kt)("p",null,"The following write permissions below describe that ",(0,a.kt)("inlineCode",{parentName:"p"},'userID: "123abc"')," can"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"write")," to documents in the ",(0,a.kt)("inlineCode",{parentName:"li"},'"books"')," collection where the ",(0,a.kt)("inlineCode",{parentName:"li"},"_id.locationId == 'abcedef123456'"),"."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"write")," to any document in the ",(0,a.kt)("inlineCode",{parentName:"li"},'"newspapers"')," collection. We use a single value of ",(0,a.kt)("inlineCode",{parentName:"li"},"true")," "),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"read")," to documents in the ",(0,a.kt)("inlineCode",{parentName:"li"},'"books"')," collection where the ",(0,a.kt)("inlineCode",{parentName:"li"},"_id.locationId == 'abcedef123456'"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsonc"},'{\n  "authenticate": true,\n  "expirationSeconds": 28800,\n  "userID": "123abc",\n  "permissions": {\n    "write": {\n      "everything": false, // ensure that this is false\n      "queriesByCollection": {\n        // highlight-start\n        // 1. \n        "books": [\n          _id.locationId == \'abcedef123456\'\n        ],\n        // highlight-end\n        \n        // highlight-start\n        // 2. \n        "newspapers": [\n          "true"\n        ]\n        // highlight-end\n      }\n    },\n    "read": {\n      "everything": false, // ensure that this is false\n      "queriesByCollection": {\n        // highlight-start\n        // 3.\n        "books": [\n          _id.locationId == \'abcedef123456\'\n        ],\n        // highlight-end\n      }\n    }\n  }\n}\n')),(0,a.kt)("h2",{id:"threat-modeling-in-p2p-networks"},"Threat modeling in P2P networks"),(0,a.kt)("p",null,"Threat modeling is a process used by software engineers to identify, analyze,\nand prioritize threats that could potentially impact an application. It helps\nengineers identify potential weak points in an application and take steps to\nmitigate those risks. Threat modeling involves identifying the assets that an\napplication needs to protect, assessing the potential threats to those assets,\nand determining the best ways to protect them."),(0,a.kt)("p",null,"By identifying potential risks, engineers can ensure that the application is\nsecure from malicious actors and that users' data is protected. Threat modeling\ncan also help ensure that the application meets the company's security\nstandards and regulations. "),(0,a.kt)("p",null,"Threat modeling in peer-to-peer (P2P) networks is different than that in\nclient-server networks due to the distributed nature of the P2P network. In a\nclient-server network, there is a single server that all clients connect to, and\nthus all of the data and resources are centralized. This makes it easier to\nidentify potential threats and vulnerabilities, but creates a entry that can be\ntargeted by an attacker, making it easier to exploit the entire network at once."),(0,a.kt)("p",null,"Peer-to-peer (P2P) networks are networks that do not have a central server, but\nrather all nodes are equal, allowing clients to share resources with each other\ndirectly. As such, P2P networks have more restrictive permissions on\nsynchronization than client-server authentication systems, as nodes are required\nto agree to any changes made by other peers. This is done to ensure that no node\nhas an advantage over another and that all nodes remain secure.  "),(0,a.kt)("p",null,"Therefore, even though peers in Ditto may have overlapping subscriptions, Ditto peers are only able\nto synchronize data directly from a peer that has the authority to write that\ndocument. In other words, small peers are only able to trust writes from other peers that have\nthe authority to make those writes. They cannot trust each other as a source of\ndata that they aren't authorized to write to, since they can't tell the\ndifference between an edit they made on their own and one which came from a\nfurther hop."),(0,a.kt)("h3",{id:"read-only-security-model"},"Read-only security model"),(0,a.kt)("p",null,"Because Ditto peers are only able to synchronize data directly from a peer that has the authority to write that document, a read-only security model comes with some caveats. This section covers how to best implement this security model and the trade-offs that exist in peer-to-peer networks."),(0,a.kt)("p",null,"Ditto provides a mechanism to specify which small peers can read documents in a collection ",(0,a.kt)("em",{parentName:"p"},"without permission to write"),". This can be useful in situations where you have restrictive user roles, such as customer and employee. "),(0,a.kt)("p",null,"To implement read-only documents, you should create restrictive write permissions that include the ",(0,a.kt)("inlineCode",{parentName:"p"},"userId")," inside of the document ",(0,a.kt)("inlineCode",{parentName:"p"},"_id"),".  Ditto ensures that only those authorized to create documents with a particular document ",(0,a.kt)("inlineCode",{parentName:"p"},"_id")," are able to synchronize those documents in a trustworthy manner throughout the system. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'{\n  "authenticate": true,\n  "expirationSeconds": 28800,\n  "userID": "A",\n  "permissions": {\n    "read": {\n      "everything": true,\n      "queriesByCollection": {}\n    },\n    "write": {\n      "everything": false,\n      "queriesByCollection": {\n        "messages": ["_id.userID == \'A\'"]\n      }\n    }\n  }\n}\n')),(0,a.kt)("h4",{id:"read-only-example"},"Read-only example"),(0,a.kt)("p",null,"In this example, peers can read chat messages from other people, but cannot\nwrite to them. They can only write their own chat messages."),(0,a.kt)("p",null,"Imagine three peers, Peer A, B, and C. Peers A and B are connected, but Peer C only connected to peer\nB. "),(0,a.kt)(r.G,{config:'{"mermaid":{"themeVariables":{"fontFamily":"Helvetica"},"sequence":{"actorFontFamily":"Helvetica","noteFontFamily":"Helvetica","messageFontFamily":"Helvetica"},"journey":{"taskFontFamily":"Helvetica"}}}',chart:"graph LR;\n    A[A] --\x3e C[fa:fa-mobile B];\n    C--\x3e D[fa:fa-mobile C];",mdxType:"Mermaid"}),(0,a.kt)("p",null,"Every peer has similar permissions, where they can read everything but can only write to a collection with an ",(0,a.kt)("inlineCode",{parentName:"p"},"_id")," that represents their ",(0,a.kt)("inlineCode",{parentName:"p"},"userID"),". So, for example, Peer A has the following permissions:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsonc"},'{\n  "authenticate": true,\n  "expirationSeconds": 28800,\n  "userID": "A",\n  "permissions": {\n    "read": {\n      "everything": true,\n      "queriesByCollection": {}\n    },\n    "write": {\n      "everything": false,\n      "queriesByCollection": {\n        "messages": ["_id.userID == \'A\'"]\n      }\n    }\n  }\n}\n')),(0,a.kt)("p",null,"Peer A writes a message and syncs that message to B."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "_id": {\n    "messageId": "00372532806762369024",\n    "userID": "A"\n  },\n  "text": "Hello world!"\n}\n')),(0,a.kt)(r.G,{chart:"graph LR;\n    A[A] --\x3e |sync| C[fa:fa-mobile B];",mdxType:"Mermaid"}),(0,a.kt)("p",null,"However, Peer B cannot forward that message from A to C. This is because peer B does not have write permissions to create documents with ",(0,a.kt)("inlineCode",{parentName:"p"},"userID=A"),". "),(0,a.kt)(r.G,{chart:'graph LR;\n    A[A] --\x3e|sync| B((fa:fa-cloud Big Peer));\n    B("B")-.Does not sync. B does not have write permissions for userID=A.-> C[fa:fa-mobile C];',mdxType:"Mermaid"}),(0,a.kt)("p",null,"Today Ditto enforces that data which has to propagate peer-to-peer must have mutual\nwrite permissions. If integrity is at risk, you have to sign the payloads\nyourself at the application level."),(0,a.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("h3",{parentName:"div",id:"threat"},"Threat"),(0,a.kt)("p",{parentName:"div"},"A hacker attempts to write messages ",(0,a.kt)("em",{parentName:"p"},"pretending to be peer A")," even though they are only allowed to read. "),(0,a.kt)("ol",{parentName:"div"},(0,a.kt)("li",{parentName:"ol"},"Steal mobile phone that is authorized as Peer B"),(0,a.kt)("li",{parentName:"ol"},"Create documents pretending to be Peer A.  ")),(0,a.kt)("p",{parentName:"div"},"This is a credible attack vector, especially if Peer A represents an authority\nin the system, such as an administrative user. This design prevents a hacker\nfrom impersonating Peer A, because other peers will only synchronize documents\nfrom Peer A when they have a direct connection to Peer A, and can verify their certificate is valid.  "))),(0,a.kt)("h3",{id:"app-level-security"},"App-level Security"),(0,a.kt)("p",null,"The access rules contained in the identity are rigid, signed by the central\ncertificate authority, and enforced by all participating devices. This offers\nthe highest level of security. If a device is not allowed to access particular\ndata, it will never be synced to their device. See ",(0,a.kt)("a",{parentName:"p",href:"../mesh-network/query-overlap-groups"},"Query Overlap\nGroups"),", for more details on multi-hopping\nthrough untrusted devices."),(0,a.kt)("p",null,"For apps with weaker security requirements, a developer may choose to relax the\naccess rules inside the Ditto certificate, and instead restrict access in their application code."),(0,a.kt)("p",null,"One advantage is that the developer has more flexibility to change the access\nrules dynamically since they are not encoded in signed certificates. Another\nadvantage is that all devices in the mesh can participate in syncing the data,\nwhich may help it propagate faster. If certain data is only accessible to a few\nprivileged devices which are not often in range of each other, it will take\nlonger for them to sync."),(0,a.kt)("p",null,"The disadvantage is that an unprivileged user does have a device containing\nprivileged data. A technically savvy user or phone thief may be able to gain\naccess to not only their regular data, but also the more privileged data that\nthey were never intended to be able to view."),(0,a.kt)("p",null,"Therefore relaxed access rules - app-level security - are only suitable for\nenvironments where there is a degree of trust that the devices won't end up\nunlocked in the wrong hands."))}p.isMDXComponent=!0}}]);