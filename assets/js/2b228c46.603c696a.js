(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9685],{50494:(e,n,t)=>{"use strict";t.d(n,{Z:()=>D});var o=t(87462),r=t(86010),i=t(67294),a=t(45697),s=t.n(a),c=t(44225),l=t(90401),d=t(23184),p=t(90858),u=t(89713),m=t(63680),g=t(78372),y=t(77832);const f=e=>{let{className:n,...t}=e;return i.createElement(c.t,(0,o.Z)({className:(0,r.Z)("text-[#3ddb85]",n)},t))},h=e=>{let{className:n,...t}=e;return i.createElement(l.A,(0,o.Z)({className:(0,r.Z)("text-text",n)},t))};h.propTypes=f.propTypes={className:s().string};const D=[{id:"javascript",name:"JavaScript",icon:function(e){return i.createElement("svg",(0,o.Z)({viewBox:"0 0 48 48",fill:"none",xmlns:"http://www.w3.org/2000/svg"},e),i.createElement("path",{d:"M0 10C0 4.47715 4.47715 0 10 0H38C43.5229 0 48 4.47715 48 10V38C48 43.5229 43.5228 48 38 48H10C4.47715 48 0 43.5228 0 38V10Z",fill:"#F5DE19"}),i.createElement("path",{d:"M32.3894 37.6804C32.8 38.5145 33.4379 39.2155 34.2296 39.7027C35.0213 40.1899 35.9346 40.4435 36.8642 40.4342C38.7402 40.4342 39.9398 39.4962 39.9398 38.1968C39.9398 36.6478 38.7075 36.0936 36.6422 35.19L35.5097 34.7047C32.2396 33.3123 30.071 31.5688 30.071 27.8822C30.071 24.4865 32.6527 21.8997 36.7024 21.8997C38.0134 21.805 39.3232 22.0984 40.4686 22.7433C41.6139 23.3882 42.544 24.356 43.1428 25.5261L39.6025 27.7893C39.3719 27.2092 38.9704 26.7128 38.4512 26.3661C37.9321 26.0194 37.3198 25.8387 36.6956 25.8479C36.4232 25.8206 36.1482 25.8504 35.888 25.9353C35.6278 26.0202 35.3881 26.1584 35.1842 26.341C34.9804 26.5237 34.8168 26.7468 34.7039 26.9961C34.5911 27.2455 34.5314 27.5156 34.5287 27.7893C34.5287 29.1472 35.3703 29.698 37.3134 30.5431L38.4459 31.0284C42.2943 32.6789 44.4698 34.3604 44.4698 38.1417C44.4698 42.219 41.2668 44.453 36.9658 44.453C35.2899 44.5597 33.619 44.1793 32.1546 43.3574C30.6902 42.5356 29.495 41.3076 28.7131 39.8215L32.3894 37.6804ZM16.3917 38.0728C17.1025 39.3344 17.7496 40.4015 19.3055 40.4015C20.7925 40.4015 21.7323 39.8198 21.7323 37.5565V22.1579H26.2605V37.6168C26.2605 42.305 23.5067 44.4392 19.4983 44.4392C18.0814 44.5166 16.6742 44.1635 15.4617 43.4263C14.2493 42.689 13.2883 41.6022 12.7051 40.3086L16.3917 38.0728Z",fill:"black"}))}},{id:"android",name:"Android",icon:f},{id:"ios",name:"iOS",icon:h},{id:"csharp",name:"C#",icon:e=>{let{className:n,...t}=e;return i.createElement(m.F,(0,o.Z)({className:(0,r.Z)("text-[#08940e]",n)},t))}},{id:"http",name:"HTTP",icon:u.d},{id:"linux",name:"Linux",icon:e=>{let{className:n,...t}=e;return i.createElement(y.L,(0,o.Z)({className:(0,r.Z)("text-[#f5c11c]",n)},t))}},{id:"rust",name:"Rust",icon:e=>{let{className:n,...t}=e;return i.createElement(g.T,(0,o.Z)({className:(0,r.Z)("text-[black]",n)},t))}},{id:"cpp",name:"C++",icon:e=>{let{className:n,...t}=e;return i.createElement(d.q,(0,o.Z)({className:(0,r.Z)("text-[#283492]",n)},t))}},{id:"python",name:"Python",icon:p.i,disabled:!0}]},36438:(e,n,t)=>{"use strict";t.d(n,{p:()=>u,Z:()=>m});var o=t(67294),r=t(80944);const i=e=>{let n=[{label:"JavaScript",value:"javascript"},{label:"Swift",value:"swift"},{label:"Objective-C",value:"objc"},{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"},{label:"C#",value:"csharp"},{label:"C++",value:"cpp"},{label:"Rust",value:"rust"},{label:"HTTP",value:"http"}];switch(e){case"android":n=[{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"}];break;case"ios":n=[{label:"Swift",value:"swift"},{label:"Objective-C",value:"objc"}];break;case"linux":n=[{label:"NodeJS",value:"javascript"},{label:"C++",value:"cpp"},{label:"Rust",value:"rust"},{label:"HTTP",value:"http"}];case void 0:break;default:n=n.filter((n=>n.value===e))}return n},a=JSON.parse('{"rust":{"remove-query":"let removed_ids = col_tx\\n    .find_with_args(\\"color == $args.color\\", json!({\\"color\\": \\"yellow\\"}))\\n    .remove()\\n    .unwrap();\\n\\n","evict":"let evicted_ids = collection\\n    .find_with_args(\\"$args.color == color\\", json!({\\"color\\": \\"red\\"}))\\n    .sort(vec![sort_param])\\n    .evict()\\n    .unwrap();\\n\\n","sync-basic":"ditto.start_sync()?;\\n\\n","datamodel":"let store = ditto.store();\\nlet collection = store.collection(\\"people\\").unwrap();\\n\\n","upsert-id":"let doc_id = DocumentId::new(&\\"123abc\\".to_string()).unwrap();\\nlet person = json!({ // Person implements serde::Serialize\\n    \\"_id\\": doc_id,\\n    \\"name\\": \\"Susan\\".to_string(),\\n    \\"age\\": 31,\\n});\\ncollection.upsert(person).unwrap();\\n\\n","array-to-map":"collection\\n    .find_by_id(doc_id)\\n    .update(|opt_doc| {\\n        if let Some(doc) = opt_doc {\\n            let friends: DittoRegister = doc.get(\\"friends\\").unwrap();\\n            let mut map = HashMap::new();\\n            let array = friends.value.as_array().unwrap();\\n\\n            for name in array {\\n                let id = Uuid::new_v4().to_string();\\n                let friend = json!({\\n                    \\"name\\": name,\\n                    \\"id\\": id\\n                });\\n                map.insert(id, friend);\\n            }\\n\\n            doc.set(\\"friendsMap\\", map).unwrap();\\n        }\\n    })\\n    .unwrap();\\n\\n","upsert":"let person = json!({\\n    \\"name\\": \\"Susan\\".to_string(),\\n    \\"age\\": 31,\\n});\\nlet collection = ditto.store().collection(\\"people\\").unwrap();\\nlet id = collection.upsert(person).unwrap();\\n\\n","remove-id":"collection.find_by_id(id).remove().unwrap();\\n\\n","upsert-composite-primary-key":"let collection = ditto.store().collection(\\"people\\").unwrap();\\nlet complex_id = PersonId {\\n    user_id: \\"456abc\\".to_string(),\\n    work_id: 789,\\n};\\nlet doc_id = DocumentId::new(&serde_json::json!(complex_id)).unwrap();\\nlet doc = json!({\\n    \\"_id\\": doc_id,\\n    \\"name\\": \\"Susan\\".to_string(),\\n    \\"age\\": 31,\\n});\\ncollection.upsert(doc).unwrap();\\n\\n","upsert-datatypes":"collection\\n    .upsert(json!({\\n      \\"boolean\\": true,\\n      \\"string\\": \\"Hello World\\",\\n      \\"number\\": 10,\\n      \\"map\\": {\\n        \\"key\\": \\"value\\"\\n      },\\n      \\"array\\": [1,2,3],\\n      \\"null\\": null,\\n    }))\\n    .unwrap();\\n\\n","upsert-default-data":"let default_id = DocumentId::new(&\\"123abc\\".to_string()).unwrap();\\nlet data = json!({ // Person implements serde::Serialize\\n    \\"_id\\": default_id,\\n    \\"name\\": \\"Susan\\".to_string(),\\n    \\"age\\": 31,\\n});\\ncollection\\n    .upsert_with_strategy(data, WriteStrategy::InsertDefaultIfAbsent)\\n    .unwrap();\\n\\n","attachment":"let store = ditto.store();\\nlet collection = store.collection(\\"foo\\")?;\\nlet attachment_file_path = images_dir.join(\\"image.png\\");\\nlet mut metadata = HashMap::new();\\nmetadata.insert(\\"some\\".to_owned(), \\"string\\".to_owned());\\nlet attachment =\\n    collection.new_attachment(attachment_file_path.to_str().unwrap(), metadata)?;\\nlet doc_id = DocumentId::new(&\\"123abc\\".to_string())?;\\nlet content = json!({\\"_id\\": doc_id, \\"some\\": \\"string\\", \\"my_attachment\\": attachment});\\nlet _ = collection.upsert(content)?;\\n// Later or on another peer ...\\nlet doc = collection.find_by_id(doc_id).exec()?;\\nlet attachment_token = doc.get::<DittoAttachmentToken>(\\"my_attachment\\")?;\\nlet (tx, rx) = channel();\\nlet m_tx = std::sync::Mutex::new(tx);\\nlet fetcher = collection.fetch_attachment(attachment_token, move |event| {\\n    // completion handler\\n    if let DittoAttachmentFetchEvent::Completed { attachment } = event {\\n        let tx = m_tx.lock().unwrap();\\n        tx.send(attachment).unwrap();\\n    }\\n})?;\\nlet fetched_attachment = rx.recv().unwrap(); // may also use an async version or other sync strategy\\nlet attachment_file_path = fetched_attachment.path();\\nstd::fs::read(attachment_file_path)?;\\n\\n","counter":"let collection = ditto.store().collection(\\"people\\").unwrap();\\nlet doc_id = collection\\n    .upsert(json!({\\"name\\": \\"Frank\\", \\"owned_cars\\": DittoCounter::new()}))\\n    .unwrap();\\n\\ncollection\\n    .find_by_id(doc_id)\\n    .update(|x| {\\n        if let Some(doc) = x {\\n            doc.increment(\\"owned_cars\\", 1.0).unwrap();\\n        }\\n    })\\n    .unwrap();\\n\\n","update":"let collection = ditto.store().collection(\\"people\\").unwrap();\\nlet doc_id = collection\\n    .upsert(json!({\\"name\\": \\"Frank\\", \\"owned_cars\\": DittoCounter::new()}))\\n    .unwrap();\\n\\ncollection\\n    .find_by_id(doc_id)\\n    .update(|opt_doc| {\\n        if let Some(doc) = opt_doc {\\n            doc.set(\\"age\\", 32).unwrap();\\n            doc.increment(\\"owned_cars\\", 1.0).unwrap();\\n        }\\n    })\\n    .unwrap();\\n\\n","query-basic":"collection\\n    .find(\\"favoriteBook.title == \\\\\'The Great Gatsby\\\\\'\\")\\n    .exec()?;\\n\\n","query-args":"let args = json!({\\"name\\": \\"Susan\\", \\"age\\": 32});\\ncollection\\n    .find_with_args(\\"name == $args.name && age <= $args.age\\", args)\\n    .exec()?;\\n\\n","query-sort":"let sort_param = ffi_sdk::COrderByParam {\\n    query_c_str: c!(\\"miles\\"),\\n    direction: ffi_sdk::QuerySortDirection::Ascending,\\n};\\ncollection\\n    .find(\\"color == \\\\\'red\\\\\'\\")\\n    .sort(vec![sort_param])\\n    .exec()?;\\n\\n","query-limit":"let sort_param = ffi_sdk::COrderByParam {\\n    query_c_str: c!(\\"rank\\"),\\n    direction: ffi_sdk::QuerySortDirection::Ascending,\\n};\\ncollection\\n    .find(\\"color == \\\\\'red\\\\\'\\")\\n    .sort(vec![sort_param])\\n    .limit(100)\\n    .exec()?;\\n\\n","subscribe":"let store = ditto.store(); // Ditto must have a longer lifetime than all live queries\\nlet live_query = store\\n    .collection(\\"cars\\")?\\n    .find(\\"color == \\\\\'red\\\\\'\\")\\n    .subscribe();\\n\\n","sync-observe":"let store = ditto.store(); // Ditto must have a longer lifetime than all live queries\\nlet (tx, rx) = channel();\\n{\\n    let live_query = store\\n        .collection(\\"cars\\")?\\n        .find(\\"color == \\\\\'red\\\\\'\\")\\n        .observe_local(move |mut docs: Vec<BoxedDocument>, event| {\\n            match event {\\n                LiveQueryEvent::Initial { .. } => { /* handle if appropriate */ }\\n                LiveQueryEvent::Update { mut insertions, .. } => {\\n                    insertions.sort_by(|a, b| b.cmp(a));\\n                    for idx in insertions.iter() {\\n                        let doc = docs.remove(*idx);\\n                        tx.send(doc).unwrap();\\n                    }\\n                }\\n            }\\n        })?;\\n    store\\n        .collection(\\"cars\\")?\\n        .upsert(json!({\\"color\\": \\"red\\"}))\\n        .unwrap();\\n    for doc in rx.iter() {\\n        println!(\\"New doc {:?}\\", doc);\\n    }\\n} // IMPORTANT: LiveQuery goes out of scope and is Dropped and terminated here.\\n\\n","sync-observe-local":"// Some action in your app ...\\nlet store = ditto.store();\\nstore.collection(\\"cars\\")?.upsert(json!({\\"color\\": \\"red\\"}))?;\\n// Elsewhere register handlers for data changes\\n{\\n    let live_query = store\\n        .collection(\\"cars\\")?\\n        .find(\\"color == \\\\\'red\\\\\'\\")\\n        .observe_local(move |cars, event| {\\n            println!(\\"cars {:?}, event {:?}\\", cars, event);\\n            // do something when data changes\\n            // BUT this closure must be permitted to take ownership\\n        })?;\\n    // stash your live query in something with a long lifetime\\n    // or it will be dropped\\n}\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every\\n// application.\\nlet p256_der_b64: &str = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nlet app_id = AppId::from_env(\\"app\\")?;\\nlet ditto = Ditto::builder()\\n    .with_root(Arc::new(PersistentRoot::from_current_exe()?))\\n    .with_identity(|ditto_root| identity::SharedKey::new(ditto_root, app_id, p256_der_b64))?\\n    .build()?;\\nlet res = ditto.set_offline_only_license_token(&license_token);\\nditto.start_sync()?;\\n\\n","online-playground":"let ditto = Ditto::builder()\\n    // creates a `ditto_data` folder in the directory containing the executing process\\n    .with_root(Arc::new(PersistentRoot::from_current_exe()?))\\n    .with_identity(|ditto_root| {\\n        // Provided as an env var, may also be provided as hardcoded string\\n        let app_id = AppId::from_env(\\"00000000-0000-4000-0000-000000000000\\")?;\\n        let shared_token = std::env::var(\\"REPLACE_ME_WITH_A_SHARED_TOKEN\\").unwrap();\\n        let enable_cloud_sync = true;\\n        let custom_auth_url = None;\\n        OnlinePlayground::new(\\n            ditto_root,\\n            app_id,\\n            shared_token,\\n            enable_cloud_sync,\\n            custom_auth_url,\\n        )\\n    })?\\n    .with_minimum_log_level(CLogLevel::Debug)\\n    .build()?;\\n\\nditto.start_sync()?;\\n\\n","offline-playground":"let ditto = Ditto::builder()\\n    // creates a `ditto_data` folder in the directory containing the executing process\\n    .with_root(Arc::new(PersistentRoot::from_current_exe()?))\\n    .with_identity(|ditto_root| {\\n        // Provided as an env var, may also be provided as hardcoded string\\n        let app_id = AppId::from_env(\\"00000000-0000-4000-0000-000000000000\\")?;\\n        OfflinePlayground::new(ditto_root, app_id)\\n    })?\\n    .build()?;\\n\\nditto.start_sync()?;\\nlet res = ditto.set_offline_only_license_token(&license_token);\\n\\n","network-remote-ditto":"let mut config = TransportConfig::new(); // empty\\n\\nconfig\\n    .connect\\n    .tcp_servers\\n    .insert(\\"135.1.5.5:12345\\".to_string()); // Custom TCP Listener\\nconfig\\n    .connect\\n    .tcp_servers\\n    .insert(\\"185.1.5.5:12345\\".to_string()); // Custom TCP Listener\\nconfig\\n    .connect\\n    .websocket_urls\\n    .insert(\\"wss://example.com\\".to_string()); // Custom WS endpoint\\n\\nditto.set_transport_config(config);\\nditto.start_sync()?;\\n\\n","network-listen":"let mut config = TransportConfig::new(); // empty\\n\\nconfig.listen.tcp.enabled = true;\\nconfig.listen.tcp.interface_ip = \\"0.0.0.0\\".to_string();\\nconfig.listen.tcp.port = 4000;\\nconfig.listen.http.enabled = false;\\n\\nditto.set_transport_config(config);\\nditto.start_sync()?;\\n\\n","transport-sync-groups":"let mut config = TransportConfig::new(); // empty\\n\\nconfig.enable_all_peer_to_peer();\\nconfig.global.sync_group = 1234;\\n\\nditto.set_transport_config(config);\\nditto.start_sync()?;\\n\\n","network-multiple-transports":"let mut config = TransportConfig::new(); // empty\\n\\n// 1. Enable auto-discovery of peer to peer connections\\nconfig.enable_all_peer_to_peer(); // Auto-connect via lan and bluetooth\\n\\n// 2. Configure TCP Listener\\nconfig.listen.tcp.enabled = true;\\nconfig.listen.tcp.interface_ip = \\"0.0.0.0\\".to_string();\\nconfig.listen.tcp.port = 4000;\\nconfig.listen.http.enabled = false;\\n\\n// 3. Configure explicit, hard coded connections\\nconfig\\n    .connect\\n    .tcp_servers\\n    .insert(\\"135.1.5.5:12345\\".to_string()); // Custom TCP Listener\\nconfig\\n    .connect\\n    .websocket_urls\\n    .insert(\\"wss://example.com\\".to_string()); // Custom WS endpoint\\n\\nditto.set_transport_config(config);\\nditto.start_sync()?;\\n\\n"},"objc":{"attachment":"NSBundle *testBundle = [NSBundle bundleForClass:self.class];\\nNSURL *attachmentTestImage = [testBundle URLForResource:@\\"attachment_test\\" withExtension:@\\"png\\"];\\nNSData *attachmentData = [NSData dataWithContentsOfURL:attachmentTestImage];\\n\\nNSDictionary<NSString *, NSString *> *metadata = @{@\\"name\\": @\\"my_image.png\\"};\\nDITAttachment *attachment = [collection newAttachment:attachmentTestImage.path metadata:metadata];\\n\\nDITDocumentID *docID = [collection upsert:@{@\\"some\\": @\\"string\\", @\\"my_attachment\\": attachment} error:nil];\\nDITDocument *doc = [[collection findByID:docID] exec];\\nDITAttachmentToken *attachmentToken = doc[@\\"my_attachment\\"].attachmentToken;\\n\\nDITAttachmentFetcher *fetcher = [collection fetchAttachment:attachmentToken onFetchEvent:^(DITAttachmentFetchEvent *event) {\\n    switch (event.type) {\\n        case DITAttachmentFetchEventTypeCompleted: {\\n            DITAttachmentFetchEventCompleted *completed = [event asCompleted];\\n            DITAttachment *fetchedAttachment = completed.attachment;\\n            NSData *fetchedAttachmentData = [fetchedAttachment getData:nil];\\n            [attachmentRoundtripExpectation fulfill];\\n            break;\\n        }\\n        case DITAttachmentFetchEventTypeProgress:\\n            break;\\n        default:\\n            break;\\n    }\\n}];\\n\\n\\n","counter":"[[collection find:@\\"make == \'Honda\'\\"] updateWithBlock:^(NSArray<DITMutableDocument *> *docs) {\\n    for (DITMutableDocument *doc in docs) {\\n        [doc[@\\"mileage\\"] set:DITCounter.new];\\n        [doc[@\\"mileage\\"].counter incrementBy:1];\\n    }\\n}];\\n\\n","datamodel":"DITCollection *collection = [store collection:@\\"people\\"];\\n\\n","upsert-id":"DITDocumentID *docId = [collection upsert:@{@\\"_id\\": @\\"123abc\\", @\\"name\\": @\\"Susan\\", @\\"age\\": @32 } error:nil];\\nNSLog(@\\"%@\\", docId); // => \\"123abc\\"\\n\\n","upsert":"DITDocumentID *docID = [[ditto.store collection:@\\"people\\"]\\n                         upsert:@{ @\\"name\\": @\\"Susan\\", @\\"age\\": @31 }\\n                         error:nil];\\n\\n","upsert-composite-primary-key":"DITDocumentID *docID = [[ditto.store collection:@\\"people\\"]\\n                upsert:@{\\n                  @\\"_id\\": @{ @\\"userId\\": @\\"456abc\\", @\\"workId\\": @789 },\\n                  @\\"name\\": @\\"John\\",\\n                  @\\"age\\": @31 }\\n                error:nil];\\nNSLog(@\\"%@\\", docID); // => \\"NSDictionary @{ @\\"userId\\": \\"456abc\\": @\\"workId\\": @789 }\\"\\n\\n","upsert-datatypes":"[[ditto.store collection:@\\"foo\\"]\\n    upsert:@{\\n        @\\"boolean\\": @true,\\n        @\\"string\\": @\\"Hello World\\",\\n        @\\"number\\": @10,\\n        @\\"map\\": @{ @\\"key\\": @\\"value\\" },\\n        @\\"array\\": @[ @1, @2, @3 ],\\n        @\\"null\\": [NSNull null]\\n    }\\n error:nil\\n];\\n\\n","upsert-default-data":"DITDocumentID *defaultDocID = [[ditto.store collection:@\\"people\\"]\\n                               upsert:@{ @\\"name\\": @\\"Susan\\", @\\"age\\": @31 }\\n                               writeStrategy: DITWriteStrategyInsertDefaultIfAbsent\\n                               error:nil];\\n\\n","query-basic":"NSArray *docs = [[[ditto.store collection:@\\"people\\"]\\n                    find:@\\"favoriteBook.title == \'The Great Gatsby\'\\"] exec];\\n\\n","query-args":"NSArray *documents = [[[ditto.store collection:@\\"people\\"] find:@\\"name == $args.name && age <= $args.age\\" withArgs:@{@\\"age\\": @32, @\\"name\\": @\\"Max\\"}] exec];\\n\\n","remove-query":"NSArray<DITDocumentID *> *removedIDs = [[[ditto.store collection:@\\"people\\"]\\n                                         find:@\\"name == \'Susan\'\\"] remove];\\n\\n","remove-id":"[[[ditto.store collection:@\\"test\\"] findByID:docID] remove];\\n\\n","update":"DITDocumentID *docID = [[ditto.store collection:@\\"people\\"] upsert:@{\\n    @\\"name\\": @\\"Frank\\",\\n    @\\"age\\": [NSNumber numberWithInt:31],\\n    @\\"ownedCars\\": DITCounter.new\\n} error:nil];\\n\\n\\nDITCollection *collection = [ditto.store collection:@\\"people\\"];\\n[[collection findByID:docID] updateWithBlock:^(DITMutableDocument *doc) {\\n    [doc[@\\"age\\"] set:[NSNumber numberWithInt:32]];\\n    [doc[@\\"ownedCars\\"].counter incrementBy:1];\\n}];\\n\\n","array-to-map":"[[collection findByID:docID] updateWithBlock:^(DITMutableDocument *doc) {\\n    NSMutableDictionary *map = [NSMutableDictionary new];\\n    NSArray *names = doc[@\\"friends\\"].arrayValue;\\n    for (id name in names) {\\n        NSString *uuid = [[NSUUID UUID] UUIDString];\\n        map[uuid] = @{\\n            @\\"id\\": uuid,\\n            @\\"name\\": name\\n        };\\n    }\\n    [doc[@\\"friendsMap\\"] set:map];\\n}];\\n\\n","query-sort":"NSArray *sortedRedCars = [[[[ditto.store collection:@\\"cars\\"]\\n                  find:@\\"color == \'red\'\\"]\\n                  sort:@\\"miles\\" direction:DITSortDirectionAscending] exec];\\n\\n","query-limit":"NSArray *sortedAndLimitedRedCars = [[[[[ditto.store collection:@\\"cars\\"]\\n                  find:@\\"color == \'red\'\\"]\\n                  sort:@\\"miles\\" direction:DITSortDirectionAscending]\\n                  limit:100] exec];\\n\\n","sync-basic":"NSError *error = nil;\\n[ditto startSync:&error];\\n\\n","write-transaction":"NSArray *results = [store write:^(DITWriteTransaction *tx) {\\n    DITScopedWriteTransaction *cars = tx[@\\"cars\\"];\\n    DITScopedWriteTransaction *people = tx[@\\"people\\"];\\n    DITDocumentID *docID = [[DITDocumentID alloc] initWithValue: @\\"abc123\\"];\\n    [people upsert:@{@\\"_id\\": docID, @\\"name\\": @\\"Susan\\"} error:nil];\\n    [cars upsert:@{@\\"make\\": @\\"Ford\\", @\\"color\\": @\\"black\\", @\\"owner\\": docID} error:nil];\\n    [cars upsert:@{@\\"make\\": @\\"Toyota\\", @\\"color\\": @\\"red\\", @\\"owner\\": docID} error:nil];\\n}];\\n\\n","sync-observe":"// Register live query to update UI\\nDITCollection *collection = [ditto.store collection:@\\"cars\\"];\\nDITLiveQuery *liveQuery = [[collection find:@\\"color == \'red\'\\"]\\n    observeLocal:^(NSArray<DITDocument *> *docs, DITLiveQueryEvent *event) {\\n\\n}];\\n\\n","subscribe":"// Register live query to update UI\\nDITCollection *collection = [ditto.store collection:@\\"cars\\"];\\nDITSubscription *subscription = [[collection find:@\\"color == \'red\'\\"] subscribe];\\n\\n","sync-observe-local":"// Register live query to update UI\\nDITCollection *collection = [ditto.store collection:@\\"cars\\"];\\n\\nDITLiveQuery *liveQuery = [[collection find:@\\"color == \'red\'\\"]\\n    observeLocal:^(NSArray<DITDocument *> *docs, DITLiveQueryEvent *event) {\\n\\n}];\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nNSString *p256_der_b64 = @\\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nDITIdentity *identity = [[DITIdentity alloc] initSharedKeyWithAppID:@\\"app\\" sharedKey:p256_der_b64];\\nDITDitto *ditto = [[DITDitto alloc] initWithIdentity:identity];\\n\\nNSError *error = nil;\\nif (![ditto setOfflineOnlyLicenseToken:validLicense error:&error]) {\\n    NSLog(@\\"Error setting license: %@\\", error);\\n}\\n\\n","online-playground-cloudSync":"DITIdentity *identity = [[DITIdentity alloc] initOnlinePlaygroundWithAppID:@\\"00000000-0000-4000-0000-000000000000\\"\\n                                                                     token:@\\"REPLACE_ME_WITH_A_SHARED_TOKEN\\"\\n                                                     // Set to false to disable syncing with the cloud\\n                                                      enableDittoCloudSync:YES];\\nDITDitto *ditto = [[DITDitto alloc] initWithIdentity:identity persistenceDirectory: dittoPersistenceDir];\\nNSError *error = nil;\\n[ditto startSync:&error];\\n\\n","online-playground":"DITIdentity *identity = [[DITIdentity alloc] initOnlinePlaygroundWithAppID:@\\"00000000-0000-4000-0000-000000000000\\"\\n                                                                     token:@\\"REPLACE_ME_WITH_A_SHARED_TOKEN\\"\\n                                                      enableDittoCloudSync:YES];\\nDITDitto *ditto = [[DITDitto alloc] initWithIdentity:identity persistenceDirectory: dittoPersistenceDir];\\nNSError *error = nil;\\n[ditto startSync:&error];\\n\\n","offline-playground":"DITIdentity *identity = [[DITIdentity alloc] initOfflinePlaygroundWithAppID:@\\"00000000-0000-4000-0000-000000000000\\"];\\nDITDitto *ditto = [[DITDitto alloc] initWithIdentity:identity];\\nNSError *error = nil;\\nif (![ditto setOfflineOnlyLicenseToken:validLicense error:&error]) {\\n  NSLog(@\\"Error setting license: %@\\", error);\\n}\\nif (![ditto startSync:&error]) {\\n  NSLog(@\\"Error starting sync: %@\\", error);\\n}\\n[ditto startSync:&error];\\n\\n","network-remote-ditto":"DITMutableTransportConfig *transportConfig = [[DITMutableTransportConfig alloc] init];\\n[transportConfig.connect.tcpServers addObject:@\\"135.1.5.5:12345\\"];\\n[transportConfig.connect.tcpServers addObject:@\\"185.1.5.5:12345\\"];\\n[ditto setTransportConfig:transportConfig];\\nNSError *err = nil;\\n[ditto startSync:&err];\\n\\n","network-listen":"DITMutableTransportConfig *transportConfig = [[DITMutableTransportConfig alloc] init];\\n[transportConfig.listen.tcp setEnabled:true];\\n[transportConfig.listen.tcp setInterfaceIp:@\\"0.0.0.0\\"];\\n[transportConfig.listen.tcp setPort:4000];\\n[ditto setTransportConfig:transportConfig];\\nNSError *err = nil;\\n[ditto startSync:&err];\\n\\n","network-multiple-transports":"DITMutableTransportConfig *transportConfig = [[DITMutableTransportConfig alloc] init];\\n// 1. Enable Local Area Network Connections\\n[transportConfig enableAllPeerToPeer];\\n// 2. Listen for incoming connections on port 4000\\n[transportConfig.listen.tcp setEnabled:true];\\n[transportConfig.listen.tcp setInterfaceIp:@\\"0.0.0.0\\"];\\n[transportConfig.listen.tcp setPort:4000];\\n// 3. Connect explicitly to remote devices\\n[transportConfig.connect.tcpServers addObject:@\\"135.1.5.5:12345\\"];\\n[transportConfig.connect.tcpServers addObject:@\\"185.1.5.5:12345\\"];\\n\\n[ditto setTransportConfig:transportConfig];\\nNSError *err = nil;\\n[ditto startSync:&err];\\n\\n","websocket-connect":"DITMutableTransportConfig *transportConfig = [[DITMutableTransportConfig alloc] init];\\n\\n[transportConfig enableAllPeerToPeer];\\n\\n[transportConfig.connect.websocketURLs addObject:@\\"ws://127.0.0.1\\"];\\n\\n[ditto setTransportConfig:transportConfig];\\nNSError *err = nil;\\n[ditto startSync:&err];\\n\\n","transport-configurations":"DITMutableTransportConfig *transportConfig = [[DITMutableTransportConfig alloc] init];\\n\\n//Enable all peer to peer transports\\n[transportConfig enableAllPeerToPeer];\\n\\n//Or enable/disable each transport separately\\n//BluetoothLe\\n[transportConfig.peerToPeer.bluetoothLe setEnabled:true];\\n//Local Area Network\\n[transportConfig.peerToPeer.lan setEnabled:true];\\n//Awdl\\n[transportConfig.peerToPeer.awdl setEnabled:true];\\n\\n[ditto setTransportConfig:transportConfig];\\nNSError *err = nil;\\n[ditto startSync:&err];\\n\\n","network-monitor-conditions":"// Setting up inside a ViewController\\nDITIdentity *identity = [[DITIdentity alloc] initOnlinePlaygroundWithAppID:@\\"REPLACE_WITH_APP_ID\\" token:@\\"REPLACE_WITH_PLAYGROUND_TOKEN\\"];\\nDITDitto *ditto = [[DITDitto alloc] initWithIdentity:identity];\\nditto.delegate = self;\\n[ditto startSync:nil];\\n\\n// Now you can observe real time changes to the transport conditions:\\n@interface ViewController () <DITDittoDelegate>\\n\\n@end\\n\\n@implementation ViewController\\n\\n- (void)transportConditionChanged:(enum DITTransportCondition)condition forSubsystem:(enum DITConditionSource)source {\\n    if (condition == DITTransportConditionBleDisabled) {\\n        NSLog(@\\"BLE disabled\\");\\n    } else if (condition == DITTransportConditionNoBleCentralPermission) {\\n        NSLog(@\\"Permission missing for BLE\\");\\n    } else if (condition == DITTransportConditionNoBlePeripheralPermission) {\\n        NSLog(@\\"Permission missing for BLE\\");\\n    }\\n}\\n\\n@end\\n\\n","network-query-overlap-group":"NSString *const orders = @\\"orders\\";\\n\\n// The passenger only observes orders that they created\\n[[[passenger.store collection:orders] find:@\\"user_id==abc123\\"] observeLocal:^(NSArray<DITDocument *> *docs, DITLiveQueryEvent *event) {\\n    // render my orders in a list UI\\n}];\\n\\n// Crew member devices observe all orders that everyone created\\n[[[crewA.store collection:orders] find:@\\"status == \'OPEN\'\\"] observeLocal:^(NSArray<DITDocument *> *docs, DITLiveQueryEvent *event) {\\n    // render all orders in a list UI\\n}];\\n\\n[[[crewB.store collection:orders] find:@\\"status == \'OPEN\'\\"] observeLocal:^(NSArray<DITDocument *> *docs, DITLiveQueryEvent *event) {\\n    // render all orders\\n}];\\n\\n// Set up our query overlap group and priorities such that the crew members\\n// will construct multihop connections with each other.\\n[DITExperimental setQueryOverlapGroup:2 ditto:crewA];\\n[DITExperimental setQueryOverlapGroup:2 ditto:crewB];\\n\\n// Query overlap groups should be set before startSync\\n[crewA startSync:nil];\\n[crewB startSync:nil];\\n[passenger startSync:nil];\\n\\n","network-set-priority":"[DITExperimental setPriority:DITConnectionPriorityHigh\\n                 forQueryOverlapGroup:2 ditto:crewA];\\n[DITExperimental setPriority:DITConnectionPriorityHigh\\n        forQueryOverlapGroup:2 ditto:crewB];\\n\\n","transport-sync-groups":"DITMutableTransportConfig *transportConfig = [[DITMutableTransportConfig alloc] init];\\n// 1. Enable All Peer to Peer Connection\\n[transportConfig enableAllPeerToPeer];\\n// 2. Set sync group to an integer between 0 and 2^32\\ntransportConfig.global.syncGroup = 12312;\\n\\n[ditto setTransportConfig:transportConfig];\\nNSError *error = nil;\\n[ditto startSync:&error];\\n\\n","evict":"NSArray<DITDocumentID *> *evictedIDs = [[collection find:@\\"make == \'Honda\'\\"] evict];\\n\\n"},"swift":{"shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nlet p256DerB64 = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\"\\n\\nlet identity = DittoIdentity.sharedKey(appID: \\"app\\", sharedKey: p256DerB64)\\nlet ditto = Ditto(identity: identity, persistenceDirectory: dittoPersistenceDir)\\ndo {\\n    try ditto.setOfflineOnlyLicenseToken(validLicense);\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","write-transaction":"ditto.store.write { transaction in\\n    let cars = transaction.scoped(toCollectionNamed: \\"cars\\")\\n    let people = transaction.scoped(toCollectionNamed: \\"people\\")\\n    let docId = \\"abc123\\"\\n    do {\\n        try people.upsert([\\"_id\\": docId, \\"name\\": \\"Susan\\"] as [String: Any?])\\n        try cars.upsert([\\"make\\": \\"Ford\\", \\"color\\": \\"red\\", \\"owner\\": docId] as [String: Any?])\\n        try cars.upsert([\\"make\\": \\"Toyota\\", \\"color\\": \\"black\\", \\"owner\\": docId] as [String: Any?])\\n    } catch (let err) {\\n      print(err.localizedDescription)\\n    }\\n    people.findByID(docId).evict()\\n}\\n\\n","online-playground":"DittoLogger.minimumLogLevel = .debug\\nlet ditto = Ditto(identity: .onlinePlayground(\\n    appID: \\"00000000-0000-4000-0000-000000000000\\",\\n    token: \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\"\\n))\\ndo {\\n  try ditto.startSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","online-playground-cloudSync":"let ditto = Ditto(identity: .onlinePlayground(\\n    appID: \\"00000000-0000-4000-0000-000000000000\\",\\n    token: \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\",\\n    // Set to false to disable syncing with the cloud\\n    enableDittoCloudSync: true\\n))\\ndo {\\n  try ditto.startSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","offline-playground":"var ditto = Ditto(identity: DittoIdentity.offlinePlayground(\\n    appID: \\"00000000-0000-4000-0000-000000000000\\"\\n))\\ntry! ditto.setOfflineOnlyLicenseToken(validLicense);\\ntry! ditto.startSync()\\n\\n","datamodel":"let carsCollection = ditto.store[\\"cars\\"]\\n// or\\nlet carsCollection = ditto.store.collection(\\"cars\\")\\n\\n","attachment":"let collection = ditto.store[\\"foo\\"]\\n\\nlet myImageURL = bundle.url(forResource: \\"image\\", withExtension: \\"png\\")!\\n\\nlet metadata = [\\"name\\": \\"my_image.png\\"]\\nlet attachment = collection.newAttachment(\\n    path: myImageURL.path,\\n    metadata: metadata\\n)!\\n\\nguard let docID = try? collection.upsert([\\"some\\": \\"string\\", \\"my_attachment\\": attachment]) else {\\n    // handle error\\n    return\\n}\\n\\n// Later, find the document and the fetch the attachment\\n\\nlet doc = collection.findByID(docID).exec()\\nlet attachmentToken = doc![\\"my_attachment\\"].attachmentToken!\\n\\nlet fetcher = collection.fetchAttachment(token: attachmentToken) { status in\\n    switch status {\\n    case .completed(let fetchedAttachment):\\n        // Do something with attachment\\n    default:\\n        print(\\"Unable to fetch attachment\\")\\n    }\\n}\\n\\n","upsert-default-data":"do {\\n    let docID = try ditto.store[\\"people\\"].upsert([\\n        \\"name\\": \\"Susan\\",\\n        \\"age\\": 31\\n    ], writeStrategy: .insertDefaultIfAbsent)\\n} catch {\\n    //handle error\\n    print(error)\\n}\\n\\n","upsert-composite-primary-key":"do {\\n    let docID = try ditto.store[\\"people\\"].upsert([\\n        \\"_id\\": [ \\"userId\\": \\"456abc\\", \\"workId\\": 789 ],\\n        \\"name\\": \\"Susan\\",\\n        \\"age\\": 31\\n    ])\\n    print(docID) // \\"[ \\"userId\\": \\"456abc\\", \\"workId\\": 789 ]\\"\\n} catch {\\n    //handle error\\n    print(error)\\n}\\n\\n","upsert-datatypes":"do {\\n    // Insert JSON-compatible data into Ditto\\n    try ditto.store[\\"foo\\"].upsert([\\n        \\"boolean\\": true,\\n        \\"string\\": \\"Hello World\\",\\n        \\"number\\": 10,\\n        \\"map\\": [\\"key\\": \\"value\\"],\\n        \\"array\\": [1,2,3],\\n        \\"null\\": nil\\n    ])\\n}\\ncatch {\\n    //handle error\\n    print(error)\\n}\\n\\n","counter":"do {\\n    let docId = try ditto.store[\\"people\\"].upsert([\\n        \\"name\\": \\"Frank\\",\\n        \\"ownedCars\\": DittoCounter() // here 0 is a number\\n    ])\\n\\n    ditto.store[\\"people\\"].findByID(docId).update({ mutableDoc in\\n        mutableDoc?[\\"ownedCars\\"].counter?.increment(by: 1)\\n    })\\n} catch {\\n    //handle error\\n    print(error)\\n}\\n\\n","update":"do {\\n    let docID = try ditto.store[\\"people\\"].upsert([\\n        \\"name\\": \\"Frank\\",\\n        \\"age\\": 31,\\n        \\"ownedCars\\": DittoCounter()\\n    ])\\n\\n    ditto.store[\\"people\\"].findByID(docID).update { mutableDoc in\\n        mutableDoc?[\\"age\\"] = 32\\n        mutableDoc?[\\"ownedCars\\"].counter?.increment(by: 1)\\n    }\\n} catch {\\n    //handle error\\n    print(error)\\n}\\n\\n","array-to-map":"collection.findByID(docID).update { doc in\\n    guard let doc = doc else {\\n        print(\\"Document with id=\\\\(docID) not found\\")\\n        return\\n    }\\n\\n    let names = doc[\\"friends\\"].arrayValue\\n    var dict = Dictionary<String, Any>()\\n\\n    _ = names.map { name in\\n        let friend: NSMutableDictionary = [:]\\n        let id = UUID().uuidString\\n        friend[\\"id\\"] = id\\n        friend[\\"name\\"] = name\\n        dict.updateValue(friend, forKey: id)\\n    }\\n    doc[\\"friendsMap\\"].set(dict)\\n}\\n\\n","upsert":"do {\\n    // upsert JSON-compatible data into Ditto\\n    let docID = try ditto.store[\\"people\\"].upsert([\\n        \\"name\\": \\"Susan\\",\\n        \\"age\\": 31\\n    ])\\n} catch {\\n    //handle error\\n    print(error)\\n}\\n\\n","upsert-id":"do {\\n    // upsert JSON-compatible data into Ditto\\n    let docID = try ditto.store[\\"people\\"].upsert([\\n        \\"_id\\": \\"abc123\\",\\n        \\"name\\": \\"Susan\\",\\n        \\"age\\": 31\\n    ])\\n    XCTAssertEqual(docID, \\"abc123\\")\\n} catch {\\n    //handle error\\n    print(error)\\n}\\n\\n","query-basic":"let collection = ditto.store[\\"people\\"]\\n    .find(\\"favoriteBook.title == \'The Great Gatsby\'\\")\\n    .exec()\\n\\n","query-args":"let documents = ditto.store[\\"users\\"].find(\\"name == $args.name && age <= $args.age\\", args: [\\n    \\"age\\": 32,\\n    \\"name\\": \\"Max\\"\\n]).exec()\\n\\n","query-sort":"let sortedRedCars = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .sort(\\"miles\\", direction: .ascending)\\n    .exec()\\n\\n","query-limit":"let sortedAndLimitedRedCars = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .sort(\\"miles\\", direction: .ascending)\\n    .limit(100)\\n    .exec()\\n\\n","sync-observe-local":"// --- Action somewhere in your application\\nfunc userDidInsertCar() {\\n    _ = try? ditto.store.collection(\\"cars\\").upsert([\\n        \\"model\\": \\"Ford\\",\\n        \\"color\\": \\"black\\"\\n    ] as [String: Any?])\\n}\\n\\n// Register live query to update UI\\nlet liveQuery = ditto.store.collection(\\"cars\\").find(\\"color == \'red\'\\")\\n    .observeLocal { cars, event in\\n        // do something\\n    }\\n\\n","sync-observe":"// Register live query to update UI\\nlet example = ditto.store.collection(\\"cars\\").find(\\"color == \'red\'\\")\\n   .observeLocal { cars, event in\\n     // do something\\n}\\n\\n","subscribe":"// Register live query to update UI\\nlet subscription = ditto.store.collection(\\"cars\\").find(\\"color == \'red\'\\").subscribe()\\n\\n","network-remote-ditto":"var config = DittoTransportConfig()\\n// Connect explicitly to a remote devices\\nconfig.connect.tcpServers.insert(\\"135.1.5.5:12345\\")\\nconfig.connect.tcpServers.insert(\\"185.1.5.5:12345\\")\\n\\nditto.transportConfig = config\\n\\ndo {\\n  try ditto.startSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","device-name":"ditto.deviceName = \\"Susan B.\\"\\nlet observer = ditto.presence.observe { presence in\\n    if !presence.remotePeers.isEmpty {\\n        // render peers\\n    }\\n}\\n\\ndo {\\n  try ditto.startSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","transport-sync-groups":"struct User {\\n    var id: String\\n    var restaurantID: UInt32\\n}\\nlet authenticatedUser = User(id: \\"abc123\\", restaurantID: 323234)\\n\\nvar config = DittoTransportConfig()\\n// 1. Enable All Peer to Peer Connections \\nconfig.enableAllPeerToPeer()\\n// 2. Set sync group to an integer between 0 and 2^32\\nconfig.global.syncGroup = authenticatedUser.restaurantID\\nditto.transportConfig = config\\n\\ndo {\\n  try ditto.startSync()\\n} catch (let error) {\\n  print(error.localizedDescription)\\n}\\n\\n","network-listen":"var config = DittoTransportConfig()\\n\\n// Listen for incoming connections on port 4000\\nconfig.listen.tcp.isEnabled = true\\nconfig.listen.tcp.interfaceIP = \\"0.0.0.0\\"\\nconfig.listen.tcp.port = 4000\\n\\nditto.transportConfig = config\\n\\ndo {\\n  try ditto.startSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","transport-configurations":"// Create a new DittoTransportConfig()\\nvar config = DittoTransportConfig()\\n\\n//Enable all peer to peer transports\\nconfig.enableAllPeerToPeer()\\n\\n//Or enable/disable each transport separately\\n//BluetoothLe\\nconfig.peerToPeer.bluetoothLE.isEnabled = true\\n//Local Area Network\\nconfig.peerToPeer.lan.isEnabled = true\\n//Awdl\\nconfig.peerToPeer.awdl.isEnabled = true\\n\\nditto.transportConfig = config\\n\\ndo {\\n  try ditto.startSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","network-multiple-transports":"var config = DittoTransportConfig()\\n// 1. Enable All Peer to Peer Connections\\nconfig.enableAllPeerToPeer()\\n\\n// 2. Listen for incoming connections on port 4000\\nconfig.listen.tcp.isEnabled = true\\nconfig.listen.tcp.interfaceIP = \\"0.0.0.0\\"\\nconfig.listen.tcp.port = 4000\\n\\n// 3. Connect explicitly to remote devices\\nconfig.connect.tcpServers.insert(\\"135.1.5.5:12345\\")\\nconfig.connect.tcpServers.insert(\\"185.1.5.5:12345\\")\\n\\nditto.transportConfig = config\\n\\ndo {\\n  try ditto.startSync()\\n} catch (let err) {\\n  print(err.localizedDescription)\\n}\\n\\n","network-monitor-conditions":"// Setting up inside a ViewController\\nlet ditto = Ditto(identity: DittoIdentity.onlinePlayground(appID: \\"00000000-0000-4000-0000-000000000000\\", token: \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\"))\\nditto.delegate = self\\ntry! ditto.startSync()\\n\\n// Now you can observe real time changes to the transport conditions:\\nextension ViewController: DittoDelegate {\\n   func transportConditionDidChange(transportID: Int64, condition: TransportCondition) {\\n       if condition == .BleDisabled {\\n           print(\\"BLE disabled\\")\\n       } else if condition == .NoBleCentralPermission {\\n           print(\\"Permission missing for BLE\\")\\n       } else if condition == .NoBlePeripheralPermission {\\n           print(\\"Permission missing for BLE\\")\\n       }\\n   }\\n\\n\\n","bus-peers-first-user":"// Get the DittoAddress from the first user in the peer object\\nlet observer = ditto.presence.observe { presence in\\n    if !presence.remotePeers.isEmpty {\\n        let user2PeerAddress = presence.remotePeers[0].address\\n    }\\n}\\nobserver.stop()\\n\\n","bus-single-message-receive":"// User2 sets up a delegate to handle inbound requests\\nlet delegate = SingleMessageReceivedDelegate()\\nditto.bus?.delegate = delegate\\n\\nclass SingleMessageReceivedDelegate: DittoBusDelegate {\\n    var receivedMessage: Data?\\n\\n    func dittoBus(_ bus: DittoBus, didReceiveSingleMessage message: DittoBusMessage) {\\n        self.receivedMessage = message.data\\n    }\\n\\n    func dittoBus(_ bus: DittoBus, didReceiveIncomingStream busStream: DittoBusStream, fromPeer peer: DittoAddress) {\\n        // not implemented\\n    }\\n}\\n\\n","bus-reliable-single-message-send":"// User1 sends data to User2. Success provides guarantee of data delivery.\\nlet data = Data([1, 2, 3, 4, 5])\\nditto.bus?.sendSingleReliableMessage(data, to: user2PeerAddress, completion: { error in\\n    if let error {\\n        // success\\n    }\\n})\\n\\n","bus-unreliable-single-message-send":"// User1 sends data to User2. Success provides guarantee of data sent.\\nlet data = Data([1, 2, 3, 4, 5])\\nditto.bus?.sendSingleUnreliableMessage(data, to: user2PeerAddress, completion: { error in\\n    if let error {\\n        // success\\n    }\\n})\\n\\n","bus-bidirectional-stream-common":"// Common Classes\\n\\n// Handles new stream requests\\nclass IncomingStreamReceivedDelegate: DittoBusDelegate {\\n    var connectedStream: DittoBusStream?\\n    var streamDelegate: DittoBusStreamDelegate?\\n\\n    func dittoBus(_ bus: DittoBus, didReceiveSingleMessage message: DittoBusMessage) {\\n        // Not implemented\\n    }\\n\\n    func dittoBus(_ bus: DittoBus, didReceiveIncomingStream busStream: DittoBusStream, fromPeer peer: DittoAddress) {\\n        self.connectedStream = busStream\\n        busStream.delegate = self.streamDelegate\\n    }\\n}\\n\\n/// Handles operations/messages on a connected stream\\nclass StreamDelegate: DittoBusStreamDelegate {\\n    /// A new message has been received from the specified stream.\\n    func dittoBusStream(_ busStream: DittoBusStream, didReceiveMessage message: Data) {\\n        // handle message received\\n    }\\n\\n    /// The stream has closed. This can be triggered by calling close() or by the remote peer doing the same.\\n    func dittoBusStream(_ busStream: DittoBusStream, didClose error: DittoSwiftError) {\\n        // handle connection closed\\n    }\\n\\n    // The operation to enqueue outgoing data on a stream has completed. More data may now be enqueued.\\n    // The message sequence number may be used to track when the remote side has fully acknowledged receipt.\\n    // `error` will be non-nil if the operation failed.\\n    func dittoBusStream(_ busStream: DittoBusStream, didEnqueueDataWithMessageSequence messageSequence: UInt64, error: DittoSwiftError?) {\\n        // handle did enqueue data\\n    }\\n\\n    // The remote peer has acknowledged receipt of all messages up to the given sequence number.\\n    func dittoBusStream(_ busStream: DittoBusStream, didAcknowledgeReceipt messageSequence: UInt64) {\\n        // handle did data was received\\n    }\\n}\\n\\n","bus-bidirectional-stream-handler":"// User2 - Create a delegate to handle inbound stream requests\\nlet incomingDelegate = IncomingStreamReceivedDelegate()\\n// Attach a StreamDelegate to handle messages once a connection is established\\nincomingDelegate.streamDelegate = StreamDelegate()\\nditto.bus?.delegate = incomingDelegate\\n\\n// Send a message\\nlet data = Data([1, 2, 3, 4, 5])\\nincomingDelegate.connectedStream?.enqueueMessage(data: data)\\n\\n// Close the stream\\nincomingDelegate.connectedStream?.close()\\n\\n","bus-reliable-bidirectional-stream-sender":"// User1 - Reliable Bidirectional Stream\\n\\nlet incomingDelegate = IncomingStreamReceivedDelegate()\\nditto.bus?.delegate = incomingDelegate\\n\\nlet streamDelegate = StreamDelegate()\\nvar user1Stream: DittoBusStream?\\nditto1.bus?.openStream(toAddress: user2PeerAddress, reliability: .reliable) { stream, err in\\n    user1Stream = stream\\n    stream?.delegate = streamDelegate\\n}\\n\\n// Send Message\\nlet data = Data([1, 2, 3, 4, 5])\\nuser1Stream?.enqueueMessage(data: data)\\n\\n// An ID unique to the local device that can be used to track this individual stream.\\n_ = user1Stream?.id\\n\\n// close\\nuser1Stream?.close()\\n\\n","bus-unreliable-bidirectional-stream-sender":"// User1 - Unreliable Bidirectional Stream\\nlet incomingDelegate = IncomingStreamReceivedDelegate()\\nditto.bus?.delegate = incomingDelegate\\n\\nlet streamDelegate = StreamDelegate()\\nvar user1Stream: DittoBusStream?\\nditto1.bus?.openStream(toAddress: user2PeerAddress, reliability: .unreliable) { stream, err in\\n    user1Stream = stream\\n    stream?.delegate = streamDelegate\\n}\\n\\n// Send Message\\nlet data = Data([1, 2, 3, 4, 5])\\nuser1Stream?.enqueueMessage(data: data)\\n\\n// An ID unique to the local device that can be used to track this individual stream.\\n_ = user1Stream?.id\\n\\n// close\\nuser1Stream?.close()\\n\\n","network-query-overlap-group":"// The passenger only observes orders that they created\\nlet passengerQuery = passenger.store.collection(\\"orders\\").find(\\"user_id==abc123\\")\\nlet passengerSubscription = passengerQuery.subscribe()\\nlet passengerLiveQuery = passengerQuery.observeLocal { docs, event in\\n  // render passenger orders in a list UI\\n}\\n\\n// Crew member devices observe all orders that everyone created\\nlet crewAQuery = crewA.store.collection(\\"orders\\").findAll()\\nlet crewASubscription = crewAQuery.subscribe()\\nlet crewALiveQuery = crewAQuery.observeLocal { docs, event in\\n  // render all orders in a list UI\\n}\\nlet crewBQuery = crewB.store.collection(\\"orders\\").findAll()\\nlet crewBSubscription = crewBQuery.subscribe()\\nlet crewBLiveQuery = crewBQuery.observeLocal { docs, event in\\n  // render all orders in a list UI\\n}\\n\\n// Set up our query overlap group and priorities such that the crew members\\n// will construct multihop connections with each other.\\nDittoExperimental.setQueryOverlapGroup(queryOverlapGroup: 2, ditto: crewA)\\nDittoExperimental.setQueryOverlapGroup(queryOverlapGroup: 2, ditto: crewB)\\n\\n// Query overlap groups should be set before startSync\\ntry! passenger.startSync()\\ntry! crewA.startSync()\\ntry! crewB.startSync()\\n\\n","network-set-priority":"DittoExperimental.setPriority(DittoConnectionPriority.high, forQueryOverlapGroup: 2, ditto: crewA)\\nDittoExperimental.setPriority(DittoConnectionPriority.high, forQueryOverlapGroup: 2, ditto: crewB)\\n\\n","evict":"collection.find(\\"owner == \'Bob\'\\").evict()\\n\\n","remove-query":"collection.find(\\"owner == \'Bob\'\\").remove()\\n\\n","remove-id":"collection.findByID(docID).remove()\\n\\n","sync-basic":"try! ditto.startSync()\\n\\n"},"cpp":{"sync-observe-local":"// --- Register live query to update UI\\nstd::shared_ptr<LiveQuery> query =\\n    collection.find(\\"color == \'red\'\\")\\n        .observe_local([&](std::vector<Document> docs, LiveQueryEvent event) {\\n\\n        });\\n\\n","datamodel":"Collection cars_collection = ditto.get_store().collection(\\"cars\\");\\n\\n","upsert-id":"json person = json({{\\"_id\\", \\"123abc\\"}, {\\"name\\", \\"Susan\\"}, {\\"age\\", 31}});\\nDocumentId doc_id = ditto.get_store().collection(\\"people\\").upsert(person);\\n\\n","upsert":"json person = json({{\\"name\\", \\"Susan\\"}, {\\"age\\", 31}});\\nDocumentId doc_id = ditto.get_store().collection(\\"people\\").upsert(person);\\n\\n","upsert-composite-primary-key":"json content = json({{\\"_id\\", {{\\"userId\\", \\"456abc\\"}, {\\"workId\\", 789}}},\\n                     {\\"name\\", \\"Susan\\"},\\n                     {\\"age\\", 31}});\\nDocumentId doc_ID = ditto.get_store().collection(\\"people\\").upsert(content);\\n\\n","upsert-datatypes":"// Insert JSON-compatible data into Ditto\\nditto.get_store().collection(\\"foo\\").upsert(json({{\\"boolean\\", true},\\n                                                 {\\"string\\", \\"Hello World\\"},\\n                                                 {\\"number\\", 10},\\n                                                 {\\"map\\", {{\\"key\\", \\"value\\"}}},\\n                                                 {\\"array\\", {1, 2, 3}},\\n                                                 {\\"null\\", NULL}}));\\n\\n","write-transaction":"auto results = ditto.get_store().write([&](WriteTransaction &write_txn) {\\n  ScopedWriteTransaction people = write_txn.scoped(\\"people\\");\\n  ScopedWriteTransaction cars = write_txn.scoped(\\"cars\\");\\n  auto docId = \\"abc123\\";\\n  people.upsert({{\\"name\\", \\"Susan\\"}, {\\"_id\\", DocumentId(docId)}});\\n  cars.upsert({{\\"make\\", \\"Hyundai\\"}, {\\"owner\\", DocumentId(docId)}});\\n  cars.upsert({{\\"make\\", \\"Toyota\\"}, {\\"owner\\", DocumentId(docId)}});\\n});\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared\\n// key for every application.\\nconst std::string p256_der_b64 =\\n    \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4\\"\\n    \\"hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlq\\"\\n    \\"nfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nDitto ditto = ditto::Ditto(Identity::SharedKey(\\"\\", p256_der_b64), path);\\nditto.set_offline_only_license_token(valid_license);\\n\\n","attachment":"auto attachment_file_path = fs::path(images_path.string() + \\"/image.png\\");\\nstd::map<std::string, std::string> metadata = {{\\"some\\", \\"string\\"}};\\n\\nAttachment attachment =\\n    collection.new_attachment(attachment_file_path.string(), metadata);\\n\\nauto doc_id =\\n    collection.upsert({{\\"some\\", \\"string\\"}, {\\"my_attachment\\", attachment}});\\n\\n// Later, find the document and the fetch the attachment\\nauto doc = collection.find_by_id(doc_id).exec();\\nauto att_token = (*doc)[\\"my_attachment\\"].get_attachment_token();\\n\\nauto fetcher = collection.fetch_attachment(\\n    att_token,\\n    AttachmentFetcherEventHandler{\\n        [&](std::unique_ptr<AttachmentFetchEvent> event) {\\n          switch (event->type) {\\n          case AttachmentFetchEventType::Completed: {\\n            AttachmentFetchEventCompleted *completed_event =\\n                static_cast<AttachmentFetchEventCompleted *>(event.get());\\n            Attachment fetched_attachment = completed_event->attachment;\\n            // Do something with attachment\\n            break;\\n          }\\n          default:\\n            std::cout << \\"Unable to fetch attachment\\" << std::endl;\\n          }\\n        }});\\n\\n","array-to-map":"ditto.get_store().collection(\\"people\\").find_by_id(docID).update(\\n    [](MutableDocument &doc) {\\n      auto friendsMap = json::object();\\n      auto array = doc[\\"friends\\"].get_json();\\n      for (size_t i = 0; i < array.size(); i++) {\\n        auto name = array[i];\\n        friendsMap[\\"my_id\\"] = json({{\\"name\\", name}, {\\"id\\", \\"my_id\\"}});\\n      };\\n      doc[\\"friendsMap\\"].set(friendsMap);\\n    });\\n\\n","counter":"DocumentId docID = ditto.get_store().collection(\\"people\\").upsert(\\n    {{\\"name\\", \\"Frank\\"}, {\\"ownedCars\\", Counter()}});\\n\\nditto.get_store().collection(\\"people\\").find_by_id(docID).update(\\n    [](MutableDocument &doc) {\\n      auto counter = doc[\\"ownedCars\\"].get_counter();\\n      counter->increment(1);\\n    });\\n\\n","update":"DocumentId doc_id = ditto.get_store().collection(\\"people\\").upsert(\\n    {{\\"name\\", \\"Frank\\"}, {\\"age\\", 31}, {\\"ownedCars\\", Counter()}});\\n\\nditto.get_store().collection(\\"people\\").find_by_id(doc_id).update(\\n    [](MutableDocument &doc) {\\n      doc[\\"age\\"].set(32);\\n      auto counter = doc[\\"ownedCars\\"].get_counter();\\n      counter->increment(1);\\n    });\\n\\n","remove-id":"ditto.get_store().collection(\\"people\\").find_by_id(doc_id).remove();\\n\\n","remove-query":"ditto.get_store().collection(\\"people\\").find(\\"age <= 32\\").remove();\\n\\n","evict":"ditto.get_store().collection(\\"people\\").find(\\"age <= 32\\").evict();\\n\\n","upsert-default-data":"DocumentId doc_id = ditto.get_store().collection(\\"people\\").upsert(\\n    content, WriteStrategy::insertDefaultIfAbsent);\\n\\n","query-basic":"std::vector<Document> results =\\n    ditto.get_store()\\n        .collection(\\"people\\")\\n        .find(\\"favoriteBook.title == \'The Great Gatsby\'\\")\\n        .exec();\\n\\n","query-args":"json args = json({{\\"age\\", 32}, {\\"name\\", \\"max\\"}});\\nstd::vector<Document> big_c_values =\\n    ditto.get_store()\\n        .collection(\\"people\\")\\n        .find(\\"name == $args.name && age <= $args.age\\", args)\\n        .exec();\\n\\n","query-sort":"std::vector<Document> sorted_red_cars =\\n    ditto.get_store()\\n        .collection(\\"cars\\")\\n        .find(\\"color == \'red\'\\")\\n        .sort(\\"miles\\", SortDirection::ascending)\\n        .exec();\\n\\n","query-limit":"std::vector<Document> sorted_and_limited_red_cars =\\n    ditto.get_store()\\n        .collection(\\"cars\\")\\n        .find(\\"color == \'red\'\\")\\n        .sort(\\"miles\\", SortDirection::ascending)\\n        .limit(100)\\n        .exec();\\n\\n","sync-basic":"try {\\n  ditto.start_sync();\\n} catch (const DittoError &err) {\\n  std::cerr << err.what();\\n}\\n\\n","subscribe":"std::shared_ptr<ditto::Subscription> subscription =\\n    collection.find(\\"color == \'red\'\\").subscribe();\\n\\n","sync-observe":"std::shared_ptr<LiveQuery> liveQuery =\\n    collection.find(\\"color == \'red\'\\")\\n        .observe_local([&](std::vector<Document> docs, LiveQueryEvent event) {\\n          // do something\\n        });\\n\\n","online-playground":"auto identity =\\n    Identity::OnlinePlayground(\\"00000000-0000-4000-0000-000000000000\\",\\n                               \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\", true);\\ntry {\\n  Ditto ditto = Ditto(identity, dir);\\n  ditto.set_minimum_log_level(LogLevel::debug);\\n  ditto.start_sync();\\n} catch (const DittoError &err) {\\n}\\n\\n","offline-playground":"auto identity =\\n    Identity::OfflinePlayground(\\"00000000-0000-4000-0000-000000000000\\", 1234);\\ntry {\\n  Ditto ditto = Ditto(identity, dir);\\n\\n  ditto.set_offline_only_license_token(valid_license);\\n  ditto.start_sync();\\n} catch (const DittoError &err) {\\n}\\n\\n","network-remote-ditto":"auto config = ditto::TransportConfig();\\n// Connect explicitly to remote devices\\nconfig.connect.tcp_servers.insert(\\"135.1.5.5:12345\\");\\nconfig.connect.tcp_servers.insert(\\"185.1.5.5:12345\\");\\n\\n// set the transport config\\nditto.set_transport_config(config);\\n// now you can start ditto\'s sync\\nditto.start_sync();\\n\\n","transport-sync-groups":"auto config = ditto::TransportConfig();\\n\\nconfig.enable_all_peer_to_peer();\\nconfig.global.sync_group = 1234;\\n\\n// set the transport config\\nditto.set_transport_config(config);\\n// now you can start ditto\'s sync\\nditto.start_sync();\\n\\n","network-listen":"auto config = ditto::TransportConfig();\\n\\nconfig.listen.tcp.enabled = true;\\nconfig.listen.http.enabled = false;\\nconfig.listen.tcp.interface_ip = \\"0.0.0.0\\";\\nconfig.listen.tcp.port = 4000;\\n\\nditto.set_transport_config(config);\\nditto.start_sync();\\n\\n","network-multiple-transports":"auto config = ditto::TransportConfig();\\n// 1. Enable All Peer to Peer Connections\\nconfig.enable_all_peer_to_peer();\\n\\n// 2. Listen for incoming connections on port 4000\\nconfig.listen.tcp.enabled = true;\\nconfig.listen.http.enabled = false;\\nconfig.listen.tcp.interface_ip = \\"0.0.0.0\\";\\nconfig.listen.tcp.port = 4000;\\n\\n// 3. Connect explicitly to remote devices\\nconfig.connect.tcp_servers.insert(\\"135.1.5.5:12345\\");\\nconfig.connect.tcp_servers.insert(\\"185.1.5.5:12345\\");\\n\\nditto.set_transport_config(config);\\nditto.start_sync();\\n\\n"},"http":{"upsert-composite-primary-key":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v3/store/write\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n      [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"id\\": { \\n          \\"user_id\\": \\"456abc\\",\\n          \\"work_id\\": 789\\n        },\\n        \\"value\\": {\\n          \\"name\\": \\"Susan\\", \\n          \\"age\\": 31\\n        }\\n      }]\\n  }\'\\n\\n","upsert":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v3/store/write\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n      \\"commands\\": [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"id\\": \\"abc123\\",\\n        \\"value\\": {\\n          \\"name\\": \\"Susan\\", \\"age\\": 31\\n        }\\n      }]\\n  }\'\\n\\n","upsert-id":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v3/store/write\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n      \\"commands\\": [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"id\\": \\"456abc\\",\\n        \\"value\\": {\\n          \\"name\\": \\"Susan\\", \\n          \\"age\\": 31\\n        }\\n      }]\\n  }\'\\n\\n","upsert-datatypes":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v3/store/write\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n      \\"commands\\": [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"id\\": \\"456abc\\",\\n        \\"value\\": {\\n          \\"boolean\\": true, \\n          \\"string\\": \\"Hello World\\",\\n          \\"number\\": 10,\\n          \\"map\\": {\\n            \\"key\\": \\"value\\",\\n          },\\n          \\"array\\": [1,2,3],\\n          \\"null\\": null\\n        }\\n      }]\\n  }\'\\n\\n","update":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v3/store/write\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n      \\"commands\\": [{\\n        \\"method\\": \\"upsert\\",\\n        \\"collection\\": \\"people\\",\\n        \\"id\\": \\"123abc\\",\\n        \\"value\\": {\\n          \\"name\\": \\"Frank\\", \\n          \\"age\\": 32,\\n          \\"friends\\": [\\"Susan\\"],\\n          \\"owned_cars\\": 0\\n        }\\n      }]\\n  }\'\\n\\n","query-basic":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v3/store/find\' \\\\\\n--header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n--header \'Content-Type: application/json\' \\\\\\n--data-raw \'{\\n    \\"collection\\": \\"people\\",\\n    \\"query\\": \\"favoriteBook.title == \'The Great Gatsby\'\\"\\n  }\'\\n\\n","query-args":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v3/store/find\' \\\\\\n--header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n--header \'Content-Type: application/json\' \\\\\\n--data-raw \'{\\n    \\"args\\": {\\n      \\"name\\": \\"max\\",\\n      \\"age\\": 32\\n    },\\n    \\"collection\\": \\"people\\",\\n    \\"query\\": \\"name == $args.name && age <= $args.age\\"\\n  }\'\\n\\n","query-limit":"curl -X POST \'https://<CLOUD_ENDPOINT>/api/v3/store/find\' \\\\\\n  --header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n  --header \'Content-Type: application/json\' \\\\\\n  --data-raw \'{\\n    \\"collection\\": \\"people\\",\\n    \\"query\\": \\"color == \'red\'\\",\\n    \\"limit\\": 100\\n  }\'\\n\\n","remove-id":"curl --location --request POST \'https://<CLOUD_ENDPOINT>/api/v3/store/write\' \\\\\\n--header \'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==\' \\\\\\n--header \'Content-Type: application/json\' \\\\\\n--data-raw \'{\\n      \\"commands\\": [{\\n        \\"method\\": \\"remove\\",\\n        \\"collection\\": \\"orders\\",\\n        \\"query\\": \\"_id == \'<ID>\'\\"\\n      }]\\n  }\'\\n\\n"},"javascript":{"online-playground":"import { init, Ditto, Logger } from \\"@dittolive/ditto\\"\\nconst identity: Identity = { type: \'onlinePlayground\', appID: \'00000000-0000-4000-0000-000000000000\', token: \'REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\' }\\nconst ditto = new Ditto(identity, path)\\nditto.startSync()\\n\\n","online-playground-cloudSync":"const identity: Identity = {\\n  type: \'onlinePlayground\',\\n  appID: \'00000000-0000-4000-0000-000000000000\',\\n  token: \'REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\',\\n  // Set to false to disable syncing with the cloud\\n  enableDittoCloudSync: true,\\n}\\nconst ditto = new Ditto(identity, path)\\nditto.startSync()\\n\\n","offline-playground":"const identity: Identity = { type: \'offlinePlayground\', appID: \'00000000-0000-4000-0000-000000000000\' }\\nconst ditto = new Ditto(identity, path)\\nditto.setOfflineOnlyLicenseToken(validLicense)\\nditto.startSync()\\n\\n","datamodel":"const carsCollection = ditto.store.collection(\'cars\')\\n\\n","upsert-id":"const docID = await ditto.store.collection(\'people\').upsert({\\n  _id: \'123abc\',\\n  name: \'Susan\',\\n  age: 31,\\n})\\n\\nconsole.log(docID) // \\"123abc\\"\\n\\n","write-transaction":"const results = await ditto.store.write(async (transaction) => {\\n  // Use the `WriteTransaction` object that is available in the\\n  // transaction closure to acquire a handle to any collection, which\\n  // allows modifying and accessing its documents in the transaction\\n  // context.\\n  const cars = transaction.scoped(\'cars\')\\n  const people = transaction.scoped(\'people\')\\n\\n  // In this example a new person and car document are created, and\\n  // finally the person document that was just created is evicted.\\n  // If any of these operations fail, all others are not applied.\\n  const susanId = await people.upsert({\\n    name: \'Susan\',\\n  })\\n  await cars.upsert({\\n    make: \'Hyundai\',\\n    color: \'red\',\\n    owner: susanId,\\n  })\\n  await people.findByID(susanId).evict()\\n})\\n\\n// The return value of a transaction is a list that contains a\\n// summary of all operations in the transaction and the document IDs\\n// that were affected:\\n\\n// results == [\\n//   {\\n//     type: \'inserted\',\\n//     docID: DocumentID { ... },\\n//     collectionName: \'people\'\\n//   },\\n//   {\\n//     type: \'inserted\',\\n//     docID: DocumentID { ... },\\n//     collectionName: \'cars\'\\n//   },\\n//   {\\n//     type: \'evicted\',\\n//     docID: DocumentID { ... },\\n//     collectionName: \'people\'\\n//   }\\n// ]\\n\\n","upsert":"const docID = await ditto.store.collection(\'people\').upsert({\\n  name: \'Susan\',\\n  age: 31,\\n})\\nconsole.log(docID) // \\"507f191e810c19729de860ea\\"\\n\\n","upsert-datatypes":"// Insert JSON-compatible data into Ditto\\nawait ditto.store.collection(\'people\').upsert({\\n  boolean: true,\\n  string: \'Hello World\',\\n  number: 10,\\n  map: { key: \'value\' },\\n  array: [],\\n  null: null,\\n})\\n\\n","counter":"const frankId = await ditto.store.collection(\'people\').upsert({\\n  name: \'Frank\',\\n  ownedCars: 0, // here 0 is a number\\n})\\n\\nawait ditto.store\\n  .collection(\'people\')\\n  .findByID(frankId)\\n  .update((mutableDoc) => {\\n    mutableDoc.at(\'ownedCars\').set(new Counter())\\n    mutableDoc.at(\'ownedCars\').counter.increment(1)\\n  })\\n\\n","upsert-default-data":"const docID = await ditto.store.collection(\'people\').upsert(\\n  {\\n    name: \'Susan\',\\n    age: 31,\\n  },\\n  { writeStrategy: \'insertDefaultIfAbsent\' },\\n)\\n\\n","upsert-composite-primary-key":"const docID = await ditto.store.collection(\'people\').upsert({\\n  _id: { userID: \'456abc\', workID: 789 },\\n  name: \'Susan\',\\n  age: 31,\\n})\\nconsole.log(docID) // \\"{ \\"userID\\": \\"456abc\\", \\"workID\\": 789 }\\"\\n\\n","update":"const docID = await ditto.store.collection(\'people\').upsert({\\n  name: \'Frank\',\\n  age: 31,\\n  ownedCars: 0,\\n})\\n\\nawait ditto.store\\n  .collection(\'people\')\\n  .findByID(docID)\\n  .update((mutableDoc) => {\\n    mutableDoc.at(\'age\').set(32)\\n\\n    mutableDoc.at(\'ownedCars\').set(new Counter())\\n    mutableDoc.at(\'ownedCars\').counter.increment(1)\\n  })\\n\\n","array-to-map":"await collection.findByID(docID).update((mutableDoc) => {\\n  const map = {}\\n  const array = mutableDoc.at(\'friends\').value\\n  array.forEach((name) => {\\n    const id = getUUID()\\n    map[id] = { id, name }\\n  })\\n  mutableDoc.at(\'friendsMap\').set(map)\\n})\\n\\n","query-basic":"const collection = await ditto.store.collection(\'people\').find(\\"favoriteBook.title == \'The Great Gatsby\'\\")\\n\\n","remove-id":"await ditto.store.collection(\'people\').findByID(docID).remove()\\n\\n","query-args":"const query = \'name == $args.name && age <= $args.age\'\\nconst documents = await ditto.store.collection(\'people\').find(query, {\\n  age: 32,\\n  name: \'Max\',\\n})\\n\\n","remove-query":"await ditto.store.collection(\'people\').find(\'age <= 32\').remove()\\n\\n","query-sort":"const sortedRedCars = await ditto.store.collection(\'cars\').find(\\"color == \'red\'\\").sort(\'miles\', \'ascending\')\\n\\n","query-limit":"const sortedAndLimitedRedCars = await ditto.store.collection(\'cars\').find(\\"color == \'red\'\\").sort(\'miles\', \'ascending\').limit(100)\\n\\n","evict":"await ditto.store.collection(\'people\').find(\'age <= 32\').evict()\\n\\n","sync-basic":"try {\\n  ditto.startSync()\\n} catch (err) {\\n  console.error(err)\\n}\\n\\n","sync-observe":"const liveQuery = ditto.store\\n  .collection(\'cars\')\\n  .find(\\"color == \'red\'\\")\\n  .observeLocal((cars, event) => {\\n    // do something\\n  })\\n\\n","subscribe":"const subscription = ditto.store.collection(\'cars\').find(\\"color == \'red\'\\").subscribe()\\n\\n","sync-observe-local":"const liveQuery = ditto.store\\n  .collection(\'cars\')\\n  .find(\\"color == \'red\'\\")\\n  .observeLocal((cars, event) => {\\n    // do something\\n  })\\n\\n","attachment":"const collection = ditto.store.collection(\'foo\')\\n\\nconst myImageBase64 = \'iVBORw0KGgoAAAANSUhEUgAAAQAAAAEAAQMAAABmvDolAAAAA1BMVEW10NBjBBbqAAAAH0lEQVRoge3BAQ0AAADCoPdPbQ43oAAAAAAAAAAAvg0hAAABmmDh1QAAAABJRU5ErkJggg==\'\\nconst myImageBytes = Uint8Array.from(myImageBase64, (character) => character.charCodeAt(0))\\nconst metadata = { name: \'image.png\' }\\n\\n// On Node, you can also pass a file path (string) instead of image data\\n// and the attachment will be created from that file.\\nconst attachment = await collection.newAttachment(myImageBytes, metadata)\\n\\nconst docID = await collection.upsert({ some: \'string\', my_attachment: attachment })\\n\\n// Later, find the document and then fetch the attachment\\n\\nconst doc = await collection.findByID(docID)\\nconst attachmentToken = doc.at(\'my_attachment\').attachmentToken\\n\\nconst attachmentFetcher = collection.fetchAttachment(attachmentToken, async (attachmentFetchEvent) => {\\n  switch (attachmentFetchEvent.type) {\\n    case \'Completed\':\\n      const fetchedAttachment = attachmentFetchEvent.attachment\\n      // Do something with attachment\\n      break\\n\\n    default:\\n      console.log(\'Unable to fetch attachment\')\\n      break\\n  }\\n})\\n\\n// There is also a more convenient way of fetching the attachment\\n// (AttachmentFetcher implements the `PromiseLike` protocol):\\nconst fetchedAttachment = await collection.fetchAttachment(attachmentToken)\\n// Do something with attachment\\n\\n","network-remote-ditto":"import { TransportConfig } from \'@dittolive/ditto\'\\n\\nconst config = new TransportConfig()\\nconfig.connect.websocketURLs.push(\'wss://135.1.5.5:12345\')\\nconfig.connect.websocketURLs.push(\'wss://185.1.5.5:12345\')\\nditto.setTransportConfig(config)\\nditto.startSync()\\n\\n\\n","network-monitor-conditions":"const transportConditionsObserver = ditto.observeTransportConditions((condition, source) => {\\n  if (condition === \'BLEDisabled\') {\\n    console.log(\'BLE disabled\')\\n  } else if (condition === \'NoBLECentralPermission\') {\\n    console.log(\'Permission missing for BLE\')\\n  } else if (condition === \'NoBLEPeripheralPermission\') {\\n    console.log(\'Permissions missing for BLE\')\\n  }\\n})\\n\\n","transport-sync-groups":"import { TransportConfig } from \'@dittolive/ditto\'\\n\\nconst config = new TransportConfig()\\n// 1. Enable All Peer to Peer Connections (not in a browser environment)\\nconfig.setAllPeerToPeerEnabled(true)\\n\\n//2. Set sync group to an integer between 0 and 2^32\\nconfig.global.syncGroup = 1234\\n\\n// 3. Connect explicitly to remote devices\\nditto.setTransportConfig(config)\\nditto.startSync()\\n\\n","network-multiple-transports":"import { TransportConfig } from \'@dittolive/ditto\'\\n\\nconst config = new TransportConfig()\\n  // 1. Enable All Peer to Peer Connections (not in a browser environment)\\n  config.setAllPeerToPeerEnabled(true)\\n\\n// 2. Listen for incoming connections on port 4000\\nconfig.listen.tcp.isEnabled = true\\nconfig.listen.tcp.interfaceIP = \'0.0.0.0\'\\nconfig.listen.tcp.port = 4000\\n\\n// 3. Connect explicitly to remote devices\\nditto.setTransportConfig(config)\\nditto.startSync()\\n\\n","transport-configurations":"const config = new TransportConfig()\\n\\n/* eslint-disable */\\n  // Enable all peer to peer transports\\n  config.setAllPeerToPeerEnabled(true)\\n\\n// or enable/disable each transport separately\\n// BluetoothLE\\nconfig.peerToPeer.bluetoothLE.isEnabled = true\\n\\n  // Local Area Network\\n  config.peerToPeer.lan.isEnabled = true\\n\\n  // AWDL\\n  config.peerToPeer.awdl.isEnabled = true\\n/* eslint-enable */\\n\\nditto.setTransportConfig(config)\\nditto.startSync()\\n\\n","websocket-connect":"import { TransportConfig } from \'@dittolive/ditto\'\\n\\nconst config = new TransportConfig()\\nconfig.connect.websocketURLs.push(\'ws://127.0.0.1\')\\nditto.setTransportConfig(config)\\nditto.startSync()\\n\\n","network-listen":"import { TransportConfig } from \'@dittolive/ditto\'\\n\\nconst config = new TransportConfig()\\nconfig.listen.tcp.isEnabled = true\\nconfig.listen.tcp.interfaceIP = \'0.0.0.0\'\\nconfig.listen.tcp.port = 4000\\nditto.setTransportConfig(config)\\nditto.startSync()\\n\\n"},"csharp":{"sync-basic":"try\\n{\\n    onlineDitto.StartSync();\\n}\\ncatch (DittoException ex)\\n{\\n    // handle exception\\n}\\n\\n","remove-query":"ditto.Store.Collection(\\"people\\").Find(\\"age <= 32\\").Remove();\\n\\n","remove-id":"var wasRemoved = coll.FindById(docId).Remove();\\n\\n","counter":"var counter = new DittoCounter();\\n\\nvar docId = coll.Upsert(new Dictionary<string, object> {\\n    { \\"make\\", \\"Honda\\" }, { \\"mileage\\", counter }\\n});\\n\\n_ = coll.FindById(docId).Update(mutableDoc =>\\n{\\n    mutableDoc[\\"mileage\\"].Counter.Increment(100);\\n});\\n\\n","update":"var content = new Dictionary<string, object>\\n{\\n    { \\"name\\", \\"Bob\\" },\\n    { \\"age\\", 40 },\\n    { \\"ownedCars\\",  new DittoCounter() }\\n};\\n\\nvar docId = Ditto.Store.Collection(\\"people\\").Upsert(content);\\nDitto.Store.Collection(\\"people\\").FindById(docId).Update(mutableDoc =>\\n{\\n    mutableDoc[\\"age\\"].Set(32);\\n    mutableDoc[\\"ownedCars\\"].Counter.Increment(1);\\n});\\n\\n","evict":"Ditto.Store.Collection(\\"people\\").Find(\\"age <= 32\\").Evict();\\n\\n","array-to-map":"Ditto.Store.Collection(\\"people\\").FindById(docId).Update(mutableDoc =>\\n{\\n    var friendsMap = new Dictionary<string, object>();\\n\\n    foreach (string name in mutableDoc[\\"friends\\"].ListValue)\\n    {\\n        var friend = new Dictionary<string, object>();\\n        var id = \\"myId\\";\\n        friend[\\"id\\"] = id;\\n        friend[\\"name\\"] = name;\\n        mutableDoc[id].Set(friend);\\n    }\\n    mutableDoc[\\"friendsMap\\"].Set(friendsMap);\\n});\\n\\n","attachment":"string attachmentImagePath = Path.Combine(Directory.GetCurrentDirectory(), \\"attachment_test.png\\");\\n\\nvar originalBytes = File.ReadAllBytes(attachmentImagePath);\\n\\nvar metadata = new Dictionary<string, string> { { \\"name\\", \\"my_image.png\\" } };\\nvar attachment = coll.NewAttachment(attachmentImagePath, metadata);\\n\\nvar docId = coll.Upsert(new Dictionary<string, object> { { \\"some\\", \\"string\\" }, { \\"my_attachment\\", attachment } });\\n\\nvar doc = coll.FindById(docId).Exec();\\nvar attachmentToken = doc[\\"my_attachment\\"].AttachmentToken;\\nusing var fetcher = coll.FetchAttachment(attachmentToken, ev =>\\n{\\n    switch (ev)\\n    {\\n        case DittoAttachmentFetchEvent.Completed e:\\n            // Do something with attachment\\n            break;\\n        default:\\n            Console.WriteLine(\\"Unable to fetch attachment\\");\\n            break;\\n    }\\n});\\n\\n","upsert-composite-primary-key":"// Insert JSON-compatible data into Ditto\\nvar content = new Dictionary<string, object> {\\n    { \\"_id\\", new Dictionary<string, object> {{ \\"userId\\", \\"456abc\\" }, { \\"workId\\", 789 }} },\\n    { \\"name\\", \\"Susan\\" },\\n    { \\"age\\", 31 }\\n};\\nvar docId = ditto.Store.Collection(\\"people\\").Upsert(content);\\n\\n","upsert-default-data":"// Immediately try and insert some new default data\\nvar docId = coll.Upsert(\\n    new Dictionary<string, object> { { \\"name\\", \\"Susan\\" } },\\n    DittoWriteStrategy.InsertDefaultIfAbsent);\\n\\n","datamodel":"var coll = ditto.Store.Collection(\\"people\\");\\n\\n","upsert":"var docId = ditto.Store.Collection(\\"people\\").Upsert(\\n    new Dictionary<string, object> {\\n    { \\"name\\", \\"Susan\\" },\\n    { \\"age\\", 31 },\\n    }\\n);\\n\\n","upsert-id":"var returnedId = ditto.Store.Collection(\\"people\\").Upsert(\\n    new Dictionary<string, object> {\\n        { \\"_id\\", \\"123abc\\" },\\n        { \\"name\\", \\"Joe\\" },\\n        { \\"age\\", 32 },\\n        { \\"isOnline\\", true }\\n    }\\n);\\n\\n","upsert-datatypes":"// Insert JSON-compatible data into Ditto\\nvar content = new Dictionary<string, object>\\n{\\n    { \\"boolean\\", true },\\n    { \\"string\\", \\"Hello World\\" },\\n    { \\"number\\", 10 },\\n    { \\"map\\", new Dictionary<string, string>{{ \\"key\\", \\"value\\"}} },\\n    { \\"array\\", new[] {1, 2, 3} },\\n    { \\"null\\", null }\\n};\\nDitto.Store.Collection(\\"foo\\").Upsert(content);\\n\\n","online-playground-cloudSync":"try\\n{\\n    var ditto = new Ditto(DittoIdentity.OnlinePlayground(\\n        appId: \\"00000000-0000-4000-0000-000000000000\\",\\n        token: \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\",\\n        // Set to false to disable syncing with the cloud\\n        enableDittoCloudSync: true), path);\\n\\n    ditto.StartSync();\\n}\\ncatch (DittoException ex)\\n{\\n    Console.WriteLine($\\"Ditto Error {ex.Message}\\");\\n}\\n\\n","online-playground":"try\\n{\\n    DittoLogger.SetMinimumLogLevel(DittoLogLevel.Debug);\\n    var ditto = new Ditto(DittoIdentity.OnlinePlayground(\\"00000000-0000-4000-0000-000000000000\\", \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\", true), path);\\n    ditto.StartSync();\\n}\\ncatch (DittoException ex)\\n{\\n    Console.WriteLine($\\"Ditto Error {ex.Message}\\");\\n}\\n\\n","offline-playground":"try\\n{\\n    var ditto = new Ditto(DittoIdentity.OfflinePlayground(\\"00000000-0000-4000-0000-000000000000\\", 0), path);\\n    ditto.StartSync();\\n    ditto.SetOfflineOnlyLicenseToken(validLicense);\\n}\\ncatch (DittoException ex)\\n{\\n    Console.WriteLine($\\"Ditto Error {ex.Message}\\");\\n}\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nstring p256DerB64 = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nvar identity = DittoIdentity.SharedKey(\\"app\\", p256DerB64);\\nvar ditto = new Ditto(identity);\\ntry\\n{\\n    ditto.SetOfflineOnlyLicenseToken(validLicense);\\n}\\ncatch (DittoException ex)\\n{\\n    Console.WriteLine($\\"Ditto Error {ex.Message}\\");\\n}\\n\\n","query-basic":"var results = ditto.Store.Collection(\\"people\\")\\n    .Find(\\"favoriteBook.title == \'The Great Gatsby\'\\")\\n    .Exec();\\n\\n","query-args":"var docs = ditto.Store\\n    .Collection(\\"users\\")\\n    .Find(\\n        \\"name == $args.name && age <= $args.age\\",\\n        new Dictionary<string, object> { { \\"name\\", \\"max\\" }, { \\"age\\", 32 } })\\n    .Exec();\\n\\n","query-sort":"var sortedCars = ditto.Store.Collection(\\"cars\\")\\n    .Find(\\"color == \'red\'\\")\\n    .Sort(\\"miles\\", direction: DittoSortDirection.Ascending)\\n    .Exec();\\n\\n","query-limit":"var sortedAndLimitedRedCars = ditto.Store.Collection(\\"cars\\")\\n    .Find(\\"color == \'red\'\\")\\n    .Sort(\\"miles\\", direction: DittoSortDirection.Ascending)\\n    .Limit(100).Exec();\\n\\n","subscribe":"// --- Register live query to update UI\\nvar subscription = ditto.Store.Collection(\\"cars\\").Find(\\"color == \'red\'\\")\\n    .Subscribe();\\n\\n","sync-observe":"// --- Register live query to update UI\\nvar liveQuery = ditto.Store.Collection(\\"cars\\").Find(\\"color == \'red\'\\").ObserveLocal((docs, dittoLiveQueryEvent) =>\\n{\\n    // Do something...\\n});\\n\\n// --- Register live query to update UI\\nvar localLiveQuery = ditto.Store.Collection(\\"cars\\").Find(\\"color == \'red\'\\").ObserveLocal((docs, dittoLiveQueryEvent) =>\\n{\\n    // Do something...\\n});\\n\\n","sync-observe-local":"// --- Register live query to update UI\\nvar localLiveQuery = ditto.Store.Collection(\\"cars\\").Find(\\"color == \'red\'\\")\\n    .ObserveLocal((docs, dittoLiveQueryEvent) =>\\n{\\n    // Do something...\\n});\\n\\n","transport-configurations":"DittoTransportConfig config = new DittoTransportConfig();\\n\\n//Enable all peer to peer transports\\nconfig.EnableAllPeerToPeer();\\n\\n//Or enable/disable each transport separately\\n//BluetoothLe\\nconfig.PeerToPeer.BluetoothLE.Enabled = true;\\nconfig.PeerToPeer.BluetoothLE.Enabled = true;\\n//Local Area Network\\nconfig.PeerToPeer.Lan.Enabled = true;\\n//Awdl\\nconfig.PeerToPeer.Awdl.Enabled = true;\\n\\nDitto.TransportConfig = config;\\n\\nDitto.StartSync();\\n\\n","websocket-connect":"DittoTransportConfig config = new DittoTransportConfig();\\n\\nconfig.Connect.WebsocketUrls.Add(\\"ws://127.0.0.1\\");\\n\\nDitto.TransportConfig = config;\\n\\nDitto.StartSync();\\n\\n","network-remote-ditto":"DittoTransportConfig transportConfig = new DittoTransportConfig();\\n// Connect explicitly to a remote device on\\ntransportConfig.Connect.TcpServers.Add(\\"135.1.5.5:12345\\");\\n// you can add as many TcpServers as you would like.\\ntransportConfig.Connect.TcpServers.Add(\\"185.1.5.5:4567\\");\\n// set the transport config\\nDitto.TransportConfig = transportConfig;\\n// now you can start ditto\'s sync\\nDitto.StartSync();\\n\\n","network-listen":"DittoTransportConfig transportConfig = new DittoTransportConfig();\\ntransportConfig.Listen.Tcp = new DittoTcpListenConfig();\\n// By default Listen.Tcp.Enabled is false, be sure to set it to true.\\ntransportConfig.Listen.Tcp.Enabled = true;\\n// if you want to listen on localhost, most likely you will use 0.0.0.0\\n// do not use \\"localhost\\" as a string\\ntransportConfig.Listen.Tcp.InterfaceIp = \\"0.0.0.0\\";\\n// specify your port.\\ntransportConfig.Listen.Tcp.Port = 4000;\\nDitto.TransportConfig = transportConfig;\\n\\n// now you can call `ditto.StartSync()`\\nDitto.StartSync();\\n\\n","network-multiple-transports":"DittoTransportConfig transportConfig = new DittoTransportConfig();\\n\\n// 1. Enable Local Area Network Connections\\ntransportConfig.EnableAllPeerToPeer();\\n\\n// 2. Listen for incoming connections on port 4000\\ntransportConfig.Listen.Tcp.Enabled = true;\\ntransportConfig.Listen.Tcp.InterfaceIp = \\"0.0.0.0\\";\\ntransportConfig.Listen.Tcp.Port = 4000;\\n\\n// 3. Connect explicitly to remote devices\\ntransportConfig.Connect.TcpServers.Add(\\"135.1.5.5:12345\\");\\ntransportConfig.Connect.TcpServers.Add(\\"185.1.5.5:12345\\");\\n\\nditto.TransportConfig = transportConfig;\\n\\nditto.StartSync();\\n\\n","network-set-priority":"DittoExperimental.SetPriorityForQueryOverlapGroup(DittoConnectionPriority.High, 2, crewB);\\nDittoExperimental.SetPriorityForQueryOverlapGroup(DittoConnectionPriority.High, 2, crewA);\\n\\n","transport-sync-groups":"DittoTransportConfig transportConfig = new DittoTransportConfig();\\n// 1. Enable All Peer to Peer Connections \\ntransportConfig.EnableAllPeerToPeer();\\n// 2. Set sync group to an integer between 0 and 2^32\\ntransportConfig.Global.SyncGroup = 12345;\\nditto.TransportConfig = transportConfig;\\n\\nditto.StartSync();\\n\\n"},"kotlin":{"attachment":"val testContext = InstrumentationRegistry.getInstrumentation().context\\nval attachmentStream = testContext.assets.open(\\"attachment_test.png\\")\\n\\nval bitmapStream = testContext.assets.open(\\"attachment_test.png\\")\\nval attachmentBitmap = BitmapFactory.decodeStream(bitmapStream)\\nbitmapStream.close()\\n\\nval metadata = mapOf(\\"name\\" to \\"my_image.png\\")\\nval attachment = coll.newAttachment(attachmentStream, metadata)\\n\\nval docId = coll.upsert(mapOf(\\"some\\" to \\"string\\", \\"my_attachment\\" to attachment))\\nval doc = coll.findById(docId).exec()\\nval attachmentToken = doc!![\\"my_attachment\\"].attachmentToken\\n\\nval fetcher = coll.fetchAttachment(attachmentToken!!) {\\n    when (it) {\\n        is Completed -> {\\n            val attBitmap: Bitmap = BitmapFactory.decodeStream(it.attachment.getInputStream())\\n        }\\n        is Progress -> {}\\n    }\\n}\\n\\n","datamodel":"val carsCollection = ditto.store[\\"cars\\"]\\n// or\\nval carsCollection = ditto.store.collection(\\"cars\\")\\n\\n","upsert-id":"val docId = ditto.store[\\"people\\"].upsert(\\n    mapOf(\\n        \\"_id\\" to \\"123abc\\",\\n        \\"name\\" to \\"Susan\\",\\n        \\"age\\" to 31\\n    )\\n)\\n\\n","upsert":"val docId2 = ditto.store[\\"people\\"].upsert(\\n    mapOf(\\n        \\"name\\" to \\"Susan\\",\\n        \\"age\\" to 31\\n    )\\n)\\n\\n","upsert-composite-primary-key":"val docId = ditto.store[\\"people\\"].upsert(\\n    mapOf(\\n        \\"_id\\" to mapOf( \\"userId\\" to \\"456abc\\", \\"workId\\" to 789),\\n        \\"name\\" to \\"Susan\\",\\n        \\"age\\" to 31\\n    )\\n)\\n\\n","upsert-datatypes":"ditto.store[\\"foo\\"].upsert(mapOf(\\n    \\"boolean\\" to true,\\n    \\"string\\" to \\"Hello World\\",\\n    \\"number\\" to 10,\\n    \\"map\\" to mapOf(\\"key\\" to \\"value\\"),\\n    \\"array\\" to listOf(1,2,3),\\n    \\"null\\" to null\\n))\\n\\n","write-transaction":"val results = ditto.store.write { transaction ->\\n    val cars = transaction.scoped(\\"cars\\")\\n    val people = transaction.scoped(\\"people\\")\\n    val docId = \\"abc123\\"\\n    people.upsert(mapOf(\\"_id\\" to docId, \\"name\\" to \\"Susan\\"))\\n    cars.upsert(mapOf(\\"make\\" to \\"Hyundai\\", \\"color\\" to \\"red\\", \\"owner\\" to docId))\\n    cars.upsert(mapOf(\\"make\\" to \\"Jeep\\", \\"color\\" to \\"pink\\", \\"owner\\" to docId))\\n    people.findById(DittoDocumentId(docId)).evict()\\n}\\n\\n","counter":"val docId = ditto.store[\\"people\\"].upsert(mapOf(\\n    \\"name\\" to \\"Frank\\",\\n    \\"ownedCars\\" to DittoCounter()\\n))\\n\\nditto.store.collection(\\"people\\").findById(docId).update { mutableDoc ->\\n    mutableDoc!![\\"ownedCars\\"].counter!!.increment(amount = 1.0)\\n}\\n\\n","counter-upsert":"val frankId = ditto.store[\\"people\\"].upsert(mapOf(\\n    \\"name\\" to \\"Frank\\",\\n    \\"age\\" to 31,\\n    \\"ownedCars\\" to DittoCounter()\\n))\\n\\n","update":"ditto.store.collection(\\"people\\").findById(frankId).update { mutableDoc ->\\n    mutableDoc?.let {\\n        it[\\"age\\"].set(32)\\n        it[\\"ownedCars\\"].counter!!.increment(amount = 1.0)\\n    }\\n}\\n\\n","evict":"ditto.store[\\"people\\"].find(\\"age <= 32\\").evict()\\n\\n","upsert-default-data":"val docId = ditto.store.collection(\\"people\\").upsert(mapOf(\\n    \\"name\\" to \\"Susan\\",\\n    \\"age\\" to 31\\n), DittoWriteStrategy.InsertDefaultIfAbsent)\\n\\n","array-to-map":"collection.findById(docId).update { mutableDoc ->\\n    val map = mutableMapOf<String, Any>()\\n    val names = mutableDoc!![\\"friends\\"].listValue\\n    names.forEach { name ->\\n        val id = UUID.randomUUID().toString()\\n        map[id] = mapOf(\\n            \\"id\\" to id,\\n            \\"name\\" to name\\n        )\\n    }\\n\\n    mutableDoc[\\"friendsMap\\"].set(map)\\n}\\n\\n","device-name":"ditto.deviceName = \\"Susan B.\\"\\nditto.startSync()\\nditto.observePeersV2 { peers ->\\n    // render peer list\\n}\\n\\n","online-playground-cloudSync":"val identity = DittoIdentity.OnlinePlayground(androidDependencies,\\n    appId = \\"00000000-0000-4000-0000-000000000000\\",\\n    token = \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\",\\n    // Set to false to disable syncing with the cloud\\n    enableDittoCloudSync = true\\n    )\\nditto = Ditto(androidDependencies, identity)\\nditto.startSync()\\n\\n","query-basic":"val results = ditto.store.collection(\\"people\\")\\n    .find(\\"favoriteBook.title == \'The Great Gatsby\'\\")\\n    .exec()\\n\\n","query-args":"val foundDocs = ditto.store.collection(\\"people\\")\\n    .find(\\"name == \\\\$args.name && age <= \\\\$args.age\\", mapOf(\\"name\\" to \\"max\\", \\"age\\" to 32))\\n\\n","query-sort":"val sortedRedCars = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .sort(\\"miles\\", DittoSortDirection.Ascending)\\n    .exec()\\n\\n","query-limit":"val sortedAndLimitedRedCars = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .sort(\\"miles\\", DittoSortDirection.Ascending)\\n    .limit(100)\\n    .exec()\\n\\n","sync-basic":"try {\\n    ditto.startSync()\\n} catch (e: DittoError) {\\n    // handle error\\n}\\n\\n","sync-observe":"// --- DittoRegister live query to update UI\\nval liveQuery = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .observeLocal { docs, event ->\\n        // Do something...\\n    }\\n\\n","sync-observe-local":"// --- Action somewhere in your application\\nfun userDidInsertCar() {\\n    ditto.store.collection(\\"cars\\").upsert(mapOf(\\n        \\"model\\" to \\"Ford\\",\\n        \\"color\\" to \\"black\\"\\n    ))\\n}\\n\\n// --- DittoRegister live query to update UI\\nval observeLocalQuery = ditto.store.collection(\\"cars\\")\\n    .find(\\"isSold == false\\")\\n    .observeLocal { docs, event ->\\n    // Do something...\\n}\\n\\n","subscribe":"// --- DittoRegister live query to update UI\\nval subscription = ditto.store.collection(\\"cars\\")\\n    .find(\\"color == \'red\'\\")\\n    .subscribe()\\n\\n","online-playground":"try {\\n    val androidDependencies = DefaultAndroidDittoDependencies(context)\\n    val identity = DittoIdentity.OnlinePlayground(\\n        androidDependencies,\\n        appId = \\"00000000-0000-4000-0000-000000000000\\",\\n        token = \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\"\\n    )\\n    DittoLogger.minimumLogLevel = DittoLogLevel.DEBUG\\n    ditto = Ditto(androidDependencies, identity)\\n    ditto.startSync()\\n} catch (e: DittoError) {\\n    Log.e(\\"Ditto error\\", e.message!!)\\n}\\n\\n","offline-playground":"try {\\n    val androidDependencies = DefaultAndroidDittoDependencies(context)\\n    val identity = DittoIdentity.OfflinePlayground(androidDependencies, appId =\\n    \\"00000000-0000-4000-0000-000000000000\\")\\n    ditto = Ditto(androidDependencies, identity)\\n    ditto.setOfflineOnlyLicenseToken(validLicense)\\n    ditto.startSync()\\n} catch(e: DittoError) {\\n    Log.e(\\"Ditto error\\", e.message!!)\\n}\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nval p256DerB64 = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\"\\nval androidDependencies = DefaultAndroidDittoDependencies(context)\\nval identity = DittoIdentity.SharedKey(\\"app\\", p256DerB64, null)\\nval ditto = Ditto(androidDependencies, identity)\\nditto.setOfflineOnlyLicenseToken(validLicense)\\n\\n","transport-configurations":"val config = DittoTransportConfig()\\n\\n//Enable all peer to peer transports\\nconfig.enableAllPeerToPeer()\\n\\n//Or enable/disable each transport separately\\n//BluetoothLe\\nconfig.peerToPeer.bluetoothLe.enabled = true\\n//Local Area Network\\nconfig.peerToPeer.lan.enabled = true\\n//Wifi Aware\\nconfig.peerToPeer.wifiAware.enabled = true\\n\\nditto.transportConfig = config\\n\\nditto.startSync()\\n\\n","transport-sync-groups":"val config = DittoTransportConfig()\\n\\n//Enable all peer to peer transports\\nconfig.enableAllPeerToPeer()\\nconfig.global.syncGroup = 1234U\\n\\nditto.transportConfig = config\\n\\nditto.startSync()\\n\\n","websocket-connect":"val config = DittoTransportConfig()\\n\\nconfig.connect.websocketUrls.add(\\"ws://127.0.0.1\\")\\n\\nditto.transportConfig = config\\n\\nditto.startSync()\\n\\n","network-remote-ditto":"val transportConfig = DittoTransportConfig()\\n\\ntransportConfig.connect.tcpServers.add(\\"135.1.5.5:12345\\")\\ntransportConfig.connect.tcpServers.add(\\"185.1.5.5:12345\\")\\n\\nditto.transportConfig = transportConfig\\nditto.startSync()\\n\\n","network-listen":"val transportConfig = DittoTransportConfig()\\ntransportConfig.connect.tcpServers.add(\\"135.1.5.5:12345\\")\\ntransportConfig.connect.tcpServers.add(\\"185.1.5.5:12345\\")\\nditto.transportConfig = transportConfig\\nditto.startSync()\\n\\n","network-multiple-transports":"val transportConfig = DittoTransportConfig()\\n// 1. Enable All Peer to Peer Connections\\ntransportConfig.enableAllPeerToPeer()\\n// 2. Listen for incoming connections on port 4000\\ntransportConfig.listen.tcp.enabled = true\\ntransportConfig.listen.http.enabled = false\\ntransportConfig.listen.tcp.interfaceIp = \\"0.0.0.0\\"\\ntransportConfig.listen.tcp.port = 4000\\n// 3. Connect explicitly to remote devices\\ntransportConfig.connect.tcpServers.add(\\"135.1.5.5:12345\\")\\ntransportConfig.connect.tcpServers.add(\\"185.1.5.5:12345\\")\\n\\nditto.transportConfig = transportConfig\\nditto.startSync()\\n\\n","network-monitor-conditions":"// ... Setting up inside an Activity\\nval androidDependencies = DefaultAndroidDittoDependencies(applicationContext)\\nval ditto = Ditto(androidDependencies, DittoIdentity.OnlinePlayground\\n(androidDependencies, appId = \\"REPLACE_WITH_APP_ID\\", token = \\"REPLACE_ME_WITH_YOUR_PLAYGROUND_TOKEN\\"))\\nditto.callback = this\\nditto.startSync()\\n\\n// Now you can observe real time changes to the transport conditions:\\n\\nclass MainActivity : AppCompatActivity(), DittoCallback {\\n\\n    override fun transportConditionDidChange(transportId: Long, condition: TransportCondition) {\\n        var toastText: String? = null\\n        if (condition == TransportCondition.TRANSPORT_CONDITION_BLE_DISABLED) {\\n            toastText = \\"BLE disabled\\"\\n        } else if (condition == TransportCondition.TRANSPORT_CONDITION_NO_BLE_CENTRAL_PERMISSION) {\\n            toastText = \\"Permission missing for BLE\\"\\n        } else if (condition == TransportCondition.TRANSPORT_CONDITION_NO_BLE_PERIPHERAL_PERMISSION) {\\n            toastText = \\"Permission missing for BLE\\"\\n        }\\n        toastText?.let {\\n            Handler(mainLooper).post {\\n                Toast.makeText(this, it, Toast.LENGTH_LONG).show()\\n            }\\n        }\\n    }\\n}\\n\\n","network-query-overlap-group":"// The passenger only observes orders that they created\\npassenger.store.collection(\\"orders\\")\\n    .find(\\"user_id==abc123\\")\\n    .observeLocal { docs, event ->\\n        // render passenger orders in a list UI\\n}\\n\\n// Crew member devices observe all orders that everyone created\\ncrewA.store.collection(\\"orders\\")\\n    .find(\\"status == \'OPEN\'\\")\\n    .observeLocal { docs, event ->\\n        // render all orders in a list UI\\n}\\ncrewB.store.collection(\\"orders\\")\\n    .find(\\"status == \'OPEN\'\\")\\n    .observeLocal { docs, event ->\\n        // render all orders in a list UI\\n}\\n\\nDittoExperimental.setQueryOverlapGroup(2u, crewA)\\nDittoExperimental.setQueryOverlapGroup(2u, crewB)\\n\\ncrewA.startSync()\\ncrewB.startSync()\\npassenger.startSync()\\n\\n","network-set-priority":"DittoExperimental.setPriorityForQueryOverlapGroup(DittoConnectionPriority.High, 2u, crewA)\\nDittoExperimental.setPriorityForQueryOverlapGroup(DittoConnectionPriority.High, 2u, crewB)\\n\\n","remove-id":"coll.findById(docId).remove()\\n\\n","remove-query":"val removedDocIds = coll.find(\\"make == \'Honda\'\\").remove()\\n\\n"},"java":{"attachment":"String attachmentPath = tempFile.getPath();\\nMap<String, String> metadata = new HashMap<>();\\nmetadata.put(\\"name\\", \\"my_image.png\\");\\nDittoAttachment attachment = coll.newAttachment(attachmentPath, metadata);\\ntempFile.delete();\\n\\nMap<String, Object> content = new HashMap<>();\\ncontent.put(\\"some\\", \\"string\\");\\ncontent.put(\\"my_attachment\\", attachment);\\nDittoDocumentId docID = coll.upsert(content);\\n\\nDittoDocument doc = coll.findById(docID).exec();\\nDittoAttachmentToken attachmentToken = doc.get(\\"my_attachment\\").getAttachmentToken();\\n\\nDittoAttachmentFetcher fetcher = coll.fetchAttachment(attachmentToken, event -> {\\n    if (event.getType() == DittoAttachmentFetchEventType.Completed) {\\n        DittoAttachment att = event.asCompleted().getAttachment();\\n        BufferedImage attachmentImage;\\n        try {\\n            attachmentImage = ImageIO.read(att.getInputStream());\\n        } catch (IOException e) {\\n            e.printStackTrace();\\n        }\\n    } else if (event.getType() == DittoAttachmentFetchEventType.Progress) {\\n        // do nothing - wait for `Completed` or `Deleted`\\n    } else {\\n    }\\n});\\n\\n\\n","datamodel":"DittoCollection carsCollection = ditto.store.collection(\\"cars\\");\\n\\n","upsert-id":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"_id\\", \\"123abc\\");\\ncontent.put(\\"name\\", \\"Susan\\");\\ncontent.put(\\"age\\", 31);\\nDittoDocumentId docId = ditto.store.collection(\\"people\\").upsert(content);\\n// docId => 123abc\\n\\n","upsert":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"name\\", \\"Susan\\");\\ncontent.put(\\"age\\", 31);\\nDittoDocumentId docId = ditto.store.collection(\\"people\\").upsert(content);\\n// docId => 507f191e810c19729de860ea\\n\\n","upsert-composite-primary-key":"Map<String, Object> _id = new HashMap<>();\\n_id.put(\\"userId\\", \\"456abc\\");\\n_id.put(\\"workId\\", 789);\\n\\nMap<String, Object> value = new HashMap<>();\\nvalue.put(\\"_id\\", _id);\\nvalue.put(\\"name\\", \\"Susan\\");\\nvalue.put(\\"age\\", 31);\\nDittoDocumentId docID = ditto.store.collection(\\"people\\").upsert(value);\\n// docId=> \\"_id.put(\\"userId\\", \\"456abc\\"); _id.put(\\"workId\\", 789);\\"\\n\\n","remove-id":"ditto.store.collection(\\"people\\").findById(docId).remove();\\n\\n","remove-query":"ditto.store.collection(\\"people\\").find(\\"age <= 32\\").remove();\\n\\n","evict":"ditto.store.collection(\\"people\\").find(\\"age <= 32\\").evict();\\n\\n","upsert-datatypes":"// Insert JSON-compatible data into Ditto\\nMap<String, Object> content = new HashMap<>();\\ncontent.put(\\"boolean\\", true);\\ncontent.put(\\"string\\", \\"Hello World\\");\\ncontent.put(\\"number\\", 10);\\nMap<String, String> innerMap = new HashMap<>();\\ninnerMap.put(\\"key\\", \\"value\\");\\ncontent.put(\\"map\\", innerMap);\\ncontent.put(\\"array\\", Arrays.asList(1, 2, 3));\\ncontent.put(\\"null\\", null);\\nditto.store.collection(\\"foo\\").upsert(content);\\n\\n","counter":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"name\\", \\"Frank\\");\\ncontent.put(\\"ownedCars\\", new DittoCounter());\\nDittoDocumentId docId = ditto.store.collection(\\"people\\").upsert(content);\\n\\nditto.store.collection(\\"people\\").findById(docId).update(mutDoc -> {\\n    assertThat(mutDoc).isNotNull();\\n    DittoMutableCounter counter = mutDoc.get(\\"ownedCars\\").getCounter();\\n    assertThat(counter).isNotNull();\\n    counter.increment(1);\\n});\\n\\n","array-to-map":"collection.findById(docId).update(dittoMutableDocument -> {\\n    Map<String, Object> friendsMap = new HashMap<>();\\n    List<Object> names = dittoMutableDocument.get(\\"friends\\").getListValue();\\n    names.forEach(name -> {\\n        Map<String, Object> friend = new HashMap<>();\\n        String id = UUID.randomUUID().toString();\\n        friend.put(\\"id\\", id);\\n        friend.put(\\"name\\", name);\\n        friendsMap.put(id, friend);\\n    });\\n});\\n\\n","counter-upsert":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"name\\", \\"Frank\\");\\ncontent.put(\\"age\\", 31);\\ncontent.put(\\"ownedCars\\", new DittoCounter());\\nDittoDocumentId docId = ditto.store.collection(\\"people\\").upsert(content);\\n\\nditto.store.collection(\\"people\\").findById(docId).update(doc -> {\\n    try {\\n        doc.get(\\"age\\").set(32);\\n        doc.get(\\"ownedCars\\").getCounter().increment(1);\\n    } catch (DittoError err) {\\n        // Do something with error\\n    }\\n});\\n\\n","device-name":"ditto.deviceName = \\"Susan B.\\";\\ntry {\\n    ditto.startSync();\\n} catch(DittoError e) {\\n    // handle error\\n}\\nditto.observePeersV2(peers -> {\\n    // render peers\\n});\\n\\n","upsert-default-data":"Map<String, Object> content = new HashMap<>();\\ncontent.put(\\"name\\", \\"Susan\\");\\ncontent.put(\\"age\\", 31);\\nDittoDocumentId docId = ditto.store\\n        .collection(\\"people\\")\\n        .upsert(content, DittoWriteStrategy.InsertDefaultIfAbsent);\\n\\n","query-basic":"List<DittoDocument> results = ditto.store.collection(\\"people\\")\\n        .find(\\"favoriteBook.title == \'The Great Gatsby\'\\")\\n        .exec();\\n\\n","query-args":"Map<String, Object> queryArgs = new HashMap<>();\\nqueryArgs.put(\\"name\\", \\"max\\");\\nqueryArgs.put(\\"age\\", 32);\\n\\nList<DittoDocument> foundDocs = ditto.store.collection(\\"users\\")\\n        .find(\\"name == $args.name && age <= $args.age\\", queryArgs)\\n        .exec();\\n\\n","query-sort":"List<DittoDocument> sortedRedCars = ditto.store.collection(\\"cars\\")\\n        .find(\\"color == \'red\'\\")\\n        .sort(\\"miles\\", DittoSortDirection.Ascending)\\n        .exec();\\n\\n","query-limit":"List<DittoDocument> sortedAndLimitedRedCars = ditto.store.collection(\\"cars\\")\\n        .find(\\"color == \'red\'\\")\\n        .sort(\\"miles\\", DittoSortDirection.Ascending)\\n        .limit(100)\\n        .exec();\\n\\n","sync-basic":"try {\\n    ditto.startSync();\\n} catch(DittoError e) {\\n    // handle error\\n}\\n\\n","sync-observe":"// --- Register live query to update UI\\nDittoLiveQuery liveQuery = ditto.store.collection(\\"cars\\")\\n        .find(\\"color == \'red\'\\")\\n        .observeLocal((docs, event) -> {\\n            // Do something...\\n        });\\n\\n","sync-observe-local":"// --- Action somewhere in your application\\nMap<String, Object> content = new HashMap<>();\\ncontent.put(\\"model\\", \\"Ford\\");\\ncontent.put(\\"color\\", \\"black\\");\\nditto.store.collection(\\"cars\\").upsert(content);\\n\\n// --- Register live query to update UI\\nDittoLiveQuery liveQueryLocal = ditto.store.collection(\\"cars\\")\\n        .find(\\"owner == \'Susan\'\\")\\n        .observeLocal((docs, event) -> {\\n            // Do something...\\n        });\\n\\n","subscribe":"// --- Register live query to update UI\\nDittoSubscription subscription = ditto.store.collection(\\"cars\\")\\n        .find(\\"!isSold\\")\\n        .subscribe();\\n\\n","shared-key":"// This is just an example. You should use OpenSSL to generate a unique shared key for every application.\\nString p256DerB64 = \\"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgFUUrOkOH52QN+Rr6uDSDsk4hUTcD1eW4mT0UnGGptFehRANCAATJ3fG8TVLQcDwUV18BJJI8efK0hQAjzB3VJeYOVbfOlqnfukVId0V25r/abxwjD3HfHuPsCGEiefzzmkMbjPo9\\";\\nDefaultAndroidDittoDependencies androidDependencies = new DefaultAndroidDittoDependencies(this.context);\\nDittoIdentity identity = new DittoIdentity.SharedKey(androidDependencies, \\"app\\", p256DerB64);\\nDitto ditto = new Ditto(androidDependencies, identity);\\ntry {\\n    ditto.setOfflineOnlyLicenseToken(validLicense);\\n} catch(DittoError e) {\\n    //handle error\\n}\\n\\n","online-playground":"DittoDependencies androidDependencies = new DefaultAndroidDittoDependencies(this.context);\\nDittoLogger.setMinimumLogLevel(DittoLogLevel.DEBUG);\\nDittoIdentity identity = new DittoIdentity.OnlinePlayground(androidDependencies, \\"00000000-0000-4000-0000-000000000000\\", \\"YOUR_PLAYGROUND_TOKEN_HERE\\");\\nDitto ditto = new Ditto(androidDependencies, identity);\\n\\ntry {\\n    ditto.startSync();\\n} catch(DittoError e) {\\n    //handle error\\n}\\n\\n","offline-playground":"DittoIdentity identity = new DittoIdentity.OfflinePlayground(androidDependencies, \\"00000000-0000-4000-0000-000000000000\\");\\nDitto ditto = new Ditto(androidDependencies, identity);\\ntry {\\n    ditto.setOfflineOnlyLicenseToken(validLicense);\\n} catch(DittoError e) {\\n    //handle error\\n}\\ntry {\\n    ditto.startSync();\\n} catch(DittoError e) {\\n    //handle error\\n}\\n\\n","online-playground-cloudSync":"DittoIdentity identity = new DittoIdentity.OnlinePlayground(androidDependencies,\\n        \\"00000000-0000-4000-0000-000000000000\\",\\n        \\"YOUR_PLAYGROUND_TOKEN_HERE\\",\\n        // Set to false to disable syncing with the cloud\\n        true);\\n\\nDitto ditto = new Ditto(androidDependencies, identity);\\n\\ntry {\\n    ditto.startSync();\\n} catch(DittoError e) {\\n    //handle error\\n}\\n\\n","transport-configurations":"DittoTransportConfig config = new DittoTransportConfig();\\n\\n//Enable all peer to peer transports\\nconfig.enableAllPeerToPeer();\\n\\n//Or enable/disable each transport separately\\n//BluetoothLe\\nconfig.getPeerToPeer().getBluetoothLe().setEnabled(true);\\n//Local Area Network\\nconfig.getPeerToPeer().getLan().setEnabled(true);\\n//Awdl\\nconfig.getPeerToPeer().getWifiAware().setEnabled(true);\\n\\nditto.setTransportConfig(config);\\n\\ntry {\\n    ditto.startSync();\\n} catch(DittoError error) {\\n    // handle error\\n}\\n\\n","websocket-connect":"DittoTransportConfig config = new DittoTransportConfig();\\n\\nDittoConnect connect = new DittoConnect();\\nconnect.setWebsocketUrls(Collections.singleton(\\"ws://127.0.0.1\\"));\\nconfig.setConnect(connect);\\n\\ntry {\\n    ditto.startSync();\\n} catch(DittoError error) {\\n    // handle error\\n}\\n\\n","network-remote-ditto":"DittoTransportConfig config = new DittoTransportConfig();\\nDittoConnect connect = new DittoConnect();\\nconnect.setTcpServers(Sets.newHashSet(\\"135.1.5.5:12345\\", \\"185.1.5.5:12345\\"));\\nconfig.setConnect(connect);\\n\\ntry {\\n    ditto.startSync();\\n} catch(DittoError error) {\\n    // handle error\\n}\\n\\n","network-listen":"DittoTransportConfig config = new DittoTransportConfig();\\nconfig.enableAllPeerToPeer();\\n\\nDittoListen listen = new DittoListen();\\nDittoTcpListenConfig tcpListenConfig = new DittoTcpListenConfig();\\ntcpListenConfig.setEnabled(true);\\ntcpListenConfig.setInterfaceIp(\\"0.0.0.0\\");\\ntcpListenConfig.setPort(4000);\\nlisten.setTcp(tcpListenConfig);\\nconfig.setListen(listen);\\n\\ntry {\\n    ditto.startSync();\\n} catch(DittoError error) {\\n    // handle error\\n}\\n\\n","network-multiple-transports":"DittoTransportConfig config = new DittoTransportConfig();\\n\\n// 1. Enable Peer to Peer Connections\\nconfig.enableAllPeerToPeer();\\n\\n// 2. Listen for incoming connections on port 4000\\nDittoListen listen = new DittoListen();\\nDittoTcpListenConfig tcpListenConfig = new DittoTcpListenConfig();\\ntcpListenConfig.setEnabled(true);\\ntcpListenConfig.setInterfaceIp(\\"0.0.0.0\\");\\ntcpListenConfig.setPort(4000);\\nlisten.setTcp(tcpListenConfig);\\nconfig.setListen(listen);\\n// 3. Connect explicitly to remote devices\\nDittoConnect connect = new DittoConnect();\\nconnect.setTcpServers(Sets.newHashSet(\\"135.1.5.5:12345\\", \\"185.1.5.5:12345\\"));\\nconfig.setConnect(connect);\\n\\ntry {\\n    ditto.startSync();\\n} catch(DittoError error) {\\n    // handle error\\n}\\n\\n","network-monitor-conditions":"// Setting up inside an Activity\\nDefaultAndroidDittoDependencies androidDependencies = new DefaultAndroidDittoDependencies(getApplicationContext());\\nDitto ditto = new Ditto(androidDependencies, new DittoIdentity.OnlinePlayground(androidDependenciesOne, \\"REPLACE_WITH_APP_ID\\"));\\nditto.callback = this;\\nditto.startSync();\\n\\n// Now you can observe real time changes to the transport conditions:\\npublic class MainActivity extends AppCompatActivity implements DittoCallback {\\n    @Override\\n    public void transportConditionDidChange(@NotNull DittoTransportCondition condition, @NotNull DittoConditionSource transportId) {\\n        String toastText = null;\\n        if (condition == DittoTransportCondition.BleDisabled) {\\n            toastText = \\"BLE disabled\\";\\n        } else if (condition == DittoTransportCondition.NoBleCentralPermission) {\\n            toastText = \\"Permission missing for BLE\\";\\n        } else if (condition == DittoTransportCondition.NoBlePeripheralPermission) {\\n            toastText = \\"Permission missing for BLE\\";\\n        }\\n\\n        if (toastText != null) {\\n            String finalToastText = toastText;\\n            runOnUiThread(new Runnable() {\\n                @Override\\n                public void run() {\\n                    Toast.makeText(MainActivity.this, finalToastText, Toast.LENGTH_LONG).show();\\n                }\\n            });\\n        }\\n    }\\n}\\n\\n"}}');var s=t(99013),c=t(49366),l=t(30547),d=t(50494);const p=e=>d.Z.find((n=>n.id===e));function u(e){let n,{name:t,language:r,label:i}=e,c=a[r];if(c){let e=c[t];e&&(n=e)}return n?o.createElement(s.Z,{className:r},n.trim().replace("00000000-0000-4000-0000-000000000000","REPLACE_ME_WITH_YOUR_APP_ID")):(console.error(`no snippet for ${t} in language=${r}`),o.createElement("div",null,"Not supported by ",i,"."))}function m(e){let{children:n,name:t}=e;const{tabGroupChoices:a,setTabGroupChoices:s}=(0,r.Z)(),d=p(a.platform);let m=d?d.id:"ios";const g=i(m),y=g[0];return o.createElement(c.Z,{platform:m,groupId:"programming-language",defaultValue:y?y.value:"swift",values:g},g.map((e=>o.createElement(l.Z,{key:`${e.value}-${t}`,value:e.value},o.createElement(u,{name:t,language:e.value,label:e.label})))))}},99013:(e,n,t)=>{"use strict";t.d(n,{Z:()=>C});var o=t(87462),r=t(67294),i=t(86010),a=t(23746),s=t(10195),c=t(87594),l=t.n(c),d=t(95999),p=t(68793),u=t(62435),m=t(71418);const g={codeBlockContainer:"codeBlockContainer_EiTO",codeBlockContent:"codeBlockContent_X2I6",codeBlockTitle:"codeBlockTitle_PQMO",codeBlock:"codeBlock_UxnK",copyButton:"copyButton_V-PD",codeBlockLines:"codeBlockLines_W6UD"};var y=t(32822);const f=/{([\d,-]+)}/,h=["js","jsBlock","jsx","python","html"],D={js:{start:"\\/\\/",end:""},jsBlock:{start:"\\/\\*",end:"\\*\\/"},jsx:{start:"\\{\\s*\\/\\*",end:"\\*\\/\\s*\\}"},python:{start:"#",end:""},html:{start:"\x3c!--",end:"--\x3e"}},v=["highlight-next-line","highlight-start","highlight-end"],b=function(e){void 0===e&&(e=h);const n=e.map((e=>{const{start:n,end:t}=D[e];return`(?:${n}\\s*(${v.join("|")})\\s*${t})`})).join("|");return new RegExp(`^\\s*(?:${n})\\s*$`)},w=e=>{switch(e){case"js":case"javascript":case"ts":case"typescript":return b(["js","jsBlock"]);case"jsx":case"tsx":return b(["js","jsBlock","jsx"]);case"html":return b(["js","jsBlock","html"]);case"python":case"py":return b(["python"]);default:return b()}};function C(e){let{children:n,className:t,metastring:c,title:h}=e;const{prism:D}=(0,y.LU)(),[v,b]=(0,r.useState)(!1),[C,I]=(0,r.useState)(!1);(0,r.useEffect)((()=>{I(!0)}),[]);const A=(0,y.bc)(c)||h,T=(0,r.useRef)(null);let S=[];const _=Array.isArray(n)?n.join(""):n;if(c&&f.test(c)){const e=c.match(f)[1];S=l()(e).filter((e=>e>0))}let k=t?.replace(/language-/,"");!k&&D.defaultLanguage&&(k=D.defaultLanguage);let E=_.replace(/\n$/,"");if(0===S.length&&void 0!==k){let e="";const n=w(k),t=_.replace(/\n$/,"").split("\n");let o;for(let r=0;r<t.length;){const i=r+1,a=t[r].match(n);if(null!==a){switch(a.slice(1).reduce(((e,n)=>e||n),void 0)){case"highlight-next-line":e+=`${i},`;break;case"highlight-start":o=i;break;case"highlight-end":e+=`${o}-${i-1},`}t.splice(r,1)}else r+=1}S=l()(e),E=t.join("\n")}const N=()=>{(0,s.Z)(E),b(!0),setTimeout((()=>b(!1)),2e3)};return r.createElement(a.ZP,(0,o.Z)({},a.lG,{key:String(C),theme:m.Z,code:E,language:k}),(e=>{let{className:n,style:t,tokens:a,getLineProps:s,getTokenProps:c}=e;return r.createElement("div",{className:g.codeBlockContainer},A&&r.createElement("div",{style:t,className:g.codeBlockTitle},A),r.createElement("div",{className:(0,i.Z)(g.codeBlockContent,k)},r.createElement("pre",{tabIndex:0,className:(0,i.Z)(n,g.codeBlock,"thin-scrollbar")},r.createElement("code",{className:g.codeBlockLines},a.map(((e,n)=>{1===e.length&&""===e[0].content&&(e[0].content="\n");const t=s({line:e,key:n}),a=S.includes(n+1);S.includes(n+1)&&(t.className+="bg-gray-800 docusaurus-highlight-code-line");let l=(0,i.Z)(t.className,a&&"bg-gray-700");return r.createElement("span",(0,o.Z)({key:n},t,{className:l}),e.map(((e,n)=>{let t={...c({token:e,key:n})},a=t.className;return a.includes("inserted-sign")&&(a=(0,i.Z)(a,"bg-green-900")),a.includes("deleted-sign")&&(a=(0,i.Z)(a,"bg-red-900")),r.createElement("span",(0,o.Z)({key:n},t,{className:a}))})))})))),r.createElement("button",{ref:T,type:"button","aria-label":(0,d.I)({id:"theme.CodeBlock.copyButtonAriaLabel",message:"Copy code to clipboard",description:"The ARIA label for copy code blocks button"}),className:(0,i.Z)(g.copyButton,"clean-btn",v?"bg-green-500":""),onClick:N},v?r.createElement("div",null,r.createElement(p.Z,{className:"w-4 h-4 inline mr-1"}),r.createElement("span",{className:"text-xs"},"Copied")):r.createElement("div",null,r.createElement(u.Z,{className:"w-4 h-4 inline mr-1"}),r.createElement("span",{className:"text-xs"},"Copy")))))}))}},30547:(e,n,t)=>{"use strict";t.d(n,{Z:()=>r});var o=t(67294);const r=function(e){let{children:n,hidden:t,className:r}=e;return o.createElement("div",{role:"tabpanel",hidden:t,className:r},n)}},49366:(e,n,t)=>{"use strict";t.d(n,{Z:()=>a});var o=t(67294),r=t(80944),i=t(86010);const a=function(e){const{lazy:n,platform:t,block:a,defaultValue:s,values:c,groupId:l,className:d}=e,p=o.Children.toArray(e.children),u=c??p.map((e=>({value:e.props.value,label:e.props.label}))),m=s??p.find((e=>e.props.default))?.props.value,{tabGroupChoices:g,setTabGroupChoices:y}=(0,r.Z)(),[f,h]=(0,o.useState)(m);(0,o.useEffect)((()=>{if(null!=l){const e=g[l];null!=e&&e!==f&&(u.some((n=>n.value===e))?h(e):h(m))}}),[t,g[l]]);const D=e=>{h(e),null!=l&&y(l,e)},v=u.length>1;return o.createElement("div",{className:"tabs-container"},v&&o.createElement(o.Fragment,null,o.createElement("div",{className:"sm:hidden"},o.createElement("label",{htmlFor:"tabs",className:"sr-only"},"Select a tab"),o.createElement("select",{id:"tabs",name:"tabs",value:f,onChange:e=>D(e.currentTarget.value),className:"block w-full focus:ring-blue-500 focus:border-blue-500 border-gray-300 rounded-md"},u.map((e=>{let{value:n,label:t}=e;return o.createElement("option",{value:n,key:n},t??n)})))),o.createElement("div",{className:"hidden sm:block"},o.createElement("nav",{className:"flex space-x-4","aria-label":"Tabs"},u.map((e=>{let{value:n,label:t}=e;return o.createElement("button",{key:n,onClick:()=>D(n),className:(0,i.Z)(f===n?"bg-blue-100 text-blue-700":"text-gray-500 hover:text-gray-700","px-3 py-2 font-medium text-sm rounded-md"),"aria-current":f===n?"page":void 0},t??n)}))))),n?(0,o.cloneElement)(p.filter((e=>e.props.value===f))[0],{className:"margin-vert--md"}):o.createElement("div",{className:"margin-vert--md"},p.map(((e,n)=>(0,o.cloneElement)(e,{key:n,hidden:e.props.value!==f})))))}},79687:(e,n,t)=>{"use strict";t.r(n),t.d(n,{contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>c,toc:()=>l});var o=t(87462),r=(t(67294),t(3905)),i=(t(8209),t(49366),t(30547),t(36438));const a={title:"Transport Configuration",sidebar_position:99},s=void 0,c={unversionedId:"mesh-network/manual",id:"mesh-network/manual",isDocsHomePage:!1,title:"Transport Configuration",description:"There are instances where you may want to configure additional connections configurations for the current Ditto instance. This section will teach you how to configure your Ditto instance to listen for connections on a port explicitly and to connect to remote instances via a host (IP) and port. To do this, before you call startSync(), construct a DittoTransportConfig value and set ditto.SetTransportConfig.",source:"@site/docs/common/mesh-network/manual.mdx",sourceDirName:"mesh-network",slug:"/mesh-network/manual",permalink:"/common/mesh-network/manual",editUrl:"https://github.com/getditto/docs/edit/main/docs/common/mesh-network/manual.mdx",tags:[],version:"current",sidebarPosition:99,frontMatter:{title:"Transport Configuration",sidebar_position:99},sidebar:"defaultSidebar",previous:{title:"Query Overlap Groups",permalink:"/common/mesh-network/query-overlap-groups"},next:{title:"Overview",permalink:"/common/datamodel/overview"}},l=[{value:"Enabling/Disabling Transports",id:"enablingdisabling-transports",children:[],level:2},{value:"Sync to Ditto Cloud",id:"sync-to-ditto-cloud",children:[],level:2},{value:"Observing Peers",id:"observing-peers",children:[],level:2},{value:"Sync Groups",id:"sync-groups",children:[],level:2},{value:"Connecting to a Remote Ditto Peer",id:"connecting-to-a-remote-ditto-peer",children:[],level:2},{value:"Listening for Connections on a Specific Port",id:"listening-for-connections-on-a-specific-port",children:[],level:2},{value:"Combining Multiple Transports",id:"combining-multiple-transports",children:[],level:2},{value:"Monitoring Transport Conditions",id:"monitoring-transport-conditions",children:[],level:2}],d={toc:l},p="wrapper";function u(e){let{components:n,...t}=e;return(0,r.kt)(p,(0,o.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"There are instances where you may want to configure additional connections configurations for the current Ditto instance. This section will teach you how to configure your Ditto instance to listen for connections on a port explicitly and to connect to remote instances via a host (IP) and port. To do this, ",(0,r.kt)("em",{parentName:"p"},"before")," you call ",(0,r.kt)("inlineCode",{parentName:"p"},"startSync()"),", construct a ",(0,r.kt)("inlineCode",{parentName:"p"},"DittoTransportConfig")," value and set ",(0,r.kt)("inlineCode",{parentName:"p"},"ditto.SetTransportConfig"),"."),(0,r.kt)("p",null,"Ditto will automatically attempt to connect to other ditto instances on\nthe Local Area Network, Bluetooth, and AWDL. However, if you supply a\n",(0,r.kt)("inlineCode",{parentName:"p"},"DittoTransportConfig"),", this will not automatically be enabled. You'll need to\nremember to enable peer to peer connnections with ",(0,r.kt)("inlineCode",{parentName:"p"},"EnableAllPeerToPeer()"),".  "),(0,r.kt)("h2",{id:"enablingdisabling-transports"},"Enabling/Disabling Transports"),(0,r.kt)("p",null,"You can enable all peer to peer connections with ",(0,r.kt)("inlineCode",{parentName:"p"},"EnableAllPeerToPeer()"),". You can also customize which transports are used by enabling/disabling each transport separately."),(0,r.kt)(i.Z,{name:"transport-configurations",mdxType:"SnippetGroup"}),(0,r.kt)("h2",{id:"sync-to-ditto-cloud"},"Sync to Ditto Cloud"),(0,r.kt)("p",null,"The big peer generates certificates automatically for each small peer. A certificate involves an expiration date and AppID, among other credentials. Read more here about how it works."),(0,r.kt)("p",null,"In order to sync with other devices, a peer must connect to the Big Peer at least once. To do this, you must use either ",(0,r.kt)("a",{parentName:"p",href:"./online-playground"},"OnlinePlayground")," or ",(0,r.kt)("a",{parentName:"p",href:"../security/authentication"},"OnlineWithAuthentication"),". "),(0,r.kt)("p",null,"We recommend using OnlinePlayground for development and OnlineWithAuthentication for production apps. If you only want to use the Big Peer for authentication without syncing to the cloud, you can use\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"enableDittoCloudSync=false"),".  ",(0,r.kt)("inlineCode",{parentName:"p"},"enableDittoCloudSync")," is set to true by default."),(0,r.kt)(i.Z,{name:"online-playground-cloudSync",mdxType:"SnippetGroup"}),(0,r.kt)("h2",{id:"observing-peers"},"Observing Peers"),(0,r.kt)("p",null,"Ditto always monitors the mesh network and can report the device names of peers\nit is connected to. You can manually set the device name of those peers and\nobserve those peers in the network."),(0,r.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"The device name must be set before ",(0,r.kt)("inlineCode",{parentName:"p"},"startSync()")," is called."))),(0,r.kt)(i.Z,{name:"device-name",mdxType:"SnippetGroup"}),(0,r.kt)("p",null,"If you want to observe changes made by a particular\ndevice, include the device name as a field in the document and query for that field in\nyour ",(0,r.kt)("a",{parentName:"p",href:"../concepts/querying"},"ditto live query")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"\"status == 'open' && edited_by == 'deviceC'\"\n")),(0,r.kt)("h2",{id:"sync-groups"},"Sync Groups"),(0,r.kt)("p",null,"When peer-to-peer transports are enabled, all devices with the same App ID will\nform an interconnected mesh network. If you have knowledge ahead of time that\ndevices are in distinct groups that should only sync with each other, you can\noptimize performance by restricting them from syncronizing with each other. "),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"syncGroup")," parameter provides this functionality. A device can only ever be\nin one sync group, which by default is group 0. Up to 2^32 distinct group\nnumbers can be used in an app. Using a sync group is more performant, and is\nrecommended in any case where this knowledge is known ahead of time."),(0,r.kt)("div",{style:{display:"flex","justify-content":"center"}},(0,r.kt)("img",{style:{width:"300px"},src:"/img/sync-group.png"}),(0,r.kt)("p",{style:{width:"500px"}},(0,r.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"For example, imagine an application that supports two different restaurant\nlocations: 1234 and 7890. Before calling ",(0,r.kt)("inlineCode",{parentName:"p"},"startSync()"),", you can use a different sync group for each location. Only\ndevices in the same sync group will sync with eachother. This will make queries faster when sent to the same big peer."))))),(0,r.kt)(i.Z,{name:"transport-sync-groups",mdxType:"SnippetGroup"}),(0,r.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("h4",{parentName:"div",id:"note-sync-groups-are-not-a-security-mechanism"},"Note: sync groups are not a security mechanism"),(0,r.kt)("p",{parentName:"div"},"Sync groups are an optimization, not a security control. If a connection is created\nmanually, such as by specifying a ",(0,r.kt)("inlineCode",{parentName:"p"},"connect")," transport, then devices from\ndifferent sync groups will still sync as normal. If two groups of devices are\nintended to have access to different data sets, this must be enforced using\nDitto's permissions system."))),(0,r.kt)("h2",{id:"connecting-to-a-remote-ditto-peer"},"Connecting to a Remote Ditto Peer"),(0,r.kt)("p",null,"If you know the host and port of another remote Ditto peer and would like to connect to it, construct a ",(0,r.kt)("inlineCode",{parentName:"p"},"DittoTransportConfig")," object and add the host and port to the ",(0,r.kt)("inlineCode",{parentName:"p"},"DittoTransportConfig.Connect.TcpServers")," property as a ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),". The string format should be ",(0,r.kt)("inlineCode",{parentName:"p"},"host:port"),", separated by a colon."),(0,r.kt)("p",null,"In the example below, we know of two other Ditto peers located on:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Host IP ",(0,r.kt)("inlineCode",{parentName:"li"},"135.1.5.5")," at port ",(0,r.kt)("inlineCode",{parentName:"li"},"12345")),(0,r.kt)("li",{parentName:"ul"},"Host IP ",(0,r.kt)("inlineCode",{parentName:"li"},"185.1.5.5")," at port ",(0,r.kt)("inlineCode",{parentName:"li"},"4567"))),(0,r.kt)(i.Z,{name:"network-remote-ditto",mdxType:"SnippetGroup"}),(0,r.kt)("p",null,"Feel free to add as many known remote ",(0,r.kt)("inlineCode",{parentName:"p"},"host:port")," strings. "),(0,r.kt)("p",null,"You can also configure your Ditto instance to connect to a websocket, which is useful to connect to one or more big peers or authentication instances."),(0,r.kt)(i.Z,{name:"websocket-connect",mdxType:"SnippetGroup"}),(0,r.kt)("h2",{id:"listening-for-connections-on-a-specific-port"},"Listening for Connections on a Specific Port"),(0,r.kt)("p",null,'You can enable the Ditto instance to listen for incoming connections from other\nremotes Ditto peers on a specific port. You can think of this as setting up your\nDitto as a "server" that can listen to connections from other peers.'),(0,r.kt)("p",null,"In this example, we would like our Ditto instance to listen to ",(0,r.kt)("em",{parentName:"p"},"incoming")," connections on port ",(0,r.kt)("inlineCode",{parentName:"p"},"4000")," on ",(0,r.kt)("inlineCode",{parentName:"p"},"0.0.0.0"),". "),(0,r.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"To be safe, please do not use ",(0,r.kt)("inlineCode",{parentName:"p"},"localhost")," when setting the IP interface. Use ",(0,r.kt)("inlineCode",{parentName:"p"},'"0.0.0.0"')," instead."))),(0,r.kt)(i.Z,{name:"network-listen",mdxType:"SnippetGroup"}),(0,r.kt)("p",null,"Incoming connections from other Ditto peers will be able to connect only if the\nport is accessible. Depending on your deployment ",(0,r.kt)("em",{parentName:"p"},"be sure to check that external\nconnections can reach the port")," that you have specified in your configuration.\nYou may need to set up port forwarding if external ports map differently to your\nhost."),(0,r.kt)("h2",{id:"combining-multiple-transports"},"Combining Multiple Transports"),(0,r.kt)("p",null,"You can specify several modes of transport configuration within ",(0,r.kt)("inlineCode",{parentName:"p"},"DittoTransportConfig"),". The following snippet shows you a ditto instance that can:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Connect to local area network devices"),(0,r.kt)("li",{parentName:"ol"},"Listen for incoming remote connections"),(0,r.kt)("li",{parentName:"ol"},"Connect to remote devices with a known host and port. ")),(0,r.kt)(i.Z,{name:"network-multiple-transports",mdxType:"SnippetGroup"}),(0,r.kt)("h2",{id:"monitoring-transport-conditions"},"Monitoring Transport Conditions"),(0,r.kt)("p",null,"If syncing over Bluetooth LE is a critical part of your application you may want\nto warn the user if they are missing the permission or if the hardware is\ndisabled. Ditto will help you by reporting conditions via a delegate or callback\nobject."),(0,r.kt)("p",null,"First, while configuring Ditto, assign a delegate or a callback to receive notifications."),(0,r.kt)(i.Z,{name:"network-monitor-conditions",mdxType:"SnippetGroup"}))}u.isMDXComponent=!0},87594:(e,n)=>{function t(e){let n,t=[];for(let o of e.split(",").map((e=>e.trim())))if(/^-?\d+$/.test(o))t.push(parseInt(o,10));else if(n=o.match(/^(-?\d+)(-|\.\.\.?|\u2025|\u2026|\u22EF)(-?\d+)$/)){let[e,o,r,i]=n;if(o&&i){o=parseInt(o),i=parseInt(i);const e=o<i?1:-1;"-"!==r&&".."!==r&&"\u2025"!==r||(i+=e);for(let n=o;n!==i;n+=e)t.push(n)}}return t}n.default=t,e.exports=t},23746:(e,n,t)=>{"use strict";t.d(n,{ZP:()=>g,lG:()=>a});var o=t(87410);const r={plain:{backgroundColor:"#2a2734",color:"#9a86fd"},styles:[{types:["comment","prolog","doctype","cdata","punctuation"],style:{color:"#6c6783"}},{types:["namespace"],style:{opacity:.7}},{types:["tag","operator","number"],style:{color:"#e09142"}},{types:["property","function"],style:{color:"#9a86fd"}},{types:["tag-id","selector","atrule-id"],style:{color:"#eeebff"}},{types:["attr-name"],style:{color:"#c4b9fe"}},{types:["boolean","string","entity","url","attr-value","keyword","control","directive","unit","statement","regex","atrule","placeholder","variable"],style:{color:"#ffcc99"}},{types:["deleted"],style:{textDecorationLine:"line-through"}},{types:["inserted"],style:{textDecorationLine:"underline"}},{types:["italic"],style:{fontStyle:"italic"}},{types:["important","bold"],style:{fontWeight:"bold"}},{types:["important"],style:{color:"#c4b9fe"}}]};var i=t(67294),a={Prism:o.default,theme:r};function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function c(){return c=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},c.apply(this,arguments)}var l=/\r\n|\r|\n/,d=function(e){0===e.length?e.push({types:["plain"],content:"\n",empty:!0}):1===e.length&&""===e[0].content&&(e[0].content="\n",e[0].empty=!0)},p=function(e,n){var t=e.length;return t>0&&e[t-1]===n?e:e.concat(n)};function u(e,n){var t={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&-1===n.indexOf(o)&&(t[o]=e[o]);return t}var m=function(e){function n(){for(var n=this,t=[],o=arguments.length;o--;)t[o]=arguments[o];e.apply(this,t),s(this,"getThemeDict",(function(e){if(void 0!==n.themeDict&&e.theme===n.prevTheme&&e.language===n.prevLanguage)return n.themeDict;n.prevTheme=e.theme,n.prevLanguage=e.language;var t=e.theme?function(e,n){var t=e.plain,o=Object.create(null),r=e.styles.reduce((function(e,t){var o=t.languages,r=t.style;return o&&!o.includes(n)||t.types.forEach((function(n){var t=c({},e[n],r);e[n]=t})),e}),o);return r.root=t,r.plain=c({},t,{backgroundColor:null}),r}(e.theme,e.language):void 0;return n.themeDict=t})),s(this,"getLineProps",(function(e){var t=e.key,o=e.className,r=e.style,i=c({},u(e,["key","className","style","line"]),{className:"token-line",style:void 0,key:void 0}),a=n.getThemeDict(n.props);return void 0!==a&&(i.style=a.plain),void 0!==r&&(i.style=void 0!==i.style?c({},i.style,r):r),void 0!==t&&(i.key=t),o&&(i.className+=" "+o),i})),s(this,"getStyleForToken",(function(e){var t=e.types,o=e.empty,r=t.length,i=n.getThemeDict(n.props);if(void 0!==i){if(1===r&&"plain"===t[0])return o?{display:"inline-block"}:void 0;if(1===r&&!o)return i[t[0]];var a=o?{display:"inline-block"}:{},s=t.map((function(e){return i[e]}));return Object.assign.apply(Object,[a].concat(s))}})),s(this,"getTokenProps",(function(e){var t=e.key,o=e.className,r=e.style,i=e.token,a=c({},u(e,["key","className","style","token"]),{className:"token "+i.types.join(" "),children:i.content,style:n.getStyleForToken(i),key:void 0});return void 0!==r&&(a.style=void 0!==a.style?c({},a.style,r):r),void 0!==t&&(a.key=t),o&&(a.className+=" "+o),a})),s(this,"tokenize",(function(e,n,t,o){var r={code:n,grammar:t,language:o,tokens:[]};e.hooks.run("before-tokenize",r);var i=r.tokens=e.tokenize(r.code,r.grammar,r.language);return e.hooks.run("after-tokenize",r),i}))}return e&&(n.__proto__=e),n.prototype=Object.create(e&&e.prototype),n.prototype.constructor=n,n.prototype.render=function(){var e=this.props,n=e.Prism,t=e.language,o=e.code,r=e.children,i=this.getThemeDict(this.props),a=n.languages[t];return r({tokens:function(e){for(var n=[[]],t=[e],o=[0],r=[e.length],i=0,a=0,s=[],c=[s];a>-1;){for(;(i=o[a]++)<r[a];){var u=void 0,m=n[a],g=t[a][i];if("string"==typeof g?(m=a>0?m:["plain"],u=g):(m=p(m,g.type),g.alias&&(m=p(m,g.alias)),u=g.content),"string"==typeof u){var y=u.split(l),f=y.length;s.push({types:m,content:y[0]});for(var h=1;h<f;h++)d(s),c.push(s=[]),s.push({types:m,content:y[h]})}else a++,n.push(m),t.push(u),o.push(0),r.push(u.length)}a--,n.pop(),t.pop(),o.pop(),r.pop()}return d(s),c}(void 0!==a?this.tokenize(n,o,a,t):[o]),className:"prism-code language-"+t,style:void 0!==i?i.root:{},getLineProps:this.getLineProps,getTokenProps:this.getTokenProps})},n}(i.Component);const g=m},71418:(e,n,t)=>{"use strict";t.d(n,{Z:()=>o});const o={plain:{color:"#9CDCFE",backgroundColor:"#1E1E1E"},styles:[{types:["prolog"],style:{color:"rgb(0, 0, 128)"}},{types:["comment"],style:{color:"rgb(106, 153, 85)"}},{types:["builtin","changed","keyword","interpolation-punctuation"],style:{color:"rgb(86, 156, 214)"}},{types:["number","inserted"],style:{color:"rgb(181, 206, 168)"}},{types:["constant"],style:{color:"rgb(100, 102, 149)"}},{types:["attr-name","variable"],style:{color:"rgb(156, 220, 254)"}},{types:["deleted","string","attr-value","template-punctuation"],style:{color:"rgb(206, 145, 120)"}},{types:["selector"],style:{color:"rgb(215, 186, 125)"}},{types:["tag"],style:{color:"rgb(78, 201, 176)"}},{types:["tag"],languages:["markup"],style:{color:"rgb(86, 156, 214)"}},{types:["punctuation","operator"],style:{color:"rgb(212, 212, 212)"}},{types:["punctuation"],languages:["markup"],style:{color:"#808080"}},{types:["function"],style:{color:"rgb(220, 220, 170)"}},{types:["class-name"],style:{color:"rgb(78, 201, 176)"}},{types:["char"],style:{color:"rgb(209, 105, 105)"}}]}},68793:(e,n,t)=>{"use strict";t.d(n,{Z:()=>r});var o=t(67294);const r=o.forwardRef((function(e,n){return o.createElement("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:2,stroke:"currentColor","aria-hidden":"true",ref:n},e),o.createElement("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"}))}))},62435:(e,n,t)=>{"use strict";t.d(n,{Z:()=>r});var o=t(67294);const r=o.forwardRef((function(e,n){return o.createElement("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:2,stroke:"currentColor","aria-hidden":"true",ref:n},e),o.createElement("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"}))}))},10195:(e,n,t)=>{"use strict";function o(e,n){let{target:t=document.body}=void 0===n?{}:n;if("string"!=typeof e)throw new TypeError(`Expected parameter \`text\` to be a \`string\`, got \`${typeof e}\`.`);const o=document.createElement("textarea"),r=document.activeElement;o.value=e,o.setAttribute("readonly",""),o.style.contain="strict",o.style.position="absolute",o.style.left="-9999px",o.style.fontSize="12pt";const i=document.getSelection(),a=i.rangeCount>0&&i.getRangeAt(0);t.append(o),o.select(),o.selectionStart=0,o.selectionEnd=e.length;let s=!1;try{s=document.execCommand("copy")}catch{}return o.remove(),a&&(i.removeAllRanges(),i.addRange(a)),r&&r.focus(),s}t.d(n,{Z:()=>o})}}]);