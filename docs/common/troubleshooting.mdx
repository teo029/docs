---
title: 'Troubleshooting'
---

import SnippetGroup from '@site/src/components/SnippetGroup';

# Troubleshooting

If you are having a problem with Ditto, first follow this guide.

## Reading the logs

First, you'll want to gather some debugging logs so you can see what's happening.

By default, Ditto only logs errors and warnings. We want to increase the log level so that we see more information.

### Setting the logs to Debug Level

In the following snippet, notice how we set the log level *before* initializing
Ditto. This is because Ditto performs some background tasks during
initialization related to file system access and authentication. You want to
begin gathering logs before Ditto is initialized in order to capture any
potential issues with those two background tasks.

<SnippetGroup name="online-playground" />

### Look for authentication success


Verify that your app id is the same on all devices. Look for a log line that contains `app_id`:

```
Ditto::new_from_uninit_ditto; app_id = 22389e28-9590-4cbf-b683-b3ac5ab2269e; site_id = 13769592724050309105; history_tracking = Disabled; presence_broadcast_targets = SmallPeersOnly
```

Then, look to see that the authentication succeeded. 

```
AuthClient: authentication request succeeded
```

If the client has a valid certificate locally, it will not try to re-authenticate until that certificate expires. You will see the line:

```
AuthClient: refreshing token in 302399 seconds
```

### Syncing with the Big Peer

A small peer syncronizes with the Big Peer using a WebSocket connection.

The debug logs will tell you each step to create a successful WebSocket connection to the big peer. 

First, the peer will discover the big peer and you'll see a `Discovered` event. 

```
peer_event = Discovered(WebsocketClientPeer(WebsocketClientRemotePeer { id: 4, transport_id: 3, local_announce: LocalAnnounceData { outer_protocol_version: 50, os: Generic, network_id: 2383820004, query_overlap_group: None, device_name: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537" }, connect_address: "wss://22389e28-9590-4cbf-b683-b3ac5ab2269e.cloud.ditto.live", routing_hint: RoutingHint(0), condition_sender: UnboundedSender { chan: Tx { inner: Chan { tx: Tx { block_tail: 0x242120, tail_position: 0 }, semaphore: Semaphore(0), rx_waker: AtomicWaker, tx_count: 2, rx_fields: "..." } } } }))
```

However, the small peer has not yet established a successful connection with
this Big Peer instance quite yet. In order to verify that the connection has
succeeded, you will see that the connection has succeeded with the
`ConnectionEstablished` event.  

```
peer_event = ConnectionEstablished(PeerConnection { id: 4, connection_type: WsClient, remote_announce: Announce { outer_protocol_version: Some('2'), os: Some(Linux), network_id: Some(1356909299), query_overlap_group: None, device_name: Some("Ditto Cloud") }, remote_peer_id: SiteIdAndPubKey([...])
```

You will then see that the underlying physical replication session has been
started with `phy started`. The remote key represents the public key
`pkSOME_BYTES` of the Big Peer instance you are connected to. 

The following is just an example, and not a guaranteed static identifer.

```
phy started; remote = pkAocCgkMCh0wD6Y83qm2UHtiN6264Jivvimg6xdR778ODaKODFKw
```

And then you will see something like this as the final message that the WebSocket client has successfully connected. 

```
VirtConnElectedNewConn { new_conn: Some((4, WsClient)), old_conn: None }
```

### Verifying correct permissions

Once the peer is authorized, it will begin to print both the known local and
remote permissions for this peer at a regular interval (30 seconds). Local
permissions refer to the current peer that is running on the device. Remote
permissions refer to any permissions from other peers that it is currently
connected to.

```
local permission: Permission { read: PermissionRules { everything: true, queries_by_collection: {} }, write: PermissionRules { everything: true, queries_by_collection: {} } }, remote permission: Permission { read: PermissionRules { everything: true, queries_by_collection: {} }, write: PermissionRules { everything: true, queries_by_collection: {} } }
```

You will want to verify that these permissions are correct and what you expect. A peer cannot subscribe to a colleciton that it is not authorized to do so.

The Big Peer remote permission will always be the following by default. This
means that the big peer will have access to read and write. This is another way
to verify that the big peer is connected and replication has started.

```
write: { everything: true, queries_by_collection: {} }
read: { everything: true, queries_by_collection: {} }
```

### Verifying correct subscriptions

Once the peer is authorized, it will begin to print the active subscriptions at
a regular interval (30seconds).

```
local subscription: Subscription { everything: false, queries: {"__presence": {Query { expr: "_id != '13407763363308666127' && v == 3 && t > 1682717143093", order_by: [], limit: None, offset: None }}, "tasks": {Query { expr: "isDeleted == false", order_by: [], limit: None, offset: None }}} }, remote subscription: Subscription { everything: true, queries: {} }
```

Every peer includes by default some internal subscriptions. These are denoted by
a double underscore (`__`) before the collection name. For example, you will
likely see a subscription to the `__presence` collection.

```
{"__presence": { expr: "_id != '13407763363308666127' && v == 3 && t > 1682717143093", order_by: [], limit: None, offset: None }}
```

Similar to the permissions, you will also see a list of remote subscriptions.
The big peer subscribes to everything, so you will see the following line which
references the big peer:

```
remote subscription: Subscription { everything: true, queries: {} }
```

Application-level subscriptions will be listed by collection. For exmaple, for a samll peer subscribing to all tasks that are not deleted, you will see:

```
"tasks": {Query { expr: "isDeleted == false", order_by: [], limit: None, offset: None }}} 
```

### Writes

For each write that is made to the local database, you will see a message like 

```
Write txn committed; txn_id = 40; originator = User
```

and

```
Notifying a database change; transaction = 40
```

Then, ditto will print again the active subscriptions and permissions to the log as in the above section.

The small peer will then create what is called an "update file" -- you will see this in the logs as
```
Creating a sending update, sending_update_path = "pkA/pkB/sending_update"
```

pkA and pkB are the two peers involved in the exchange.

Once the update file has completed, you will see the following line, which
indicates that the local peer is ready to send the new update to the remote
peer. This time elapsed is only for local generation of the update file. The
local write still has not been syncronized to other peers.  

```
update creation done; since_index = 40; new_update_created = true; num_docs = 1; elapsed = 908us 708ns
```

Once the process has completed successfully on the local peer, you will see
```
No next update chunk to send - setting is_ready to false
No message to send
```

This indicates that the update file sync process has been successful, and the local replication process has completed.

### Troubleshooting

#### Did you copy your playground token and App ID correctly? 

If the app_id is not the same on all devices, you should do the following:

1. Login to the [Portal](https://portal.ditto.live) 
1. Go to your App.
1. Make sure that the portal playground token is the same as the value you are using in your code.

![Online Playground enabled in the Ditto Portal](./mesh-network/portal-playground-setting.png)

#### Did your device connect to the internet?

`OnlinePlayground` applications must connect to the Big Peer first
*before* going offline. [Read more about online playground](./mesh-network/online-playground).

#### Do you have a firewall or proxy enabled that is blocking Ditto's connection to the Big Peer?

A proxy may either either block connections or cause errors in the log by substituting its own
TLS certificate: `invalid certificate: UnknownIssuer`. If you see this log message you will either
need to get Ditto unblocked or add the CA certificate to the Small Peer's trusted certificate store.

Verify that you can reach the following endpoints. You should see the output exactly as written below:

```
> nc -v MY_APP_ID.cloud.ditto.live 443
Connection to MY_APP_ID.cloud.ditto.live port 443 [tcp/https] succeeded!
^C
```

```
> curl -i https://MY_APP_ID.cloud.ditto.live/_ditto/auth/login
HTTP/1.1 405 Method Not Allowed
Date: Fri, 30 Sep 2022 02:03:36 GMT
Content-Type: text/plain; charset=utf-8
Content-Length: 23
Connection: keep-alive
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true
Access-Control-Allow-Methods: GET, PUT, POST, DELETE, PATCH, OPTIONS
Access-Control-Allow-Headers: X-DITTO-ENSURE-INSERT,X-HYDRA-ENSURE-INSERT,X-DITTO-CLIENT-ID,X-HYDRA-CLIENT-ID,Accept,Referer,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,X-Forwarded-For
Access-Control-Max-Age: 1728000

HTTP method not allowed% 
```

If this test passes, next check to see if WebSockets are blocked on your
machine. Some corporate networks, firewalls, or proxies block the HTTP upgrade
packet that tells the WebSocket server to keep the connection alive. Check with
your IT administrator to see if your computer is configured to block WebSocket connections.

### Online with Authentication

#### Check permissions

Verify this isn't simply a permission misconfiguration issue. Are you able to
try the operations with global read and write permission to verify that sync succeeds
in this case? 


#### Did you follow the [tutorial](./security/authentication#tutorial)?

The tutorial is your best guide for implementing this correctly. See the [code on GitHub for a complete working example](https://github.com/getditto/samples/tree/main/authentication).

#### Is your authentication server behind `https` and open? 


#### Common mistakes

1. Ensure that Ditto's Big Peer server hosted in the United States on AWS can send a POST request to your authentication server. Send a POST request to your server with a JSON stringified body.
1. `authenticationExpiringSoon` and `authenticationRequired` both need to be
implemented according to the [sample
code](./security/authentication#creating-your-client).
1. Do not create subscriptions inside the callbacks. These callbacks are only
called on first launch and when the certificate expires.
1. Keep a strong reference to the AuthClient for the duration of the 


#### Verify that your webhook provider name is [correctly copied in the Ditto portal](./security/authentication#login).

The provider name given to the Ditto Client must match a provider name in the Portal (e.g., `my-auth`).


![Sample Authentication Webhook Endpoint in the Portal](./security/sample-authentication-webhook-endpoint.png)


#### What are the permissions that you are returning for this client? 

Are the permissions allowing write and read access to the collection? Are you able to try the operations with global read and write permission to verify it succeeds in this case?

#### Is your AuthClient becoming garbage collected?

Ensure that you keep a reference to the AuthClient in scope for the duration that Ditto is also active.  You should attach the dittoAuth variable to the object so it does not get garbage collected. 

For example:
```
namespace Sync {
    public class DittoClient {
        private Ditto ditto;
+       private DittoAuthDelegate dittoAuthDelegate;

        public DittoClient(string appId, string id, string jwt) {
+          dittoAuthDelegate = new DittoAuthDelegate(id, jwt);
           ditto = new Ditto(identity);
        }
       ...
   }
}
```

### How can I show how many peers are connected?

DItto offers an API that you can use to watch all of the peers and their
respective transports that are connected to the current Ditto instance. Use the
`ditto.presence` API to get real-time updates whenever Ditto's network topology
changes. 


### Bluetooth 

1. Turn Use Location on
1. Turn Bluetooth Scanning on
1. Are permissions set correctly? See [installation](../installation).
1. Go to your OS-level permissions for Bluetooth and clear the app permissions for your application.
1. Delete the app, install it again, and open it. Does it ask for Bluetooth permissions?
1. Android only: are you calling `ditto.refreshPermissions()`?

### Apple Wireless Direct Link, P2P-Wifi, Wifi Aware 

1. Are permissions set correctly? See [installation](../installation).
1. Go to your OS-level permissions and clear the app permissions for your application.
1. Delete the app, install it again, and open it. Does it ask for location permissions?
1. If you are using a custom `TransportConfig`, make sure you have enabled all peer-to-peer transports using `enableAllPeerToPeer()`.

### Local Area Network (LAN)

1. Are permissions set correctly? See [installation](../installation).
1. Are both devices connected to the same WiFi network?
1. Check your router settings and see the [LAN troubleshooting guide](./mesh-network/supported-transports/#local-area-network).

## Synchronization seems slow, or comes to a halt over time

Ensure that you are only creating a fixed number of live queries, with a smaller amount of data. Do not use `findAll()`. 

## App is using too much memory, why?

Use profiling tools for your platform to better understand where the memory leak
may be occurring. 

A common issue we see in reactive apps is a failure to dispose of resources as
conditions change. Your app could create a large accumulation of publishers that
infinitely grow. Every liveQuery and subscription in ditto must be explicitly
stopped using the `stop` or `cancel` API. See [snycing data](./concepts/syncing-data) for more information.

## Debugging Blocked Transactions

:::info 
💡 This section only discusses blocked transactions on **native** platforms (e.g. iOS, Android, Windows, Linux). Ditto in web browsers operates sufficiently differently and isn’t covered here.
:::indo

Blocked write transactions will automatically retry until they succeed. A
blocked write transaction will never crash. Howewever, blocked write
transactions are a common cause for poor database performance. Long running blocks are
generally bad since they mean that nothing else can be writing to the
database during this time. This could manifest itself as one of many problems:

- Unresponsive UI: an interaction might try to update a document, but is blocked by an existing write transaction
- Slow sync: new updates cannot be integrated into the store, since they’re blocked by another write transaction

A blocked write transaction can hint that something is wrong with the application code, or at a deeper level in Ditto. This page contains some tips & tricks to help understand the situation.

The process of unblocking is automatic and you don’t need to write any code to handle this. However, you can drastically reduce the chance of blocking transactions by **making sure a device is only syncing the data it really needs**.

### What is a “blocked” transaction?

At any given time, there can be only one write transaction. Any subsequent
attempts to open another write transaction will become blocked
until the existing write transaction finishes. 

### Read vs. Write Transactions

Read transactions operate differently to write transactions.

Read transactions cannot be blocked and can run in parallel with write transactions. Read transactions don’t block each other, don’t block write transactions, and aren’t blocked by write transactions.


If a write transaction is blocked, Ditto will log a message with increasing severity every 10s.

| Time (t) a transaction has been blocked | Log Level |
| --- | --- |
| t ≤ 30s | DEBUG |
| 31s < t ≤ 120s | WARN |
| 120s < t | ERROR |

To see these logs in the database, it’s important to have a minimum log level
set. Transactions that are blocked for over 2 minutes should always be visible
in the logs.

If `INFO` level is used, then `INFO`, `WARN`,  and `ERROR` messages will all be
included in the logs. This means any write transactions blocking for more than
30s should always be visible in the logs.

### Reading the Logs

If a write transaction is blocked, the device logs will look something like the following. In this example we can see a write transaction was blocked for a total of 150s (or 2.5 minutes).

![204421276-4eee2f5d-806d-4d0d-af3e-d96a035d97a0.png](troubleshooting.png)

As time progressed, Ditto complained more and more loudly (starting with `DEBUG`
logs before eventually logging at `ERROR` level). Eventually the existing
transaction finished and blocked transaction was was able to proceed.

The write transaction which was blocked was for a Ditto internal component. This is identified by
`“originator=Internal”`. 

The existing, long-running write transaction which was causing the block was a
user call in the public SDK. This is identified by
`“blocked_by=User”`. So a user-level write transaction is blocking some internal
workload. This is not *necessarily* a problem, as the internal system will catch up eventually.

### Originators

The three values you’ll see for `originator` and `blocked_by` are: 

| Originator / Blocked By | Description |
| --- | --- |
| “User" | Any user-level API which modifies data. |
| “Internal" | An internal job (presence data, DB maintenance, etc.). |
| “Replication" | Updating the store with data received via replication. |

## Causes of Blocked Transactions

This section presents a few examples blocked transaction scenarios, how they would appear in logs, and what they might mean.

### User blocks User

An application might block its own write transactions by performing multiple writes at the same time in different places. If one is slow (perhaps it does too much work, or perhaps it reaches out to external APIs, etc.) then the other write transactions will block until it finishes.

```swift
// Thread/Queue 1 (starts first):
{
   // Somewhere in the app, a long running write transaction exists
   ditto.store["people"].findByID(docID).update { mutableDoc in
	// Most update tasks are quick, but a developer might
	// doing something slow within the update block:
	let apiData = getDataFromASlowExternalAPICall() // <-- !!!!
		
	mutableDoc?["age"] = apiData.age
	mutableDoc?["ownedCars"].set(DittoCounter())
	mutableDoc?["ownedCars"].counter?.increment(by: apiData.count)
   }
}

// Thread/Queue 2 (starts second):
{
    // Somewhere else in the app, concurrently (e.g. background thread or queue)
    // another write transaction tries to update a document. 
    //
    // This will block until the "people" update block above completes.
    let docID = try! ditto.store["settings"].upsert([
        "_id": "abc123",
	"preference": 31,
    ])
}
```

In logs, this scenario will look like the following:

`LOG_LEVEL: Waiting for write transaction (elapsed: XXs), originator=User blocked_by=User`

Note that `“User”` is blocking `“User”`. This *could* be temporary, but it could also be a deadlock which is much worse. See below.

### User deadlocks User

```swift
// Start a write transaction:
ditto.store["people"].findByID(docID).update { mutableDoc in
    // Start a write transaction _within_ a write transacton.
    // !! Deadlocks !!
    let docID = try! ditto.store["settings"].upsert([
        "_id": "abc123",
        "preference": 31,
    ]) 

    // ...
}
```

You cannot start a write transaction within a write transaction. The result will be a deadlock which **never** resolves itself. This might manifest itself in the logs as: 

`LOG_LEVEL: Waiting for write transaction (elapsed: XXs), originator=User blocked_by=User`

Note that User blocking User doesn’t necessarily mean a deadlock. It might
merely be a long running write transaction and this situation might be expected
depending on the task. However, if the transaction never unblocks and the log
messages at `ERROR` level continue forever - you have a strong indication that
there’s a deadlock and should investigate the application code.

### Replication blocks User

```swift
// Somewhere in the app, a simple enough user write transaction is happening.
// There's no other user write transaction happening concurrently in the
// app, yet the update seems blocked or slow and UI might seems slugglish
// or unresponsive.
let docID = try! ditto.store["settings"].upsert([
    "_id": "abc123",
    "preference": 31,
])
```

From the application code, it might not be obvious what the problem is. By looking in the logs, you might get a hint. For instance:

`LOG_LEVEL: Waiting for write transaction (elapsed: XXs), originator=User blocked_by=Replication`

Here we can see that replication is blocking our user’s write transaction. This might happen if we’ve just received a large amount of sync data from another peer. Most commonly, happens during initial sync (either with the Big Peer, or joining a mesh for the first time, or re-joining a mesh after an extended period away).

This scenario is something to be aware of, but will resolve itself automatically once the sync is complete. The user transaction will eventually unblock and continue when replication has finished updating the store.  

### Replication blocks Replication

If you see the following in logs, it’s an indication that one replication session with a remote peer is blocking another: 

`LOG_LEVEL: Waiting for write transaction (elapsed: XXs), originator=Replication blocked_by=Replication`

This can happen when the device has received large amounts of data from multiple peers **simultaneously** and must update the database with the changes it received from each. Ditto can only update the database with sync data from remote peers one at a time, so the other updates must wait their turn.

This scenario is most likely to happen during a large initial sync - either with the Big Peer **at the same time** as with nearby devices, or just with **multiple** nearby devices when joining a mesh for the first time (or re-joining after an extended period away).

This scenario is something to be aware of, but will resolve itself automatically once the sync is complete. You can drastically reduce the chance of this type of blocking transaction by **making sure each device is only syncing the data it really needs**.

### User or Replication blocks Internal

A long running write transaction might block an internal job. This scenario will be the least obvious to spot and it might not be obvious that it’s happening at all. It’s also the least likely to cause actual problems.

```swift
// Somewhere in the app, a long running write transaction exists
ditto.store["people"].findByID(docID).update { mutableDoc in
    // Most update tasks are quick, but you might
    // doing something slow within the update block
    let apiData = getDataFromASlowExternalAPICall() // <-- !!!!

    mutableDoc?["age"] = apiData.age
    mutableDoc?["ownedCars"].set(DittoCounter())
    mutableDoc?["ownedCars"].counter?.increment(by: apiData.count)
}
```

In logs, you might see the following:

`LOG_LEVEL: Waiting for write transaction (elapsed: XXs), originator=Internal blocked_by=User`

or:

`LOG_LEVEL: Waiting for write transaction (elapsed: XXs), originator=Internal blocked_by=Replication`

i.e. something is blocking `Internal`.

This might not have any observable effect, but if it does, it is most likely to manifest as slow/unreliable Ditto Bus connections, an inaccurate presence viewer, or slow/unreliable multihop replication. Ditto's internal mesh presence component must persist an update every 30s for these systems to keep working. If presence can’t do this because it’s blocked by another write transaction, those systems will begin to to fail until presence can successfully write its next update. This scenario should automatically recover just fine once the blocking write transaction finishes.

## Still stuck?

If you continue to have problems, please email us at
[support@ditto.live](mailto:support@ditto.live) or [login to your Ditto
account](https://portal.ditto.live) to chat with the support bot in the lower
right corner of your screen. An engineer will reach out to you shortly.